# 目录

## [1 前言](ch01.md#1-preface)
  + [1.1 小型嵌入式系统中的多任务处理](ch01.md#11-multitasking-in-small-embedded-systems)
    + [1.1.1 关于FreeRTOS内核](ch01.md#111-about-the-freertos-kernel)
    + [1.1.2 价值主张](ch01.md#112-value-proposition)
    + [1.1.3 关于术语的说明](ch01.md#113-a-note-about-terminology)
    + [1.1.4 为什么使用RTOS？](ch01.md#114-why-use-an-rtos)
    + [1.1.5 FreeRTOS内核特性](ch01.md#115-freertos-kernel-features)
    + [1.1.6 许可证，以及FreeRTOS、OpenRTOS和SafeRTOS系列](ch01.md#116-licensing-and-the-freertos-openrtos-and-safertos-family)
  + [1.2 包含的源文件和项目](ch01.md#12-included-source-files-and-projects)
    + [1.2.1 获取本书附带的示例](ch01.md#121-obtaining-the-examples-that-accompany-this-book)

## [2 FreeRTOS内核发行版](ch02.md#2-the-freertos-kernel-distribution)
  + [2.1 简介](ch02.md#21-introduction)
  + [2.2 了解FreeRTOS发行版](ch02.md#22-understanding-the-freertos-distribution)
    + [2.2.1 定义：FreeRTOS端口](ch02.md#221-definition-freertos-port)
    + [2.2.2 构建FreeRTOS](ch02.md#222-building-freertos)
    + [2.2.3 FreeRTOSConfig.h](ch02.md#223-freertosconfigh)
    + [2.2.4 官方发行版](ch02.md#224-official-distributions)
    + [2.2.5 所有端口通用的FreeRTOS源文件](ch02.md#225-freertos-source-files-common-to-all-ports)
    + [2.2.6 特定于某个端口的FreeRTOS源文件](ch02.md#226-freertos-source-files-specific-to-a-port)
    + [2.2.7 包含路径](ch02.md#227-include-paths)
    + [2.2.8 头文件](ch02.md#228-header-files)
  + [2.3 演示应用程序](ch02.md#23-demo-applications)
  + [2.4 创建FreeRTOS项目](ch02.md#24-creating-a-freertos-project)
    + [2.4.1 适配提供的演示项目之一](ch02.md#241-adapting-one-of-the-supplied-demo-projects)
    + [2.4.2 从头开始创建新项目](ch02.md#242-creating-a-new-project-from-scratch)
  + [2.5 数据类型和编码风格指南](ch02.md#25-data-types-and-coding-style-guide)
    + [2.5.1 数据类型](ch02.md#251-data-types)
    + [2.5.2 变量名](ch02.md#252-variable-names)
    + [2.5.3 函数名](ch02.md#253-function-names)
    + [2.5.4 格式化](ch02.md#254-formatting)
    + [2.5.5 宏名称](ch02.md#255-macro-names)
    + [2.5.6 过度类型转换的理由](ch02.md#256-rationale-for-excessive-type-casting)

## [3 堆内存管理](ch03.md#3-heap-memory-management)
  + [3.1 简介](ch03.md#31-introduction)
    + [3.1.1 前提条件](ch03.md#311-prerequisites)
    + [3.1.2 范围](ch03.md#312-scope)
    + [3.1.3 在静态和动态内存分配之间切换](ch03.md#313-switching-between-static-and-dynamic-memory-allocation)
    + [3.1.4 使用动态内存分配](ch03.md#314-using-dynamic-memory-allocation)
    + [3.1.5 动态内存分配选项](ch03.md#315-options-for-dynamic-memory-allocation)
  + [3.2 示例内存分配方案](ch03.md#32-example-memory-allocation-schemes)
    + [3.2.1 Heap_1](ch03.md#321-heap_1)
    + [3.2.2 Heap_2](ch03.md#322-heap_2)
    + [3.2.3 Heap_3](ch03.md#323-heap_3)
    + [3.2.4 Heap_4](ch03.md#324-heap_4)
    + [3.2.5 Heap_5](ch03.md#325-heap_5)
    + [3.2.6 初始化Heap_5: vPortDefineHeapRegions() API函数](ch03.md#326-initialising-heap_5-the-vportdefineheapregions-api-function)
  + [3.3 与堆相关的实用函数和宏](ch03.md#33-heap-related-utility-functions-and-macros)
    + [3.3.1 定义堆的起始地址](ch03.md#331-defining-the-heap-start-address)
    + [3.3.2 xPortGetFreeHeapSize() API函数](ch03.md#332-the-xportgetfreeheapsize-api-function)
    + [3.3.3 xPortGetMinimumEverFreeHeapSize() API函数](ch03.md#333-the-xportgetminimumeverfreeheapsize-api-function)
    + [3.3.4 vPortGetHeapStats() API函数](ch03.md#334-the-vportgetheapstats-api-function)
    + [3.3.5 收集每个任务的堆使用统计信息](ch03.md#335-collecting-per-task-heap-usage-statistics)
    + [3.3.6 malloc失败钩子函数](ch03.md#336-malloc-failed-hook-functions)
    + [3.3.7 将任务堆栈放在快速内存中](ch03.md#337-placing-task-stacks-in-fast-memory)
  + [3.4 使用静态内存分配](ch03.md#34-using-static-memory-allocation)
    + [3.4.1 启用静态内存分配](ch03.md#341-enabling-static-memory-allocation)
    + [3.4.2 静态内部内核内存](ch03.md#342-static-internal-kernel-memory)
      + [3.4.2.1 vApplicationGetTimerTaskMemory](ch03.md#3421-vapplicationgettimertaskmemory)
      + [3.4.2.2 vApplicationGetIdleTaskMemory](ch03.md#3422-vapplicationgetidletaskmemory)

## [4 任务管理](ch04.md#4-task-management)
  + [4.1 简介](ch04.md#41-introduction)
    + [4.1.1 范围](ch04.md#411-scope)
  + [4.2 任务函数](ch04.md#42-task-functions)
  + [4.3 顶层任务状态](ch04.md#43-top-level-task-states)
  + [4.4 任务创建](ch04.md#44-task-creation)
    + [4.4.1 xTaskCreate() API 函数](ch04.md#441-the-xtaskcreate-api-function)
  + [4.5 任务优先级](ch04.md#45-task-priorities)
    + [通用调度器](ch04.md#451-generic-scheduler)
    + [架构优化调度器](ch04.md#452-architecture-optimized-scheduler)
  + [4.6 时间测量和滴答中断](ch04.md#46-time-measurement-and-the-tick-interrupt)
  + [4.7 扩展“未运行”状态](ch04.md#47-expanding-the-not-running-state)
    + [4.7.1 “阻塞”状态](ch04.md#471-the-blocked-state)
    + [4.7.2 “挂起”状态](ch04.md#472-the-suspended-state)
    + [4.7.3 就绪状态](ch04.md#473-the-ready-state)
    + [4.7.4 完成状态转换图](ch04.md#474-completing-the-state-transition-diagram)
    + [4.7.5 vTaskDelayUntil() API 函数](ch04.md#475-the-vtaskdelayuntil-api-function)
  + [4.8 空闲任务和空闲任务钩子](ch04.md#48-the-idle-task-and-the-idle-task-hook)
    + [4.8.1 空闲任务钩子函数](ch04.md#481-idle-task-hook-functions)
    + [4.8.2 空闲任务钩子函数实现的限制](ch04.md#482-limitations-on-the-implementation-of-idle-task-hook-functions)
  + [4.9 改变任务的优先级](ch04.md#49-changing-the-priority-of-a-task)
    + [4.9.1 vTaskPrioritySet() API 函数](ch04.md#491-the-vtaskpriorityset-api-function)
    + [4.9.2 uxTaskPriorityGet() API 函数](ch04.md#492-the-uxtaskpriorityget-api-function)
  + [4.10 删除任务](ch04.md#410-deleting-a-task)
    + [4.10.1 vTaskDelete() API 函数](ch04.md#4101-the-vtaskdelete-api-function)
  + [4.11 线程局部存储和可重入性](ch04.md#411-thread-local-storage-and-reentrancy)
    + [4.11.1 C 运行时线程局部存储实现](ch04.md#4111-c-runtime-thread-local-storage-implementations)
    + [4.11.2 自定义 C 运行时线程局部存储](ch04.md#4112-custom-c-runtime-thread-local-storage)
    + [4.11.3 应用程序线程局部存储](ch04.md#4113-application-thread-local-storage)
  + [4.12 调度算法](ch04.md#412-scheduling-algorithms)
    + [4.12.1 任务状态和事件回顾](ch04.md#4121-a-recap-of-task-states-and-events)
    + [4.12.2 选择调度算法](ch04.md#4122-selecting-the-scheduling-algorithm)
    + [4.12.3 带时间片的优先抢占式调度](ch04.md#4123-prioritized-preemptive-scheduling-with-time-slicing)
    + [4.12.4 不带时间片的优先抢占式调度](ch04.md#4124-prioritized-preemptive-scheduling-without-time-slicing)
    + [4.12.5 协同调度](ch04.md#4125-cooperative-scheduling)

## [5 队列管理](ch05.md#5-queue-management)
  + [5.1 简介](ch05.md#51-introduction)
    + [5.1.1 范围](ch05.md#511-scope)
  + [5.2 队列的特性](ch05.md#52-characteristics-of-a-queue)
    + [5.2.1 数据存储](ch05.md#521-data-storage)
    + [5.2.2 多任务访问](ch05.md#522-access-by-multiple-tasks)
    + [5.2.3 读队列时阻塞](ch05.md#523-blocking-on-queue-reads)
    + [5.2.4 写队列时阻塞](ch05.md#524-blocking-on-queue-writes)
    + [5.2.5 在多个队列上阻塞](ch05.md#525-blocking-on-multiple-queues)
    + [5.2.6 创建队列：静态分配和动态分配的队列](ch05.md#526-creating-queues-statically-allocated-and-dynamically-allocated-queues)
  + [5.3 使用队列](ch05.md#53-using-a-queue)
    + [5.3.1 xQueueCreate() API 函数](ch05.md#531-the-xqueuecreate-api-function)
    + [5.3.2 xQueueSendToBack() 和 xQueueSendToFront() API 函数](ch05.md#532-the-xqueuesendtoback-and-xqueuesendtofront-api-functions)
    + [5.3.3 xQueueReceive() API 函数](ch05.md#533-the-xqueuereceive-api-function)
    + [5.3.4 uxQueueMessagesWaiting() API 函数](ch05.md#534-the-uxqueuemessageswaiting-api-function)
  + [5.4 从多个源接收数据](ch05.md#54-receiving-data-from-multiple-sources)
  + [5.5 处理大数据或可变大小的数据](ch05.md#55-working-with-large-or-variable-sized-data)
    + [5.5.1 排队指针](ch05.md#551-queuing-pointers)
    + [5.5.2 使用队列发送不同类型和长度的数据[^9]](ch05.md#552-using-a-queue-to-send-different-types-and-lengths-of-data9)
  + [5.6 从多个队列接收数据](ch05.md#56-receiving-from-multiple-queues)
    + [5.6.1 队列集](ch05.md#561-queue-sets)
    + [5.6.2 xQueueCreateSet() API 函数](ch05.md#562-the-xqueuecreateset-api-function)
    + [5.6.3 xQueueAddToSet() API 函数](ch05.md#563-the-xqueueaddtoset-api-function)
    + [5.6.4 xQueueSelectFromSet() API 函数](ch05.md#564-the-xqueueselectfromset-api-function)
    + [5.6.5 更现实的队列集使用案例](ch05.md#565-more-realistic-queue-set-use-cases)
  + [5.7 使用队列创建邮箱](ch05.md#57-using-a-queue-to-create-a-mailbox)
    + [5.7.1 xQueueOverwrite() API 函数](ch05.md#571-the-xqueueoverwrite-api-function)
    + [5.7.2 xQueuePeek() API 函数](ch05.md#572-the-xqueuepeek-api-function)

## [6 软件定时器管理](ch06.md#6-software-timer-management)
  + [6.1 章节介绍和范围](ch06.md#61-chapter-introduction-and-scope)
    + [6.1.1 范围](ch06.md#611-scope)
  + [6.2 软件定时器回调函数](ch06.md#62-software-timer-callback-functions)
  + [6.3 软件定时器的属性和状态](ch06.md#63-attributes-and-states-of-a-software-timer)
    + [6.3.1 软件定时器的周期](ch06.md#631-period-of-a-software-timer)
    + [6.3.2 单次触发和自动重载定时器](ch06.md#632-one-shot-and-auto-reload-timers)
    + [6.3.3 软件定时器的状态](ch06.md#633-software-timer-states)
  + [6.4 软件定时器的上下文](ch06.md#64-the-context-of-a-software-timer)
    + [6.4.1 RTOS守护进程（定时器服务）任务](ch06.md#641-the-rtos-daemon-timer-service-task)
    + [6.4.2 定时器命令队列](ch06.md#642-the-timer-command-queue)
    + [6.4.3 守护进程任务调度](ch06.md#643-daemon-task-scheduling)
  + [6.5 创建并启动软件定时器](ch06.md#65-creating-and-starting-a-software-timer)
    + [6.5.1 xTimerCreate() API函数](ch06.md#651-the-xtimercreate-api-function)
    + [6.5.2 xTimerStart() API函数](ch06.md#652-the-xtimerstart-api-function)
  + [6.6 定时器ID](ch06.md#66-the-timer-id)
    + [6.6.1 vTimerSetTimerID() API函数](ch06.md#661-the-vtimersettimerid-api-function)
    + [6.6.2 pvTimerGetTimerID() API函数](ch06.md#662-the-pvtimergettimerid-api-function)
  + [6.7 更改定时器的周期](ch06.md#67-changing-the-period-of-a-timer)
    + [6.7.1 xTimerChangePeriod() API函数](ch06.md#671-the-xtimerchangeperiod-api-function)
  + [6.8 重置软件定时器](ch06.md#68-resetting-a-software-timer)
    + [6.8.1 xTimerReset() API函数](ch06.md#681-the-xtimerreset-api-function)

## [7 中断管理](ch07.md#7-interrupt-management)
  + [7.1 简介](ch07.md#71-introduction)
    + [7.1.1 事件](ch07.md#711-events)
    + [7.1.2 范围](ch07.md#712-scope)
  + [7.2 从ISR中使用FreeRTOS API](ch07.md#72-using-the-freertos-api-from-an-isr)
    + [7.2.1 中断安全API](ch07.md#721-the-interrupt-safe-api)
    + [7.2.2 使用单独的中断安全API的好处](ch07.md#722-the-benefits-of-using-a-separate-interrupt-safe-api)
    + [7.2.3 使用单独的中断安全API的缺点](ch07.md#723-the-disadvantages-of-using-a-separate-interrupt-safe-api)
    + [7.2.4 xHigherPriorityTaskWoken 参数](ch07.md#724-the-xhigherprioritytaskwoken-parameter)
    + [7.2.5 portYIELD_FROM_ISR() 和 portEND_SWITCHING_ISR() 宏](ch07.md#725-the-portyield_from_isr-and-portend_switching_isr-macros)
  + [7.3 延迟中断处理](ch07.md#73-deferred-interrupt-processing)
  + [7.4 用于同步的二进制信号量](ch07.md#74-binary-semaphores-used-for-synchronization)
    + [7.4.1 xSemaphoreCreateBinary() API 函数](ch07.md#741-the-xsemaphorecreatebinary-api-function)
    + [7.4.2 xSemaphoreTake() API 函数](ch07.md#742-the-xsemaphoretake-api-function)
    + [7.4.3 xSemaphoreGiveFromISR() API 函数](ch07.md#743-the-xsemaphoregivefromisr-api-function)
    + [7.4.4 改进示例7.1中使用的任务实现](ch07.md#744-improving-the-implementation-of-the-task-used-in-example-71)
  + [7.5 计数信号量](ch07.md#75-counting-semaphores)
    + [7.5.1 xSemaphoreCreateCounting() API 函数](ch07.md#751-the-xsemaphorecreatecounting-api-function)
  + [7.6 将工作推迟到RTOS守护任务](ch07.md#76-deferring-work-to-the-rtos-daemon-task)
    + [7.6.1 xTimerPendFunctionCallFromISR() API 函数](ch07.md#761-the-xtimerpendfunctioncallfromisr-api-function)
  + [7.7 在中断服务例程中使用队列](ch07.md#77-using-queues-within-an-interrupt-service-routine)
    + [7.7.1 xQueueSendToFrontFromISR() 和 xQueueSendToBackFromISR() API 函数](ch07.md#771-the-xqueuesendtofrontfromisr-and-xqueuesendtobackfromisr-api-functions)
    + [7.7.2 从ISR中使用队列时的注意事项](ch07.md#772-considerations-when-using-a-queue-from-an-isr)
  + [7.8 中断嵌套](ch07.md#78-interrupt-nesting)
    + [7.8.1 致ARM Cortex-M[^22] 和 ARM GIC 用户的说明](ch07.md#781-a-note-to-arm-cortex-m22-and-arm-gic-users)

## [8 资源管理](ch08.md#8-resource-management)
  + [8.1 章节介绍和范围](ch08.md#81-chapter-introduction-and-scope)
    + [8.1.1 互斥](ch08.md#811-mutual-exclusion)
    + [8.1.2 范围](ch08.md#812-scope)
  + [8.2 关键段和挂起调度器](ch08.md#82-critical-sections-and-suspending-the-scheduler)
    + [8.2.1 基本关键段](ch08.md#821-basic-critical-sections)
    + [8.2.2 挂起（或锁定）调度器](ch08.md#822-suspending-or-locking-the-scheduler)
    + [8.2.3 vTaskSuspendAll() API 函数](ch08.md#823-the-vtasksuspendall-api-function)
    + [8.2.4 xTaskResumeAll() API 函数](ch08.md#824-the-xtaskresumeall-api-function)
  + [8.3 互斥锁（和二值信号量）](ch08.md#83-mutexes-and-binary-semaphores)
    + [8.3.1 xSemaphoreCreateMutex() API 函数](ch08.md#831-the-xsemaphorecreatemutex-api-function)
    + [8.3.2 优先级反转](ch08.md#832-priority-inversion)
    + [8.3.3 优先级继承](ch08.md#833-priority-inheritance)
    + [8.3.4 死锁（或致命拥抱）](ch08.md#834-deadlock-or-deadly-embrace)
    + [8.3.5 递归互斥锁](ch08.md#835-recursive-mutexes)
    + [8.3.6 互斥锁和任务调度](ch08.md#836-mutexes-and-task-scheduling)
  + [8.4 门控任务](ch08.md#84-gatekeeper-tasks)
    + [8.4.1 重写 vPrintString() 以使用门控任务](ch08.md#841-re-writing-vprintstring-to-use-a-gatekeeper-task)

## [9 事件组](ch09.md#9-事件组)
  + [9.1 章节介绍和范围](ch09.md#91-章节介绍和范围)
    + [9.1.1 范围](ch09.md#911-范围)
  + [9.2 事件组的特性](ch09.md#92-事件组的特性)
    + [9.2.1 事件组、事件标志和事件位](ch09.md#921-事件组-事件标志和事件位)
    + [9.2.2 关于EventBits_t数据类型的更多信息](ch09.md#922-关于eventbits_t数据类型的更多信息)
    + [9.2.3 多任务访问](ch09.md#923-多任务访问)
    + [9.2.4 使用事件组的实际示例](ch09.md#924-使用事件组的实际示例)
  + [9.3 使用事件组进行事件管理](ch09.md#93-使用事件组进行事件管理)
    + [9.3.1 xEventGroupCreate() API函数](ch09.md#931-xeventgroupcreate-api函数)
    + [9.3.2 xEventGroupSetBits() API函数](ch09.md#932-xeventgroupsetbits-api函数)
    + [9.3.3 xEventGroupSetBitsFromISR() API函数](ch09.md#933-xeventgroupsetbitsfromisr-api函数)
    + [9.3.4 xEventGroupWaitBits() API函数](ch09.md#934-xeventgroupwaitbits-api函数)
    + [9.3.5 xEventGroupGetStaticBuffer() API函数](ch09.md#935-xeventgroupgetstaticbuffer-api函数)
  + [9.4 使用事件组进行任务同步](ch09.md#94-使用事件组进行任务同步)
    + [9.4.1 xEventGroupSync() API函数](ch09.md#941-xeventgroupsync-api函数)

## [10 任务通知](ch10.md#10-task-notifications)
  + [10.1 简介](ch10.md#101-introduction)
    + [10.1.1 通过中介对象通信](ch10.md#1011-communicating-through-intermediary-objects)
    + [10.1.2 任务通知—直接任务通信](ch10.md#1012-task-notificationsdirect-to-task-communication)
    + [10.1.3 范围](ch10.md#1013-scope)
  + [10.2 任务通知；优点和局限性](ch10.md#102-task-notifications-benefits-and-limitations)
    + [10.2.1 任务通知的性能优势](ch10.md#1021-performance-benefits-of-task-notifications)
    + [10.2.2 任务通知的RAM占用优势](ch10.md#1022-ram-footprint-benefits-of-task-notifications)
    + [10.2.3 任务通知的局限性](ch10.md#1023-limitations-of-task-notifications)
  + [10.3 使用任务通知](ch10.md#103-using-task-notifications)
    + [10.3.1 任务通知API选项](ch10.md#1031-task-notification-api-options)
      + [10.3.1.1 API函数的完整列表 <sup>27</sup>](ch10.md#10311-the-complete-list-of-api-functions-sup27sup)
    + [10.3.2 xTaskNotifyGive() API函数](ch10.md#1032-the-xtasknotifygive-api-functions)
    + [10.3.3 vTaskNotifyGiveFromISR() API函数](ch10.md#1033-the-vtasknotifygivefromisr-api-function)
    + [10.3.4 ulTaskNotifyTake() API函数](ch10.md#1034-the-ultasknotifytake-api-function)
    + [10.3.5 xTaskNotify() 和 xTaskNotifyFromISR() API函数](ch10.md#1035-the-xtasknotify-and-xtasknotifyfromisr-api-functions)
    + [10.3.6 xTaskNotifyWait() API函数](ch10.md#1036-the-xtasknotifywait-api-function)
    + [10.3.7 在外设驱动程序中使用任务通知：UART示例](ch10.md#1037-task-notifications-used-in-peripheral-device-drivers-uart-example)
    + [10.3.8 在外设驱动程序中使用任务通知：ADC示例](ch10.md#1038-task-notifications-used-in-peripheral-device-drivers-adc-example)
    + [10.3.9 在应用程序中直接使用任务通知](ch10.md#1039-task-notifications-used-directly-within-an-application)

## [11 低功耗支持](ch11.md#11-low-power-support)
  + [11.1 节电介绍](ch11.md#111-power-saving-introduction)
  + [11.2 FreeRTOS 睡眠模式](ch11.md#112-freertos-sleep-modes)
  + [11.3 功能和启用内置无滴答空闲功能](ch11.md#113-functions-and-enabling-built-in-tickless-idle-functionality)
    + [11.3.1 portSUPPRESS_TICKS_AND_SLEEP() 宏](ch11.md#1131-the-portsuppress_ticks_and_sleep-macro)
    + [11.3.2 vPortSuppressTicksAndSleep 函数](ch11.md#1132-the-vportsuppressticksandsleep-function)
    + [11.3.3 eTaskConfirmSleepModeStatus 函数](ch11.md#1133-the-etaskconfirmsleepmodestatus-function)
    + [11.3.4 configPRE_SLEEP_PROCESSING 配置](ch11.md#1134-the-configpre_sleep_processing-configuration)
    + [11.3.5 configPOST_SLEEP_PROCESSING 配置](ch11.md#1135-the-configpost_sleep_processing-configuration)
  + [11.4 实现 portSUPPRESS_TICKS_AND_SLEEP() 宏](ch11.md#114-implementing-portsuppress_ticks_and_sleep-macro)
  + [11.5 空闲任务钩子函数](ch11.md#115-idle-task-hook-function)

## [12 开发者支持](ch12.md#12-developer-support)
  + [12.1 简介](ch12.md#121-introduction)
  + [12.2 configASSERT()](ch12.md#122-configassert)
    + [12.2.1 示例 configASSERT() 定义](ch12.md#1221-example-configassert-definitions)
  + [12.3 适用于 FreeRTOS 的 Tracealyzer](ch12.md#123-tracealyzer-for-freertos)
  + [12.4 调试相关的钩子（回调）函数](ch12.md#124-debug-related-hook-callback-functions)
    + [12.4.1 内存分配失败钩子](ch12.md#1241-malloc-failed-hook)
  + [12.5 查看运行时间和任务状态信息](ch12.md#125-viewing-run-time-and-task-state-information)
    + [12.5.1 任务运行时间统计](ch12.md#1251-task-run-time-statistics)
    + [12.5.2 运行时间统计时钟](ch12.md#1252-the-run-time-statistics-clock)
    + [12.5.3 配置应用程序以收集运行时间统计信息](ch12.md#1253-configuring-an-application-to-collect-run-time-statistics)
    + [12.5.4 uxTaskGetSystemState() API 函数](ch12.md#1254-the-uxtaskgetsystemstate-api-function)
    + [12.5.5 vTaskListTasks() 辅助函数](ch12.md#1255-the-vtasklisttasks-helper-function)
    + [12.5.6 vTaskGetRunTimeStatistics() 辅助函数](ch12.md#1256-the-vtaskgetruntimestatistics-helper-function)
    + [12.5.7 生成和显示运行时间统计信息，一个实例](ch12.md#1257-generating-and-displaying-run-time-statistics-a-worked-example)
  + [12.6 跟踪钩子宏](ch12.md#126-trace-hook-macros)
    + [12.6.1 可用的跟踪钩子宏](ch12.md#1261-available-trace-hook-macros)
    + [12.6.2 定义跟踪钩子宏](ch12.md#1262-defining-trace-hook-macros)
    + [12.6.3 支持 FreeRTOS 的调试器插件](ch12.md#1263-freertos-aware-debugger-plug-ins)

## [13 故障排除](ch13.md#13-troubleshooting)
  + [13.1 章节介绍和范围](ch13.md#131-chapter-introduction-and-scope)
  + [13.2 中断优先级](ch13.md#132-interrupt-priorities)
  + [13.3 栈溢出](ch13.md#133-stack-overflow)
    + [13.3.1 uxTaskGetStackHighWaterMark() API 函数](ch13.md#1331-the-uxtaskgetstackhighwatermark-api-function)
    + [13.3.2 运行时栈检查—概述](ch13.md#1332-run-time-stack-checkingoverview)
    + [13.3.3 运行时栈检查—方法 1](ch13.md#1333-run-time-stack-checkingmethod-1)
    + [13.3.4 运行时栈检查—方法 2](ch13.md#1334-run-time-stack-checkingmethod-2)
    + [13.3.5 运行时栈检查—方法 3](ch13.md#1334-run-time-stack-checkingmethod-3)
  + [13.4 printf() 和 sprintf() 的使用](ch13.md#134-use-of-printf-and-sprintf)
    + [13.4.1 Printf-stdarg.c](ch13.md#1341-printf-stdargc)
  + [13.5 其他常见错误来源](ch13.md#135-other-common-sources-of-error)
    + [13.5.1 症状：向演示中添加一个简单的任务导致演示崩溃](ch13.md#1351-symptom-adding-a-simple-task-to-a-demo-causes-the-demo-to-crash)
    + [13.5.2 症状：在中断中使用 API 函数导致应用程序崩溃](ch13.md#1352-symptom-using-an-api-function-within-an-interrupt-causes-the-application-to-crash)
    + [13.5.3 症状：有时应用程序在中断服务例程中崩溃](ch13.md#1353-symptom-sometimes-the-application-crashes-within-an-interrupt-service-routine)
    + [13.5.4 症状：调度器在尝试启动第一个任务时崩溃](ch13.md#1354-symptom-the-scheduler-crashes-when-attempting-to-start-the-first-task)
    + [13.5.5 症状：中断意外地被禁用，或者临界区没有正确嵌套](ch13.md#1355-symptom-interrupts-are-unexpectedly-left-disabled-or-critical-sections-do-not-nest-correctly)
    + [13.5.6 症状：应用程序在调度器启动之前就崩溃了](ch13.md#1356-symptom-the-application-crashes-even-before-the-scheduler-is-started)
    + [13.5.7 症状：在调度器挂起时或从临界区内部调用 API 函数导致应用程序崩溃](ch13.md#1357-symptom-calling-api-functions-while-the-scheduler-is-suspended-or-from-inside-a-critical-section-causes-the-application-to-crash)
  + [13.6 额外的调试步骤](ch13.md#136-additional-debugging-steps)


## 示例：
+ [示例 4.1 创建任务](ch04.md#example4.1)
+ [示例 4.2 使用任务参数](ch04.md#example4.2)
+ [示例 4.3 试验优先级](ch04.md#example4.3)
+ [示例 4.4 使用*阻塞*状态创建延迟](ch04.md#example4.4)
+ [示例 4.5 将示例任务转换为使用 vTaskDelayUntil()](ch04.md#example4.5)
+ [示例 4.6 结合阻塞和非阻塞任务](ch04.md#example4.6)
+ [示例 4.7 定义空闲任务钩子函数](ch04.md#example4.7)
+ [示例 4.8 删除任务](ch04.md#example4.8)
+ [示例 5.1 从队列接收时阻塞](ch05.md#example5.1)
+ [示例 5.2 向队列发送时阻塞，以及在队列中发送结构体](ch05.md#example5.2)
+ [示例 5.3 使用队列集](ch05.md#example5.3)
+ [示例 6.1 创建一次性定时器和自动重载定时器](ch06.md#example6.1)
+ [示例 6.2 使用回调函数参数和软件定时器 ID](ch06.md#example6.2)
+ [示例 6.3 重置软件定时器](ch06.md#example6.3)
+ [示例 7.1 使用二进制信号量同步任务与中断](ch07.md#example7.1)
+ [示例 7.2 使用计数信号量同步任务与中断](ch07.md#example7.2)
+ [示例 7.3 集中处理延后中断](ch07.md#example7.3)
+ [示例 7.4 在中断中发送和接收队列消息](ch07.md#example7.4)
+ [示例 8.1 重写 vPrintString() 以使用信号量](ch08.md#example8.1)
+ [示例 8.2 打印任务的替代实现](ch08.md#example8.2)
+ [示例 9.1 试验事件组](ch09.md#example9.1)
+ [示例 9.2 同步任务](ch09.md#example9.2)
+ [示例 10.1 使用任务通知代替信号量，方法 1](ch10.md#example10.1)
+ [示例 10.2 使用任务通知代替信号量，方法 2](ch10.md#example10.2)

## 图表：
+ [图2.1 FreeRTOS发行版中的顶级目录](ch02.md#fig2.1)
+ [图2.2 FreeRTOS目录树中的核心FreeRTOS源文件](ch02.md#fig2.2)
+ [图2.3 FreeRTOS目录树中的特定端口源文件](ch02.md#fig2.3)
+ [图2.4 演示目录层次结构](ch02.md#fig2.4)
+ [图3.1 每次创建任务时从heap_1数组分配RAM](ch03.md#fig3.1)
+ [图3.2 任务创建和删除时从heap_2数组分配和释放RAM](ch03.md#fig3.2)
+ [图3.3 从heap_4数组分配和释放RAM](ch03.md#fig3.3)
+ [图3.4 内存映射](ch03.md#fig3.4)
+ [图4.1 顶层任务状态和转换](ch04.md#fig4.1)
+ [图4.2 执行示例4.1时产生的输出](ch04.md#fig4.2)
+ [图4.3 示例4.1中两个任务的实际执行模式](ch04.md#fig4.3)
+ [图4.4 执行序列扩展以显示正在执行的滴答中断](ch04.md#fig4.4)
+ [图4.5 以不同优先级运行两个任务](ch04.md#fig4.5)
+ [图4.6 当一个任务的优先级高于另一个任务时的执行模式...](ch04.md#fig4.6)
+ [图4.7 完整的任务状态机](ch04.md#fig4.7)
+ [图4.8 执行示例4.4时产生的输出](ch04.md#fig4.8)
+ [图4.9 任务使用vTaskDelay()代替空循环时的执行序列](ch04.md#fig4.9)
+ [图4.10 粗线表示任务执行的状态转换...](ch04.md#fig4.10)
+ [图4.11 执行示例4.6时产生的输出](ch04.md#fig4.11)
+ [图4.12 示例4.6的执行模式](ch04.md#fig4.12)
+ [图4.13 执行示例4.7时产生的输出](ch04.md#fig4.13)
+ [图4.14 运行示例4.8时的任务执行序列](ch04.md#fig4.14)
+ [图4.15 执行示例4.8时产生的输出](ch04.md#fig4.15)
+ [图4.16 执行示例4.9时产生的输出](ch04.md#fig4.16)
+ [图4.17 示例4.9的执行序列](ch04.md#fig4.17)
+ [图4.18 强调任务优先级和抢占的执行模式...](ch04.md#fig4.18)
+ [图4.19 强调任务优先级和时间切片的执行模式...](ch04.md#fig4.19)
+ [图4.20 与图4.19所示相同场景的执行模式...](ch04.md#fig4.20)
+ [图4.21 演示具有相同优先级的任务如何...](ch04.md#fig4.21)
+ [图4.22 演示协作调度器行为的执行模式](ch04.md#fig4.22)
+ [图5.1 写入队列和从队列读取的一个示例序列](ch05.md#fig5.1)
+ [图5.2 执行示例5.1时产生的输出](ch05.md#fig5.2)
+ [图5.3 示例5.1产生的执行序列](ch05.md#fig5.3)
+ [图5.4 通过队列发送结构的一个示例场景](ch05.md#fig5.4)
+ [图5.5 由示例5.2产生的输出](ch05.md#fig5.5)
+ [图5.6 由示例5.2产生的执行顺序](ch05.md#fig5.6)
+ [图5.7 当示例5.3执行时产生的输出](ch05.md#fig5.7)
+ [图6.1 单次和自动重载软件定时器的行为差异](ch06.md#fig6.1)
+ [图6.2 自动重载软件定时器的状态和转换](ch06.md#fig6.2)
+ [图6.3 单次软件定时器的状态和转换](ch06.md#fig6.3)
+ [图6.4 软件定时器API函数使用计时器命令队列与RTOS守护任务通信](ch06.md#fig6.4)
+ [图6.5 当调用xTimerStart()的任务优先级高于守护任务优先级时的执行模式](ch06.md#fig6.5)
+ [图6.6 当调用xTimerStart()的任务优先级低于守护任务优先级时的执行模式](ch06.md#fig6.6)
+ [图6.7 当示例6.1执行时产生的输出](ch06.md#fig6.7)
+ [图6.8 当示例6.2执行时产生的输出](ch06.md#fig6.8)
+ [图6.9 启动和重置周期为6个滴答的软件定时器](ch06.md#fig6.9)
+ [图6.10 当示例6.3执行时产生的输出](ch06.md#fig6.10)
+ [图7.1 在高优先级任务中完成中断处理](ch07.md#fig7.1)
+ [图7.2 使用二值信号量实现延迟中断处理](ch07.md#fig7.2)
+ [图7.3 使用二值信号量同步任务与中断](ch07.md#fig7.3)
+ [图7.4 当示例7.1执行时产生的输出](ch07.md#fig7.4)
+ [图7.5 当示例7.1执行时的执行顺序](ch07.md#fig7.5)
+ [图7.6 当一个中断在任务处理第一个事件之前发生的情景](ch07.md#fig7.6)
+ [图7.7 当两个中断在任务处理第一个事件之前发生的情景](ch07.md#fig7.7)
+ [图7.8 使用计数信号量](ch07.md#fig7.8)
+ [图7.9 当示例7.2执行时产生的输出](ch07.md#fig7.9)
+ [图7.10 当示例7.3执行时产生的输出](ch07.md#fig7.10)
+ [图7.11 当示例7.3执行时的执行顺序](ch07.md#fig7.11)
+ [图7.12 当示例7.4执行时产生的输出](ch07.md#fig7.12)
+ [图7.13 由示例7.4产生的执行顺序](ch07.md#fig7.13)
+ [图7.14 影响中断嵌套行为的常量](ch07.md#fig7.14)
+ [图7.15 如何存储二进制101优先级（由实现四个优先级位的Cortex-M微控制器）](ch07.md#fig7.15)
+ [图8.1 使用互斥锁实现互斥](ch08.md#fig8.1)
+ [图8.2 当示例8.1执行时产生的输出](ch08.md#fig8.2)
+ [图8.3 示例8.1可能的执行顺序](ch08.md#fig8.3)
+ [图8.4 最坏情况下的优先级反转情景](ch08.md#fig8.4)
+ [图8.5 优先级继承最小化优先级反转的影响](ch08.md#fig8.5)
+ [图8.6 当具有相同优先级的任务使用相同的互斥锁时可能的执行顺序](ch08.md#fig8.6)
+ [图8.7 如果在同一优先级下创建了示例8.15中所示任务的两个实例，可能会发生的执行顺序](ch08.md#fig8.7)
+ [图8.8 执行示例8.2时产生的输出](ch08.md#fig8.8)
+ [图9.1 事件标志到EventBits_t类型变量中的位数映射](ch09.md#fig9.1)
+ [图9.2 一个事件组，其中仅设置了第1、4和7位，其他所有事件标志都清除](ch09.md#fig9.2)
+ [图9.3 当xWaitForAllBits设置为pdFALSE时执行示例9.1产生的输出](ch09.md#fig9.3)
+ [图9.4 当xWaitForAllBits设置为pdTRUE时执行示例9.1产生的输出](ch09.md#fig9.4)
+ [图9.5 执行示例9.2时产生的输出](ch09.md#fig9.5)
+ [图10.1 使用通信对象从一个任务向另一个任务发送事件](ch10.md#fig10.1)
+ [图10.2 使用任务通知直接从一个任务向另一个任务发送事件](ch10.md#fig10.2)
+ [图10.3 执行示例7.1时产生的输出](ch10.md#fig10.3)
+ [图10.4 执行示例10.1时的执行顺序](ch10.md#fig10.4)
+ [图10.5 执行示例10.2时产生的输出](ch10.md#fig10.5)
+ [图10.6 从应用程序任务到云服务器以及返回的通信路径](ch10.md#fig10.6)
+ [图12.1 FreeRTOS+Trace 包含超过20个相互关联的视图](ch12.md#fig12.1)
+ [图12.2 FreeRTOS+Trace 主跟踪视图 - 超过20个相互关联的跟踪视图之一](ch12.md#fig12.2)
+ [图12.3 FreeRTOS+Trace CPU负载视图 - 超过20个相互关联的跟踪视图之一](ch12.md#fig12.3)
+ [图12.4 FreeRTOS+Trace 响应时间视图 - 超过20个相互关联的跟踪视图之一](ch12.md#fig12.4)
+ [图12.5 FreeRTOS+Trace 用户事件图视图 - 超过20个相互关联的跟踪视图之一](ch12.md#fig12.5)
+ [图12.6 FreeRTOS+Trace 内核对象历史视图 - 超过20个相互关联的跟踪视图之一](ch12.md#fig12.6)
+ [图12.7 由vTaskListTasks()生成的示例输出](ch12.md#fig12.7)
+ [图12.8 由vTaskGetRunTimeStatistics()生成的示例输出](ch12.md#fig12.8)


## 代码清单：
+ [代码清单2.1 新的main()函数模板](ch02.md#list2.1)
+ [代码清单3.1 vPortDefineHeapRegions() API函数原型](ch03.md#list3.1)
+ [代码清单3.2 HeapRegion_t 结构体](ch03.md#list3.2)
+ [代码清单3.3 一组HeapRegion_t结构体，它们共同描述了整个RAM的3个区域](ch03.md#list3.3)
+ [代码清单3.4 一组HeapRegion_t结构体，描述了所有RAM2、所有RAM3，但只有一部分RAM1](ch03.md#list3.4)
+ [代码清单3.5 使用GCC语法声明将被heap_4使用的数组，并将该数组放置在名为.my_heap的内存段中](ch03.md#list3.5)
+ [代码清单3.6 使用IAR语法声明将被heap_4使用的数组，并将该数组放置在绝对地址0x20000000处](ch03.md#list3.6)
+ [代码清单3.7 xPortGetFreeHeapSize() API函数原型](ch03.md#list3.7)
+ [代码清单3.8 xPortGetMinimumEverFreeHeapSize() API函数原型](ch03.md#list3.8)
+ [代码清单3.9 vPortGetHeapStatus() API函数原型](ch03.md#list3.9)
+ [代码清单3.10 HeapStatus_t 结构体](ch03.md#list3.10)
+ [代码清单3.11 收集每个任务的堆使用统计信息](ch03.md#list3.11)
+ [代码清单3.12 malloc失败钩子函数名称和原型](ch03.md#list3.12)
+ [代码清单3.13 将pvPortMallocStack()和vPortFreeStack()宏映射到应用程序定义的内存分配器](ch03.md#list3.13)
+ [代码清单3.14 vApplicationGetTimerTaskMemory 的典型实现](ch03.md#list3.14)
+ [代码清单3.15 vApplicationGetIdleTaskMemory 的典型实现](ch03.md#list3.15)
+ [代码清单4.1 任务函数原型](ch04.md#list4.1)
+ [代码清单4.2 典型任务函数的结构](ch04.md#list4.2)
+ [代码清单4.3 xTaskCreate() API函数原型](ch04.md#list4.3)
+ [代码清单4.4 示例4.1中第一个任务的实现](ch04.md#list4.4)
+ [代码清单4.5 示例4.1中第二个任务的实现](ch04.md#list4.5)
+ [代码清单4.6 启动示例4.1中的任务](ch04.md#list4.6)
+ [代码清单4.7 在调度程序启动后从另一个任务中创建任务](ch04.md#list4.7)
+ [代码清单4.8 示例4.2中用于创建两个任务的单个任务函数](ch04.md#list4.8)
+ [代码清单4.9 示例2的main()函数](ch04.md#list4.9)
+ [代码清单4.10 使用pdMS_TO_TICKS()宏将200毫秒转换为...](ch04.md#list4.10)
+ [代码清单4.11 创建不同优先级的两个任务](ch04.md#list4.11)
+ [代码清单4.12 vTaskDelay() API函数原型](ch04.md#list4.12)
+ [代码清单4.13 示例任务的源代码，将空循环延迟替换为调用...](ch04.md#list4.13)
+ [代码清单4.14 vTaskDelayUntil() API函数原型](ch04.md#list4.14)
+ [代码清单4.15 使用vTaskDelayUntil()的示例任务实现](ch04.md#list4.15)
+ [代码清单4.16 示例4.6中使用的连续处理任务](ch04.md#list4.16)
+ [清单4.17 例4.6中使用的周期性任务](ch04.md#list4.17)
+ [清单4.18 空闲任务钩子函数名称和原型](ch04.md#list4.18)
+ [清单4.19 一个非常简单的空闲钩子函数](ch04.md#list4.19)
+ [清单4.20 示例任务的源代码现在打印出ulIdleCycleCount值](ch04.md#list4.20)
+ [清单4.21 vTaskPrioritySet() API函数原型](ch04.md#list4.21)
+ [清单4.22 uxTaskPriorityGet() API函数原型](ch04.md#list4.22)
+ [清单4.23 例4.8中任务1的实现](ch04.md#list4.23)
+ [清单4.24 例4.8中任务2的实现](ch04.md#list4.24)
+ [清单4.25 例4.8中main()的实现](ch04.md#list4.25)
+ [清单4.26 vTaskDelete() API函数原型](ch04.md#list4.26)
+ [清单4.27 例4.9中main()的实现](ch04.md#list4.27)
+ [清单4.28 例4.9中任务1的实现](ch04.md#list4.28)
+ [清单4.29 例4.9中任务2的实现](ch04.md#list4.29)
+ [清单4.30 线程本地存储指针API函数的函数原型](ch04.md#list4.30)
+ [清单5.1 xQueueCreate() API函数原型](ch05.md#list5.1)
+ [清单5.2 xQueueSendToFront() API函数原型](ch05.md#list5.2)
+ [清单5.3 xQueueSendToBack() API函数原型](ch05.md#list5.3)
+ [清单5.4 xQueueReceive() API函数原型](ch05.md#list5.4)
+ [清单5.5 uxQueueMessagesWaiting() API函数原型](ch05.md#list5.5)
+ [清单5.6 例5.1中发送任务的实现](ch05.md#list5.6)
+ [清单5.7 例5.1中接收任务的实现](ch05.md#list5.7)
+ [清单5.8 例5.1中main()的实现](ch05.md#list5.8)
+ [清单5.9 将在队列中传递的结构定义，以及示例中使用的两个变量的声明](ch05.md#list5.9)
+ [清单5.10 例5.2中发送任务的实现](ch05.md#list5.10)
+ [清单5.11 例5.2中接收任务的定义](ch05.md#list5.11)
+ [清单5.12 例5.2中main()的实现](ch05.md#list5.12)
+ [清单5.13 创建一个保存指针的队列](ch05.md#list5.13)
+ [清单5.14 使用队列发送指向缓冲区的指针](ch05.md#list5.14)
+ [清单5.15 使用队列接收指向缓冲区的指针](ch05.md#list5.15)
+ [清单5.16 在FreeRTOS+TCP中用于向TCP/IP堆栈任务发送事件的结构](ch05.md#list5.16)
+ [清单5.17 伪代码显示如何使用IPStackEvent_t结构将从网络接收到的数据发送到TCP/IP任务](ch05.md#list5.17)
+ [清单5.18 伪代码显示如何使用IPStackEvent_t结构将接受连接的套接字句柄发送到TCP/IP任务](ch05.md#list5.18)
+ [清单5.19 伪代码展示如何使用IPStackEvent_t结构发送网络断开事件到TCP/IP任务](ch05.md#list5.19)
+ [清单5.20 伪代码展示如何接收和处理IPStackEvent_t结构](ch05.md#list5.20)
+ [清单5.21 xQueueCreateSet() API函数原型](ch05.md#list5.21)
+ [清单5.22 xQueueAddToSet() API函数原型](ch05.md#list5.22)
+ [清单5.23 xQueueSelectFromSet() API函数原型](ch05.md#list5.23)
+ [清单5.24 示例5.3中main()函数的实现](ch05.md#list5.24)
+ [清单5.25 示例5.3中使用的发送任务](ch05.md#list5.25)
+ [清单5.26 示例5.3中使用的接收任务](ch05.md#list5.26)
+ [清单5.27 使用包含队列和信号量的队列集](ch05.md#list5.27)
+ [清单5.28 创建用于邮箱的队列](ch05.md#list5.28)
+ [清单5.29 xQueueOverwrite() API函数原型](ch05.md#list5.29)
+ [清单5.30 使用xQueueOverwrite() API函数](ch05.md#list5.30)
+ [清单5.31 xQueuePeek() API函数原型](ch05.md#list5.31)
+ [清单5.32 使用xQueuePeek() API函数](ch05.md#list5.32)
+ [清单6.1 软件定时器回调函数原型](ch06.md#list)
+ [清单6.2 xTimerDelete() API函数原型](ch06.md#list6.2)
+ [清单6.3 xTimerCreate() API函数原型](ch06.md#list6.3)
+ [清单6.4 xTimerStart() API函数原型](ch06.md#list6.4)
+ [清单6.5 创建并启动示例6.1中使用的定时器](ch06.md#list6.5)
+ [清单6.6 示例6.1中单次定时器使用的回调函数](ch06.md#list6.5)
+ [清单6.7 示例6.1中自动重载定时器使用的回调函数](ch06.md#list6.7)
+ [清单6.8 vTimerSetTimerID() API函数原型](ch06.md#list6.8)
+ [清单6.9 pvTimerGetTimerID() API函数原型](ch06.md#list6.9)
+ [清单6.10 创建示例6.2中使用的定时器](ch06.md#list6.10)
+ [清单6.11 示例6.2中使用的定时器回调函数](ch06.md#list6.11)
+ [清单6.12 xTimerChangePeriod() API函数原型](ch06.md#list6.12)
+ [清单6.13 使用xTimerChangePeriod()](ch06.md#list6.13)
+ [清单6.14 xTimerReset() API函数原型](ch06.md#list6.14)
+ [清单6.15 示例6.3中单次定时器使用的回调函数](ch06.md#list6.15)
+ [清单6.16 示例6.3中用于重置软件定时器的任务](ch06.md#list6.16)
+ [清单7.1 portEND_SWITCHING_ISR()宏](ch07.md#list7.1)
+ [清单7.2 portYIELD_FROM_ISR()宏](ch07.md#list7.2)
+ [清单7.3 xSemaphoreCreateBinary() API函数原型](ch07.md#list7.3)
+ [清单7.4 xSemaphoreTake() API函数原型](ch07.md#list7.4)
+ [清单7.5 xSemaphoreGiveFromISR() API函数原型](ch07.md#list)
+ [示例7.6 实现示例7.1中定期生成软件中断的任务](ch07.md#list7.6)
+ [示例7.7 实现中断处理被推迟到的任务（任务...）](ch07.md#list7.7.)
+ [示例7.8 示例7.1中使用的软件中断的ISR](ch07.md#list7.8)
+ [示例7.9 示例7.1中main()的实现](ch07.md#list7.9)
+ [示例7.10 推荐的延迟中断处理任务结构，使用UART接收...](ch07.md#list7.10)
+ [示例7.11 xSemaphoreCreateCounting() API函数原型](ch07.md#list7.11)
+ [示例7.12 用于在示例7.2中创建计数信号量的xSemaphoreCreateCounting()调用](ch07.md#list7.12)
+ [示例7.13 示例7.2中使用的中断服务例程的实现](ch07.md#list7.13)
+ [示例7.14 xTimerPendFunctionCallFromISR() API函数原型](ch07.md#list7.14)
+ [示例7.15 传递给xTimerPendFunctionCallFromISR()的xFunctionToPend参数的函数原型...](ch07.md#list7.15)
+ [示例7.16 示例7.3中使用的软件中断处理程序](ch07.md#list7.16)
+ [示例7.17 示例7.3中执行中断所需处理的函数](ch07.md#list7.17)
+ [示例7.18 示例7.3中main()的实现](ch07.md#list7.18)
+ [示例7.19 xQueueSendToFrontFromISR() API函数原型](ch07.md#list7.19)
+ [示例7.20 xQueueSendToBackFromISR() API函数原型](ch07.md#list7.20)
+ [示例7.21 示例7.4中写入队列的任务实现](ch07.md#list7.21)
+ [示例7.22 示例7.4中使用的中断服务例程的实现](ch07.md#list7.22)
+ [示例7.23 示例7.4中打印从中断服务例程接收到的字符串的任务](ch07.md#list7.23)
+ [示例7.24 示例7.4中的main()函数](ch07.md#list7.24)
+ [示例8.1 一个读、修改、写序列的例子](ch08.md#list8.1)
+ [示例8.2 一个可重入函数的例子](ch08.md#list8.2)
+ [示例8.3 一个不可重入函数的例子](ch08.md#list8.3)
+ [示例8.4 使用临界区保护寄存器访问](ch08.md#list8.4)
+ [示例8.5 vPrintString()的一种可能实现](ch08.md#list8.5)
+ [示例8.6 在中断服务例程中使用临界区](ch08.md#list8.6)
+ [示例8.7 vTaskSuspendAll() API函数原型](ch08.md#list8.7)
+ [示例8.8 xTaskResumeAll() API函数原型](ch08.md#list8.8)
+ [示例8.9 vPrintString()的实现](ch08.md#list8.9)
+ [示例8.10 xSemaphoreCreateMutex() API函数原型](ch08.md#list8.10)
+ [示例8.11 prvNewPrintString()的实现](ch08.md#list8.11)
+ [示例8.12 示例8.1中prvPrintTask()的实现](ch08.md#list8.12)
+ [清单8.13 示例8.1中main()的实现](ch08.md#list8.13)
+ [清单8.14 创建和使用递归互斥锁](ch08.md#list8.14)
+ [清单8.15 在紧密循环中使用互斥锁的任务](ch08.md#list8.15)
+ [清单8.16 确保在循环中使用互斥锁的任务获得更均衡的处理时间...](ch08.md#list8.16)
+ [清单8.17 tick钩子函数的名称和原型](ch08.md#list8.17)
+ [清单8.18 门控任务](ch08.md#list8.18)
+ [清单8.19 示例8.2中的打印任务实现](ch08.md#list8.19)
+ [清单8.20 tick钩子实现](ch08.md#list8.20)
+ [清单8.21 示例8.2中main()的实现](ch08.md#list8.21)
+ [清单9.1 xEventGroupCreate() API函数原型](ch09.md#list9.1)
+ [清单9.2 xEventGroupSetBits() API函数原型](ch09.md#list9.2)
+ [清单9.3 xEventGroupSetBitsFromISR() API函数原型](ch09.md#list9.3)
+ [清单9.4 xEventGroupWaitBits() API函数原型](ch09.md#list9.4)
+ [清单9.5 xEventGroupGetStaticBuffer() API函数原型](ch09.md#list9.5)
+ [清单9.6 示例9.1中使用的事件位定义](ch09.md#list9.6)
+ [清单9.7 示例9.1中设置事件组中两个位的任务](ch09.md#list9.7)
+ [清单9.8 示例9.1中设置事件组中位2的中断服务程序](ch09.md#list9.8)
+ [清单9.9 示例9.1中阻塞等待事件位设置的任务](ch09.md#list9.9)
+ [清单9.10 示例9.1中创建事件组和任务](ch09.md#list9.10)
+ [清单9.11 伪代码：两个任务同步以确保共享TCP套接字...](ch09.md#list9.11)
+ [清单9.12 xEventGroupSync() API函数原型](ch09.md#list9.12)
+ [清单9.13 示例9.2中使用的任务实现](ch09.md#list9.13)
+ [清单9.14 示例9.2中使用的main()函数](ch09.md#list9.14)
+ [清单10.1 xTaskNotifyGive() API函数原型](ch10.md#list10.1)
+ [清单10.2 vTaskNotifyGiveFromISR() API函数原型](ch10.md#list10.2)
+ [清单10.3 ulTaskNotifyTake() API函数原型](ch10.md#list10.3)
+ [清单10.4 中断处理被推迟到的任务的实现（任务...](ch10.md#list10.4)
+ [清单10.5 示例10.1中使用的中断服务程序的实现](ch10.md#list10.5)
+ [清单10.6 中断处理被推迟到的任务的实现（任务...](ch10.md#list10.6)
+ [清单10.7 示例10.2中使用的中断服务程序的实现](ch10.md#list10.7)
+ [清单10.8 xTaskNotify() 和 xTaskNotifyFromISR() API函数的原型](ch10.md#list10.8)
+ [清单10.9 xTaskNotifyWait() API函数原型](ch10.md#list10.9)
+ [清单10.10 伪代码：演示如何在驱动库传输中使用二值信号量...](ch10.md#list10.10)
+ [代码清单10.11 演示如何在驱动库传输中使用任务通知的伪代码...](ch10.md#list10.11)
+ [代码清单10.12 演示如何在驱动库接收中使用任务通知的伪代码...](ch10.md#list10.12)
+ [代码清单10.13 演示如何使用任务通知将值传递给任务的伪代码](ch10.md#list10.13)
+ [代码清单10.14 通过队列发送到服务器任务的结构和数据类型](ch10.md#list10.14)
+ [代码清单10.15 云读取API函数的实现](ch10.md#list10.15)
+ [代码清单10.16 服务器任务处理读取请求](ch10.md#list10.16)
+ [代码清单10.17 云写入API函数的实现](ch10.md#list10.17)
+ [代码清单10.18 服务器任务处理发送请求](ch10.md#list10.18)
+ [代码清单11.1 portSUPPRESS_TICKS_AND_SLEEP宏的原型](ch11.md#list11.1)
+ [代码清单11.2 vPortSuppressTicksAndSleep API函数原型](ch11.md#list11.2)
+ [代码清单11.3 eTaskConfirmSleepModeStatus API函数原型](ch11.md#list11.3)
+ [代码清单11.4 configPRE_SLEEP_PROCESSING宏的原型](ch11.md#list11.4)
+ [代码清单11.5 configPOST_SLEEP_PROCESSING宏的原型](ch11.md#list11.5)
+ [代码清单11.6 用户自定义portSUPPRESS_TICKS_AND_SLEEP()实现示例](ch11.md#list11.6)
+ [代码清单11.7 vApplicationIdleHook API函数原型](ch11.md#list11.7)
+ [代码清单12.1 使用标准C assert()宏检查pxMyPointer是否不为NULL](ch12.md#list12.1)
+ [代码清单12.2 在调试器控制下执行时有用的简单configASSERT()定义](ch12.md#list12.2)
+ [代码清单12.3 记录断言失败的源代码行的configASSERT()定义](ch12.md#list12.3)
+ [代码清单12.4 uxTaskGetSystemState() API函数原型](ch12.md#list12.4)
+ [代码清单12.5 TaskStatus_t结构](ch12.md#list12.5)
+ [代码清单12.6 vTaskListTasks() API函数原型](ch12.md#list12.6)
+ [代码清单12.7 vTaskList() API函数原型](ch12.md#list12.7)
+ [代码清单12.8 vTaskGetRunTimeStatistics() API函数原型](ch12.md#list12.8)
+ [代码清单12.9 vTaskGetRunTimeStats() API函数原型](ch12.md#list12.9)
+ [代码清单12.10 用于计数定时器溢出的16位定时器溢出中断处理程序](ch12.md#list12.10)
+ [代码清单12.11 添加到FreeRTOSConfig.h以启用运行时统计信息收集的宏](ch12.md#list12.11)
+ [代码清单12.12 打印收集的运行时统计信息的任务](ch12.md#list12.12)
+ [代码清单13.1 uxTaskGetStackHighWaterMark() API函数原型](ch13.md#list13.1)
+ [代码清单13.2 uxTaskGetStackHighWaterMark2() API函数原型](ch13.md#list13.2)
+ [代码清单13.3 堆栈溢出钩子函数原型](ch13.md#list13.3)


## 表格：
+ [表1 项目中包含的FreeRTOS源文件](ch02.md#tbl1)
+ [表2 TickType\_t 数据类型和 configTICK\_TYPE\_WIDTH\_IN\_BITS 配置](ch02.md#tbl2)
+ [表3 宏前缀](ch02.md#tbl3)
+ [表4 常见宏定义](ch02.md#tbl4)
+ [表5 用于配置内核调度算法的 FreeRTOSConfig.h 设置](ch04.md#tbl5)
+ [表6 uxBitsToWaitFor 和 xWaitForAllBits 参数的影响](ch09.md#tbl6)

