# 目录

## [1 前言](ch01.md#1-前言)
  + [1.1 小型嵌入式系统中的多任务处理](ch01.md#11-小型嵌入式系统中的多任务处理)
    + [1.1.1 关于FreeRTOS内核](ch01.md#111-关于freertos内核)
    + [1.1.2 价值主张](ch01.md#112-价值主张)
    + [1.1.3 关于术语的说明](ch01.md#113-关于术语的说明)
    + [1.1.4 为什么使用RTOS？](ch01.md#114-为什么使用rtos)
    + [1.1.5 FreeRTOS内核特性](ch01.md#115-freertos内核特性)
    + [1.1.6 许可证，以及FreeRTOS、OpenRTOS和SafeRTOS系列](ch01.md#116-许可证以及freertos-openrtos和safertos系列)
  + [1.2 包含的源文件和项目](ch01.md#12-包含的源文件和项目)
    + [1.2.1 获取本书附带的示例](ch01.md#121-获取本书附带的示例)

## [2 FreeRTOS内核发行版](ch02.md#2-freertos内核发行版)
  + [2.1 简介](ch02.md#21-简介)
  + [2.2 理解FreeRTOS发行版](ch02.md#22-理解freertos发行版)
    + [2.2.1 定义：FreeRTOS移植](ch02.md#221-定义-freertos移植)
    + [2.2.2 构建FreeRTOS](ch02.md#222-构建freertos)
    + [2.2.3 FreeRTOSConfig.h](ch02.md#223-freertosconfigh)
    + [2.2.4 官方发行版](ch02.md#224-官方发行版)
    + [2.2.5 所有移植共用的FreeRTOS源文件](ch02.md#225-所有移植共用的freertos源文件)
    + [2.2.6 特定移植的FreeRTOS源文件](ch02.md#226-特定移植的freertos源文件)
    + [2.2.7 包含路径](ch02.md#227-包含路径)
    + [2.2.8 头文件](ch02.md#228-头文件)
  + [2.3 演示应用程序](ch02.md#23-演示应用程序)
  + [2.4 创建FreeRTOS项目](ch02.md#24-创建freertos项目)
    + [2.4.1 适配一个提供的演示项目](ch02.md#241-适配一个提供的演示项目)
    + [2.4.2 从零开始创建新项目](ch02.md#242-从零开始创建新项目)
  + [2.5 数据类型和编码风格指南](ch02.md#25-数据类型和编码风格指南)
    + [2.5.1 数据类型](ch02.md#251-数据类型)
    + [2.5.2 变量命名](ch02.md#252-变量命名)
    + [2.5.3 函数命名](ch02.md#253-函数命名)
    + [2.5.4 格式化](ch02.md#254-格式化)
    + [2.5.5 宏命名](ch02.md#255-宏命名)
    + [2.5.6 过度类型转换的合理性](ch02.md#256-过度类型转换的合理性)

## [3 堆内存管理](ch03.md#3-堆内存管理)
  + [3.1 简介](ch03.md#31-简介)
    + [3.1.1 先决条件](ch03.md#311-先决条件)
    + [3.1.2 范围](ch03.md#312-范围)
    + [3.1.3 在静态和动态内存分配之间切换](ch03.md#313-在静态和动态内存分配之间切换)
    + [3.1.4 使用动态内存分配](ch03.md#314-使用动态内存分配)
    + [3.1.5 动态内存分配的选项](ch03.md#315-动态内存分配的选项)
  + [3.2 示例内存分配方案](ch03.md#32-示例内存分配方案)
    + [3.2.1 Heap\_1](ch03.md#321-heap_1)
    + [3.2.2 Heap\_2](ch03.md#322-heap_2)
    + [3.2.3 Heap\_3](ch03.md#323-heap_3)
    + [3.2.4 Heap\_4](ch03.md#324-heap_4)
    + [3.2.5 Heap\_5](ch03.md#325-heap_5)
    + [3.2.6 初始化heap\_5：vPortDefineHeapRegions() API函数](ch03.md#326-初始化heap_5-vportdefineheapregions-api函数)
  + [3.3 堆相关的实用函数和宏](ch03.md#33-堆相关的实用函数和宏)
    + [3.3.1 定义堆起始地址](ch03.md#331-定义堆起始地址)
    + [3.3.2 xPortGetFreeHeapSize() API函数](ch03.md#332-xportgetfreeheapsize-api函数)
    + [3.3.3 xPortGetMinimumEverFreeHeapSize() API函数](ch03.md#333-xportgetminimumeverfreeheapsize-api函数)
    + [3.3.4 vPortGetHeapStats() API函数](ch03.md#334-vportgetheapstats-api函数)
    + [3.3.5 收集每个任务的堆使用统计信息](ch03.md#335-收集每个任务的堆使用统计信息)
    + [3.3.6 Malloc失败钩子函数](ch03.md#336-malloc失败钩子函数)
    + [3.3.7 将任务栈放置在快速内存中](ch03.md#337-将任务栈放置在快速内存中)
  + [3.4 使用静态内存分配](ch03.md#34-使用静态内存分配)
    + [3.4.1 启用静态内存分配](ch03.md#341-启用静态内存分配)
    + [3.4.2 静态内部内核内存](ch03.md#342-静态内部内核内存)
      + [3.4.2.1 vApplicationGetTimerTaskMemory](ch03.md#3421-vapplicationgettimertaskmemory)
      + [3.4.2.2 vApplicationGetIdleTaskMemory](ch03.md#3422-vapplicationgetidletaskmemory)

## [4 任务管理](ch04.md#4-任务管理)
  + [4.1 简介](ch04.md#41-简介)
    + [4.1.1 范围](ch04.md#411-范围)
  + [4.2 任务函数](ch04.md#42-任务函数)
  + [4.3 顶层任务状态](ch04.md#43-顶层任务状态)
  + [4.4 任务创建](ch04.md#44-任务创建)
    + [4.4.1 xTaskCreate() API函数](ch04.md#441-xtaskcreate-api函数)
  + [4.5 任务优先级](ch04.md#45-任务优先级)
    + [通用调度器](ch04.md#451-通用调度器)
    + [架构优化调度器](ch04.md#452-架构优化调度器)
  + [4.6 时间测量与滴答中断](ch04.md#46-时间测量与滴答中断)
  + [4.7 扩展*非运行*状态](ch04.md#47-扩展非运行状态)
    + [4.7.1 *阻塞*状态](ch04.md#471-阻塞状态)
    + [4.7.2 *挂起*状态](ch04.md#472-挂起状态)
    + [4.7.3 就绪状态](ch04.md#473-就绪状态)
    + [4.7.4 完善状态转换图](ch04.md#474-完善状态转换图)
    + [4.7.5 vTaskDelayUntil() API函数](ch04.md#475-vtaskdelayuntil-api函数)
  + [4.8 空闲任务与空闲任务钩子](ch04.md#48-空闲任务与空闲任务钩子)
    + [4.8.1 空闲任务钩子函数](ch04.md#481-空闲任务钩子函数)
    + [4.8.2 空闲任务钩子函数的实现限制](ch04.md#482-空闲任务钩子函数的实现限制)
  + [4.9 更改任务优先级](ch04.md#49-更改任务优先级)
    + [4.9.1 vTaskPrioritySet() API函数](ch04.md#491-vtaskpriorityset-api函数)
    + [4.9.2 uxTaskPriorityGet() API函数](ch04.md#492-uxtaskpriorityget-api函数)
  + [4.10 删除任务](ch04.md#410-删除任务)
    + [4.10.1 vTaskDelete() API函数](ch04.md#4101-vtaskdelete-api函数)
  + [4.11 线程本地存储与可重入性](ch04.md#411-线程本地存储与可重入性)
    + [4.11.1 C运行时线程本地存储实现](ch04.md#4111-c运行时线程本地存储实现)
    + [4.11.2 自定义C运行时线程本地存储](ch04.md#4112-自定义c运行时线程本地存储)
    + [4.11.3 应用程序线程本地存储](ch04.md#4113-应用程序线程本地存储)
  + [4.12 调度算法](ch04.md#412-调度算法)
    + [4.12.1 任务状态与事件回顾](ch04.md#4121-任务状态与事件回顾)
    + [4.12.2 选择调度算法](ch04.md#4122-选择调度算法)
    + [4.12.3 带时间片优先抢占式调度](ch04.md#4123-带时间片优先抢占式调度)
    + [4.12.4 不带时间片优先抢占式调度](ch04.md#4124-不带时间片优先抢占式调度)
    + [4.12.5 协作式调度](ch04.md#4125-协作式调度)

## [5 队列管理](ch05.md#5-队列管理)
  + [5.1 简介](ch05.md#51-简介)
    + [5.1.1 范围](ch05.md#511-范围)
  + [5.2 队列的特性](ch05.md#52-队列的特性)
    + [5.2.1 数据存储](ch05.md#521-数据存储)
    + [5.2.2 多任务访问](ch05.md#522-多任务访问)
    + [5.2.3 队列读取阻塞](ch05.md#523-队列读取阻塞)
    + [5.2.4 队列写入阻塞](ch05.md#524-队列写入阻塞)
    + [5.2.5 多队列阻塞](ch05.md#525-多队列阻塞)
    + [5.2.6 创建队列：静态分配和动态分配队列](ch05.md#526-创建队列静态分配和动态分配队列)
  + [5.3 使用队列](ch05.md#53-使用队列)
    + [5.3.1 xQueueCreate() API函数](ch05.md#531-xqueuecreate-api函数)
    + [5.3.2 xQueueSendToBack()和xQueueSendToFront() API函数](ch05.md#532-xqueuesendtoback和xqueuesendtofront-api函数)
    + [5.3.3 xQueueReceive() API函数](ch05.md#533-xqueuereceive-api函数)
    + [5.3.4 uxQueueMessagesWaiting() API函数](ch05.md#534-uxqueuemessageswaiting-api函数)
  + [5.4 从多个源接收数据](ch05.md#54-从多个源接收数据)
  + [5.5 处理大型或可变大小数据](ch05.md#55-处理大型或可变大小数据)
    + [5.5.1 队列指针](ch05.md#551-队列指针)
    + [5.5.2 使用队列发送不同类型和长度的数据[^9]](ch05.md#552-使用队列发送不同类型和长度的数据9)
  + [5.6 从多队列接收数据](ch05.md#56-从多队列接收数据)
    + [5.6.1 队列集](ch05.md#561-队列集)
    + [5.6.2 xQueueCreateSet() API函数](ch05.md#562-xqueuecreateset-api函数)
    + [5.6.3 xQueueAddToSet() API函数](ch05.md#563-xqueueaddtoset-api函数)
    + [5.6.4 xQueueSelectFromSet() API函数](ch05.md#564-xqueueselectfromset-api函数)
    + [5.6.5 更实际的队列集使用场景](ch05.md#565-更实际的队列集使用场景)
  + [5.7 使用队列创建邮箱](ch05.md#57-使用队列创建邮箱)
    + [5.7.1 xQueueOverwrite() API函数](ch05.md#571-xqueueoverwrite-api函数)
    + [5.7.2 xQueuePeek() API函数](ch05.md#572-xqueuepeek-api函数)

## [6 软件定时器管理](ch06.md#6-软件定时器管理)
  + [6.1 章节介绍与范围](ch06.md#61-章节介绍与范围)
    + [6.1.1 范围](ch06.md#611-范围)
  + [6.2 软件定时器回调函数](ch06.md#62-软件定时器回调函数)
  + [6.3 软件定时器的属性与状态](ch06.md#63-软件定时器的属性与状态)
    + [6.3.1 软件定时器的周期](ch06.md#631-软件定时器的周期)
    + [6.3.2 单次定时器和自动重载定时器](ch06.md#632-单次定时器和自动重载定时器)
    + [6.3.3 软件定时器状态](ch06.md#633-软件定时器状态)
  + [6.4 软件定时器的上下文](ch06.md#64-软件定时器的上下文)
    + [6.4.1 RTOS守护进程（定时器服务）任务](ch06.md#641-rtos守护进程定时器服务任务)
    + [6.4.2 定时器命令队列](ch06.md#642-定时器命令队列)
    + [6.4.3 守护进程任务调度](ch06.md#643-守护进程任务调度)
  + [6.5 创建并启动软件定时器](ch06.md#65-创建并启动软件定时器)
    + [6.5.1 xTimerCreate() API函数](ch06.md#651-xtimercreate-api函数)
    + [6.5.2 xTimerStart() API函数](ch06.md#652-xtimerstart-api函数)
  + [6.6 定时器ID](ch06.md#66-定时器id)
    + [6.6.1 vTimerSetTimerID() API函数](ch06.md#661-vtimersettimerid-api函数)
    + [6.6.2 pvTimerGetTimerID() API函数](ch06.md#662-pvtimergettimerid-api函数)
  + [6.7 更改定时器周期](ch06.md#67-更改定时器周期)
    + [6.7.1 xTimerChangePeriod() API函数](ch06.md#671-xtimerchangeperiod-api函数)
  + [6.8 重置软件定时器](ch06.md#68-重置软件定时器)
    + [6.8.1 xTimerReset() API函数](ch06.md#681-xtimerreset-api函数)

## [7 中断管理](ch07.md#7-中断管理)
  + [7.1 简介](ch07.md#71-简介)
    + [7.1.1 事件](ch07.md#711-事件)
    + [7.1.2 范围](ch07.md#712-范围)
  + [7.2 在ISR中使用FreeRTOS API](ch07.md#72-在ISR中使用FreeRTOS API)
    + [7.2.1 中断安全API](ch07.md#721-中断安全API)
    + [7.2.2 使用独立的中断安全API的优势](ch07.md#722-使用独立的中断安全API的优势)
    + [7.2.3 使用独立的中断安全API的缺点](ch07.md#723-使用独立的中断安全API的缺点)
    + [7.2.4 xHigherPriorityTaskWoken参数](ch07.md#724-xhigherprioritytaskwoken参数)
    + [7.2.5 portYIELD\_FROM\_ISR()和portEND\_SWITCHING\_ISR()宏](ch07.md#725-portyield_from_isr和portend_switching_isr宏)
  + [7.3 延迟中断处理](ch07.md#73-延迟中断处理)
  + [7.4 用于同步的二进制信号量](ch07.md#74-用于同步的二进制信号量)
    + [7.4.1 xSemaphoreCreateBinary() API函数](ch07.md#741-xsemaphorecreatebinary-api函数)
    + [7.4.2 xSemaphoreTake() API函数](ch07.md#742-xsemaphoretake-api函数)
    + [7.4.3 xSemaphoreGiveFromISR() API函数](ch07.md#743-xsemaphoregivefromisr-api函数)
    + [7.4.4 改进示例7.1中任务的实现](ch07.md#744-改进示例7.1中任务的实现)
  + [7.5 计数信号量](ch07.md#75-计数信号量)
    + [7.5.1 xSemaphoreCreateCounting() API函数](ch07.md#751-xsemaphorecreatecounting-api函数)
  + [7.6 将工作延迟到RTOS守护进程任务](ch07.md#76-将工作延迟到RTOS守护进程任务)
    + [7.6.1 xTimerPendFunctionCallFromISR() API函数](ch07.md#761-xtimerpendfunctioncallfromisr-api函数)
  + [7.7 在中断服务例程中使用队列](ch07.md#77-在中断服务例程中使用队列)
    + [7.7.1 xQueueSendToFrontFromISR()和xQueueSendToBackFromISR() API函数](ch07.md#771-xqueuesendtofrontfromisr和xqueuesendtobackfromisr-api函数)
    + [7.7.2 在ISR中使用队列的注意事项](ch07.md#772-在ISR中使用队列的注意事项)
  + [7.8 中断嵌套](ch07.md#78-中断嵌套)
    + [7.8.1 给ARM Cortex-M[^22]和ARM GIC用户的说明](ch07.md#781-给ARM Cortex-M22和ARM GIC用户的说明)

## [8 资源管理](ch08.md#8-资源管理)
  + [8.1 本章介绍与范围](ch08.md#81-本章介绍与范围)
    + [8.1.1 互斥](ch08.md#811-互斥)
    + [8.1.2 范围](ch08.md#812-范围)
  + [8.2 临界区与调度器挂起](ch08.md#82-临界区与调度器挂起)
    + [8.2.1 基本临界区](ch08.md#821-基本临界区)
    + [8.2.2 挂起（或锁定）调度器](ch08.md#822-挂起或锁定调度器)
    + [8.2.3 vTaskSuspendAll() API函数](ch08.md#823-the-vtasksuspendall-api函数)
    + [8.2.4 xTaskResumeAll() API函数](ch08.md#824-the-xtaskresumeall-api函数)
  + [8.3 互斥锁（与二进制信号量）](ch08.md#83-互斥锁与二进制信号量)
    + [8.3.1 xSemaphoreCreateMutex() API函数](ch08.md#831-the-xsemaphorecreatemutex-api函数)
    + [8.3.2 优先级反转](ch08.md#832-优先级反转)
    + [8.3.3 优先级继承](ch08.md#833-优先级继承)
    + [8.3.4 死锁（或死锁拥抱）](ch08.md#834-死锁或死锁拥抱)
    + [8.3.5 递归互斥锁](ch08.md#835-递归互斥锁)
    + [8.3.6 互斥锁与任务调度](ch08.md#836-互斥锁与任务调度)
  + [8.4 看门人任务](ch08.md#84-看门人任务)
    + [8.4.1 重写vPrintString()以使用看门人任务](ch08.md#841-重写vprintstring以使用看门人任务)

## [9 事件组](ch09.md#9-事件组)
  + [9.1 本章介绍与范围](ch09.md#91-本章介绍与范围)
    + [9.1.1 范围](ch09.md#911-范围)
  + [9.2 事件组的特性](ch09.md#92-事件组的特性)
    + [9.2.1 事件组、事件标志与事件位](ch09.md#921-事件组、事件标志与事件位)
    + [9.2.2 关于EventBits\_t数据类型的更多信息](ch09.md#922-关于eventbits_t数据类型的更多信息)
    + [9.2.3 多任务访问](ch09.md#923-多任务访问)
    + [9.2.4 使用事件组的实际示例](ch09.md#924-使用事件组的实际示例)
  + [9.3 使用事件组进行事件管理](ch09.md#93-使用事件组进行事件管理)
    + [9.3.1 xEventGroupCreate() API函数](ch09.md#931-the-xeventgroupcreate-api函数)
    + [9.3.2 xEventGroupSetBits() API函数](ch09.md#932-the-xeventgroupsetbits-api函数)
    + [9.3.3 xEventGroupSetBitsFromISR() API函数](ch09.md#933-the-xeventgroupsetbitsfromisr-api函数)
    + [9.3.4 xEventGroupWaitBits() API函数](ch09.md#934-the-xeventgroupwaitbits-api函数)
    + [9.3.5 xEventGroupGetStaticBuffer() API函数](ch09.md#935-the-xeventgroupgetstaticbuffer-api函数)
  + [9.4 使用事件组进行任务同步](ch09.md#94-使用事件组进行任务同步)
    + [9.4.1 xEventGroupSync() API函数](ch09.md#941-the-xeventgroupsync-api函数)

## [10 任务通知](ch10.md#10-任务通知)
  + [10.1 简介](ch10.md#101-简介)
    + [10.1.1 通过中介对象进行通信](ch10.md#1011-通过中介对象进行通信)
    + [10.1.2 任务通知——直接任务通信](ch10.md#1012-任务通知直接任务通信)
    + [10.1.3 范围](ch10.md#1013-范围)
  + [10.2 任务通知的优势与限制](ch10.md#102-任务通知的优势与限制)
    + [10.2.1 任务通知的性能优势](ch10.md#1021-任务通知的性能优势)
    + [10.2.2 任务通知的RAM占用优势](ch10.md#1022-任务通知的ram占用优势)
    + [10.2.3 任务通知的限制](ch10.md#1023-任务通知的限制)
  + [10.3 使用任务通知](ch10.md#103-使用任务通知)
    + [10.3.1 任务通知API选项](ch10.md#1031-任务通知api选项)
      + [10.3.1.1 API函数的完整列表 <sup>27</sup>](ch10.md#10311-api函数的完整列表-sup27sup)
    + [10.3.2 xTaskNotifyGive() API函数](ch10.md#1032-the-xtasknotifygive-api函数)
    + [10.3.3 vTaskNotifyGiveFromISR() API函数](ch10.md#1033-the-vtasknotifygivefromisr-api函数)
    + [10.3.4 ulTaskNotifyTake() API函数](ch10.md#1034-the-ultasknotifytake-api函数)
    + [10.3.5 xTaskNotify() 和 xTaskNotifyFromISR() API函数](ch10.md#1035-the-xtasknotify-and-xtasknotifyfromisr-api函数)
    + [10.3.6 xTaskNotifyWait() API函数](ch10.md#1036-the-xtasknotifywait-api函数)
    + [10.3.7 任务通知在外设驱动中的应用：UART示例](ch10.md#1037-任务通知在外设驱动中的应用uart示例)
    + [10.3.8 任务通知在外设驱动中的应用：ADC示例](ch10.md#1038-任务通知在外设驱动中的应用adc示例)
    + [10.3.9 任务通知在应用程序中的直接使用](ch10.md#1039-任务通知在应用程序中的直接使用)

## [11 低功耗支持](ch11.md#11-低功耗支持)
  + [11.1 省电模式简介](ch11.md#111-省电模式简介)
  + [11.2 FreeRTOS 睡眠模式](ch11.md#112-freertos-睡眠模式)
  + [11.3 函数与启用内置无滴答空闲功能](ch11.md#113-函数与启用内置无滴答空闲功能)
    + [11.3.1 portSUPPRESS\_TICKS\_AND\_SLEEP() 宏](ch11.md#1131-the-portsuppress_ticks_and_sleep-宏)
    + [11.3.2 vPortSuppressTicksAndSleep 函数](ch11.md#1132-the-vportsuppressticksandsleep-函数)
    + [11.3.3 eTaskConfirmSleepModeStatus 函数](ch11.md#1133-the-etaskconfirmsleepmodestatus-函数)
    + [11.3.4 configPRE\_SLEEP\_PROCESSING 配置](ch11.md#1134-the-configpre_sleep_processing-配置)
    + [11.3.5 configPOST\_SLEEP\_PROCESSING 配置](ch11.md#1135-the-configpost_sleep_processing-配置)
  + [11.4 实现 portSUPPRESS\_TICKS\_AND\_SLEEP() 宏](ch11.md#114-实现-portsuppress_ticks_and_sleep-宏)
  + [11.5 空闲任务钩子函数](ch11.md#115-空闲任务钩子函数)

## [12 开发者支持](ch12.md#12-开发者支持)
  + [12.1 简介](ch12.md#121-简介)
  + [12.2 configASSERT()](ch12.md#122-configassert)
    + [12.2.1 configASSERT() 定义示例](ch12.md#1221-configassert-定义示例)
  + [12.3 FreeRTOS 的 Tracealyzer](ch12.md#123-freertos-的-tracealyzer)
  + [12.4 调试相关的钩子（回调）函数](ch12.md#124-调试相关的钩子回调函数)
    + [12.4.1 内存分配失败钩子](ch12.md#1241-内存分配失败钩子)
  + [12.5 查看运行时和任务状态信息](ch12.md#125-查看运行时和任务状态信息)
    + [12.5.1 任务运行时统计](ch12.md#1251-任务运行时统计)
    + [12.5.2 运行时统计时钟](ch12.md#1252-运行时统计时钟)
    + [12.5.3 配置应用程序以收集运行时统计信息](ch12.md#1253-配置应用程序以收集运行时统计信息)
    + [12.5.4 uxTaskGetSystemState() API 函数](ch12.md#1254-the-uxtaskgetsystemstate-api-函数)
    + [12.5.5 vTaskListTasks() 辅助函数](ch12.md#1255-the-vtasklisttasks-辅助函数)
    + [12.5.6 vTaskGetRunTimeStatistics() 辅助函数](ch12.md#1256-the-vtaskgetruntimestatistics-辅助函数)
    + [12.5.7 生成和显示运行时统计信息示例](ch12.md#1257-生成和显示运行时统计信息示例)
  + [12.6 跟踪钩子宏](ch12.md#126-跟踪钩子宏)
    + [12.6.1 可用的跟踪钩子宏](ch12.md#1261-可用的跟踪钩子宏)
    + [12.6.2 定义跟踪钩子宏](ch12.md#1262-定义跟踪钩子宏)
    + [12.6.3 FreeRTOS 感知调试器插件](ch12.md#1263-freertos-感知调试器插件)

## [13 故障排查](ch13.md#13-故障排查)
  + [13.1 本章介绍与范围](ch13.md#131-本章介绍与范围)
  + [13.2 中断优先级](ch13.md#132-中断优先级)
  + [13.3 堆栈溢出](ch13.md#133-堆栈溢出)
    + [13.3.1 uxTaskGetStackHighWaterMark() API 函数](ch13.md#1331-the-uxtaskgetstackhighwatermark-api-函数)
    + [13.3.2 运行时堆栈检查——概述](ch13.md#1332-运行时堆栈检查概述)
    + [13.3.3 运行时堆栈检查——方法1](ch13.md#1333-运行时堆栈检查方法1)
    + [13.3.4 运行时堆栈检查——方法2](ch13.md#1334-运行时堆栈检查方法2)
    + [13.3.4 运行时堆栈检查——方法3](ch13.md#1334-运行时堆栈检查方法3)
  + [13.4 printf() 和 sprintf() 的使用](ch13.md#134-printf-和-sprintf-的使用)
    + [13.4.1 Printf-stdarg.c](ch13.md#1341-printf-stdargc)
  + [13.5 其他常见错误来源](ch13.md#135-其他常见错误来源)
    + [13.5.1 症状：向示例中添加一个简单任务会导致示例崩溃](ch13.md#1351-症状向示例中添加一个简单任务会导致示例崩溃)
    + [13.5.2 症状：在中断中使用 API 函数会导致应用程序崩溃](ch13.md#1352-症状在中断中使用-api-函数会导致应用程序崩溃)
    + [13.5.3 症状：应用程序有时在中断服务例程中崩溃](ch13.md#1353-症状应用程序有时在中断服务例程中崩溃)
    + [13.5.4 症状：调度程序在尝试启动第一个任务时崩溃](ch13.md#1354-症状调度程序在尝试启动第一个任务时崩溃)
    + [13.5.5 症状：中断意外地被禁用，或临界区未正确嵌套](ch13.md#1355-症状中断意外地被禁用或临界区未正确嵌套)
    + [13.5.6 症状：应用程序甚至在调度程序启动之前就崩溃了](ch13.md#1356-症状应用程序甚至在调度程序启动之前就崩溃了)
    + [13.5.7 症状：在调度程序挂起时或从临界区内调用 API 函数会导致应用程序崩溃](ch13.md#1357-症状在调度程序挂起时或从临界区内调用-api-函数会导致应用程序崩溃)
  + [13.6 其他调试步骤](ch13.md#136-其他调试步骤)


## 示例：
+ [示例 4.1 创建任务](ch04.md#example4.1)
+ [示例 4.2 使用任务参数](ch04.md#example4.2)
+ [示例 4.3 实验优先级](ch04.md#example4.3)
+ [示例 4.4 使用 *阻塞* 状态创建延迟](ch04.md#example4.4)
+ [示例 4.5 将示例任务转换为使用 vTaskDelayUntil()](ch04.md#example4.5)
+ [示例 4.6 结合阻塞和非阻塞任务](ch04.md#example4.6)
+ [示例 4.7 定义空闲任务钩子函数](ch04.md#example4.7)
+ [示例 4.8 删除任务](ch04.md#example4.8)
+ [示例 5.1 从队列接收时阻塞](ch05.md#example5.1)
+ [示例 5.2 发送到队列时阻塞，以及在队列上发送结构体](ch05.md#example5.2)
+ [示例 5.3 使用队列集](ch05.md#example5.3)
+ [示例 6.1 创建单次和自动重载定时器](ch06.md#example6.1)
+ [示例 6.2 使用回调函数参数和软件定时器ID](ch06.md#example6.2)
+ [示例 6.3 重置软件定时器](ch06.md#example6.3)
+ [示例 7.1 使用二进制信号量将任务与中断同步](ch07.md#example7.1)
+ [示例 7.2 使用计数信号量将任务与中断同步](ch07.md#example7.2)
+ [示例 7.3 集中式延迟中断处理](ch07.md#example7.3)
+ [示例 7.4 在中断内从队列发送和接收](ch07.md#example7.4)
+ [示例 8.1 重写 vPrintString() 以使用信号量](ch08.md#example8.1)
+ [示例 8.2 打印任务的替代实现](ch08.md#example8.2)
+ [示例 9.1 实验事件组](ch09.md#example9.1)
+ [示例 9.2 同步任务](ch09.md#example9.2)
+ [示例 10.1 使用任务通知替代信号量，方法1](ch10.md#example10.1)
+ [示例 10.2 使用任务通知替代信号量，方法2](ch10.md#example10.2)

## 图表：
+ [图 2.1 FreeRTOS 发行版中的顶级目录](ch02.md#fig2.1)
+ [图 2.2 FreeRTOS 目录树中的核心 FreeRTOS 源文件](ch02.md#fig2.2)
+ [图 2.3 FreeRTOS 目录树中的端口特定源文件](ch02.md#fig2.3)
+ [图 2.4 演示目录层次结构](ch02.md#fig2.4)
+ [图 3.1 每次创建任务时从 heap_1 数组分配 RAM](ch03.md#fig3.1)
+ [图 3.2 在任务创建和删除时从 heap_2 数组分配和释放 RAM](ch03.md#fig3.2)
+ [图 3.3 从 heap_4 数组分配和释放 RAM](ch03.md#fig3.3)
+ [图 3.4 内存映射](ch03.md#fig3.4)
+ [图 4.1 顶级任务状态及其转换](ch04.md#fig4.1)
+ [图 4.2 执行示例 4.1 时产生的输出](ch04.md#fig4.2)
+ [图 4.3 两个示例 4.1 任务的实际执行模式](ch04.md#fig4.3)
+ [图 4.4 扩展的执行序列，显示滴答中断的执行](ch04.md#fig4.4)
+ [图 4.5 以不同优先级运行两个任务](ch04.md#fig4.5)
+ [图 4.6 当一个任务的优先级高于另一个任务时的执行模式](ch04.md#fig4.6)
+ [图 4.7 完整的任务状态机](ch04.md#fig4.7)
+ [图 4.8 执行示例 4.4 时产生的输出](ch04.md#fig4.8)
+ [图 4.9 当任务使用 vTaskDelay() 代替空循环时的执行序列](ch04.md#fig4.9)
+ [图 4.10 粗线表示任务执行的状态转换](ch04.md#fig4.10)
+ [图 4.11 执行示例 4.6 时产生的输出](ch04.md#fig4.11)
+ [图 4.12 示例 4.6 的执行模式](ch04.md#fig4.12)
+ [图 4.13 执行示例 4.7 时产生的输出](ch04.md#fig4.13)
+ [图 4.14 运行示例 4.8 时的任务执行顺序](ch04.md#fig4.14)
+ [极 4.15 执行示例 4.8 时产生的输出](ch04.md#fig4.15)
+ [图 4.16 执行示例 4.9 时产生的输出](ch04.md#fig4.16)
+ [图 4.17 示例 4.9 的执行顺序](ch04.md#fig4.17)
+ [图 4.18 突出显示任务优先级和抢占的执行模式](ch04.md#fig4.18)
+ [图 4.19 突出显示任务优先级和时间片调度的执行模式](ch04.md#fig4.19)
+ [图 4.20 与图 4.19 相同场景的执行模式](ch04.md#fig4.20)
+ [图 4.21 演示相同优先级任务如何共享 CPU 的执行模式](ch极.md#fig4.21)
+ [图 4.22 演示协作调度器行为的执行模式](ch04.md#fig4.22)
+ [图 5.1 队列写入和读取的示例序列](ch05.md#fig5.1)
+ [图 5.2 执行示例 5.1 时产生的输出](ch05.md#fig5.2)
+ [图 5.3 示例 5.1 产生的执行顺序](ch05.md#fig5.3)
+ [图 5.4 在队列上发送结构体的示例场景](ch05.md#fig5.4)
+ [图 5.5 示例 5.2 产生的输出](ch05.md#fig5.5)
+ [图 5.6 示例 5.2 产生的执行顺序](ch05.md#fig5.6)
+ [图 5.7 执行示例 5.3 时产生的输出](ch05.md#fig5.7)
+ [图 6.1 单次和自动重载软件定时器之间的行为差异](ch06.md#fig6.1)
+ [图 6.2 自动重载软件定时器的状态和转换](ch06.md#fig6.2)
+ [图 6.3 单次软件定时器的状态和转换](ch06.md#fig6.3)
+ [图 6.4 软件定时器 API 函数使用定时器命令队列与 RTOS 守护任务通信](ch06.md#fig6.4)
+ [图 6.5 当调用 xTimerStart() 的任务优先级高于守护任务时的执行模式](ch06.md#fig6.5)
+ [图 6.6 当调用 xTimerStart() 的任务优先级低于守护任务时的执行模式](ch06.md#fig6.6)
+ [图 6.7 执行示例 6.1 时产生的输出](ch06.md#fig6.7)
+ [图 6.8 执行示例 6.2 时产生的输出](ch06.md#fig6.8)
+ [图 6.9 启动和重置周期为 6 个滴答的软件定时器](ch06.md#fig6.9)
+ [图 6.10 执行示例 6.3 时产生的输出](ch06.md#fig6.10)
+ [图 7.1 在高优先级任务中完成中断处理](ch07.md#fig7.1)
+ [图 7.2 使用二进制信号量实现延迟中断处理](ch07.md#fig7.2)
+ [图 7.3 使用二进制信号量将任务与中断同步](ch07.md#fig7.3)
+ [图 7.4 执行示例 7.1 时产生的输出](ch07.md#fig7.4)
+ [图 7.5 执行示例 7.1 时的执行顺序](ch07.md#fig7.5)
+ [图 7.6 当任务尚未完成第一个事件处理时发生一次中断的场景](ch07.md#fig7.6)
+ [图 7.7 当任务尚未完成第一个事件处理时发生两次中断的场景](ch07.md#fig7.7)
+ [图 7.8 使用计数信号量](ch07.md#fig7.8)
+ [图 7.9 执行示例 7.2 时产生的输出](ch07.md#fig7.9)
+ [图 7.10 执行示例 7.3 时产生的输出](ch07.md#fig极.10)
+ [图 7.11 执行示例 7.3 时的执行顺序](ch07.md#fig7.11)
+ [图 7.12 执行示例 7.4 时产生的输出](ch07.md#fig7.12)
+ [图 7.13 示例 7.4 产生的执行顺序](ch07.md#fig7.13)
+ [图 7.14 影响中断嵌套行为的常量](ch07.md#fig7.14)
+ [图 7.15 实现四个优先级位的 Cortex-M 微控制器如何存储二进制优先级 101](ch07.md#fig7.15)
+ [图 8.1 使用互斥锁实现互斥](ch08.md#fig8.1)
+ [图 8.2 执行示例 8.1 时产生的输出](ch08.md#fig8.2)
+ [图 8.3 示例 8.1 的一个可能执行顺序](ch08.md#fig8.3)
+ [图 8.4 最坏情况下的优先级反转场景](ch08.md#fig8.4)
+ [图 8.5 优先级继承最小化优先级反转的影响](ch08.md#fig8.5)
+ [图 8.6 当具有相同优先级的任务使用同一个互斥锁时可能出现的执行顺序](ch08.md#fig8.6)
+ [图 8.7 如果以相同优先级创建两个清单 8.15 所示任务的实例时可能出现的执行顺序](ch08.md#fig8.7)
+ [图 8.8 执行示例 8.2 时产生的输出](ch08.md#fig8.8)
+ [图 9.1 EventBits_t 类型变量中的事件标志到位的映射](ch09.md#fig9.1)
+ [图 9.2 一个事件组，其中仅设置了位 1、4 和 7，所有其他事件标志均已清除，使得事件组](ch09.md#fig9.2)
+ [图 9.3 当 xWaitForAllBits 设置为 pdFALSE 时执行示例 9.1 产生的输出](ch09.md#fig9.3)
+ [图 9.4 当 xWaitForAllBits 设置为 pdTRUE 时执行示例 9.1 产生的输出](ch09.md#fig9.4)
+ [图 9.5 执行示例 9.2 时产生的输出](ch09.md#fig9.5)
+ [图 10.1 使用通信对象从一个任务向另一个任务发送事件](ch10.md#fig10.1)
+ [图 10.2 使用任务通知直接从一个任务向另一个任务发送事件](ch10.md#fig10.2)
+ [图 10.3 执行示例 7.1 时产生的输出](ch10.md#fig10.3)
+ [图 10.4 执行示例 10.1 时的执行顺序](ch10.md#fig10.4)
+ [图 10.5 执行示例 10.2 时产生的输出](ch10.md#fig10.5)
+ [图 10.6 从应用程序任务到云服务器再返回的通信路径](ch10.md#fig10.6)
+ [图 12.1 FreeRTOS+Trace 包含 20 多个相互关联的视图](ch12.md#fig12.1)
+ [图 12.2 FreeRTOS+Trace 主跟踪视图 - 20 多个相互关联的跟踪视图之一](ch12.md#fig12.2)
+ [图 12.3 FreeRTOS+Trace CPU 负载视图 - 20 多个相互关联的跟踪视图之一](ch12.md#fig12.3)
+ [图 12.4 FreeRTOS+Trace 响应时间视图 - 20 多个相互关联的跟踪视图之一](ch12.md#fig12.4)
+ [图 12.5 FreeRTOS+Trace 用户事件绘图视图 - 20 多个相互关联的跟踪视图之一](ch12.md#fig12.5)
+ [图 12.6 FreeRTOS+Trace 内核对象历史视图 - 20 多个相互关联的跟踪视图之一](ch12.md#fig12.6)
+ [图 12.7 vTaskListTasks() 生成的示例输出](ch12.md#fig12.7)
+ [图 12.8 vTaskGetRunTimeStatistics() 生成的示例输出](ch12.md#fig12.8)


## 代码清单:
+ [清单 2.1 新 main() 函数的模板](ch02.md#list2.1)
+ [清单 3.1 vPortDefineHeapRegions() API 函数原型](ch03.md#list3.1)
+ [清单 3.2 HeapRegion_t 结构体](ch03.md#list3.2)
+ [清单 3.3 描述整个 RAM 区域的 HeapRegion_t 结构体数组](ch03.md#list3.3)
+ [清单 3.4 描述 RAM2 和 RAM3 全部内容及 RAM1 部分的 HeapRegion_t 结构体数组](ch03.md#list3.4)
+ [清单 3.5 使用 GCC 语法声明将由 heap_4 使用的数组，并将数组放置在名为 .my_heap 的内存段中](ch03.md#list3.5)
+ [清单 3.6 使用 IAR 语法声明将由 heap_4 使用的数组，并将数组放置在绝对地址 0x20000000](ch03.md#list3.6)
+ [清单 3.7 xPortGetFreeHeapSize() API 函数原型](极c03.md#list3.7)
+ [清单 3.8 xPortGetMinimumEverFreeHeapSize() API 函数原型](ch03.md#list3.8)
+ [清单 3.9 vPortGetHeapStatus() API 函数原型](ch03.md#list3.9)
+ [清单 3.10 HeapStatus_t() 结构体](ch03.md#list3.10)
+ [清单 3.11 收集每个任务的堆使用统计信息](ch03.md#list3.11)
+ [清单 3.12 malloc 失败钩子函数名称和原型](ch03.md#list3.12)
+ [清单 3.13 将 pvPortMallocStack() 和 vPortFreeStack() 宏映射到应用程序定义的内存分配器](ch03.md#list3.13)
+ [清单 3.14 vApplicationGetTimerTaskMemory 的典型实现](ch03.md#list3.14)
+ [清单 3.15 vApplicationGetIdleTaskMemory 的典型实现](ch03.md#list3.15)
+ [清单 4.1 任务函数原型](ch04.md#list4.1)
+ [清单 4.2 典型任务函数的结构](ch04.md#list4.2)
+ [清单 4.3 xTaskCreate() API 函数原型](ch04.md#list4.3)
+ [清单 4.4 示例 4.1 中使用的第一个任务的实现](ch04.md#list4.4)
+ [清单 4.5 示例 4.1 中使用的第二个任务的实现](ch04.md#list4.5)
+ [清单 4.6 启动示例 4.1 的任务](ch04.md#list4.6)
+ [清单 4.7 调度器启动后从另一个任务中创建任务](ch04.md#list4.7)
+ [清单 4.8 用于在示例 4.2 中创建两个任务的单一任务函数](ch04.md#list4.8)
+ [清单 4.9 示例 2 的 main() 函数](ch04.md#list4.9)
+ [清单 4.10 使用 pdMS_TO_TICKS() 宏将 200 毫秒转换为...](ch04.md#list4.10)
+ [清单 4.11 创建具有不同优先级的两个任务](ch04.md#list4.11)
+ [清单 4.12 vTaskDelay() API 函数原型](ch04.md#list4.12)
+ [清单 4.13 将空循环延迟替换为调用后的示例任务源代码](ch04.md#list4.13)
+ [清单 4.14 vTaskDelayUntil() API 函数原型](ch04.md#list4.14)
+ [清单 4.15 使用 vTaskDelayUntil() 实现的示例任务](ch04.md#list4.15)
+ [清单 4.16 示例 4.6 中使用的连续处理任务](ch04.md#list4.16)
+ [清单 4.17 示例 4.6 中使用的周期性任务](ch04.md#list4.17)
+ [清单 4.18 空闲任务钩子函数名称和原型](ch04.md#list4.18)
+ [清单 4.19 非常简单的空闲钩子函数](ch04.md#list4.19)
+ [清单 4.20 示例任务现在打印出 ulIdleCycleCount 值的源代码](ch04.md#list4.20)
+ [清单 4.21 vTaskPrioritySet() API 函数原型](ch04.md#list4.21)
+ [清单 4.22 uxTaskPriorityGet() API 函数原型](ch04.md#list4.22)
+ [清单 4.23 示例 4.8 中任务 1 的实现](ch04.md#list4.23)
+ [清单 4.24 示例 4.8 中任务 2 的实现](ch04.md#list4.24)
+ [清单 4.25 示例 4.8 的 main() 实现](ch04.md#list4.25)
+ [清单 4.26 vTaskDelete() API 函数原型](ch04.md#list4.26)
+ [清单 4.27 示例 4.9 的 main() 实现](ch04.md#list4.27)
+ [清单 4.28 示例 4.9 中任务 1 的实现](ch04.md#list4.28)
+ [清单 4.29 示例 4.9 中任务 2 的实现](ch04.md#list4.29)
+ [清单 4.30 线程本地存储指针 API 函数的函数原型](ch04.md#list4.30)
+ [清单 5.1 xQueueCreate() API 函数原型](ch05.md#list5.1)
+ [清单 5.2 xQueueSendToFront() API 函数原型](ch05.md#list5.2)
+ [清单 5.3 xQueueSendToBack() API 函数原型](ch05.md#list5.3)
+ [清单 5.4 xQueueReceive() API 函数原型](ch05.md#list5.4)
+ [清单 5.5 uxQueueMessagesWaiting() API 函数原型](ch05.md#list5.5)
+ [清单 5.6 示例 5.1 中使用的发送任务的实现](ch05.md#list5.6)
+ [清单 5.7 示例 5.1 的接收任务的实现](ch05.md#list5.7)
+ [清单 5.8 示例 5.1 中 main() 的实现](ch05.md#list5.8)
+ [清单 5.9 要在队列上传递的结构体定义，以及示例中使用的两个变量的声明](ch05.md#list5.9)
+ [清单 5.10 示例 5.2 中发送任务的实现](ch05.md#list5.10)
+ [清单 5.11 示例 5.2 中接收任务的定义](ch05.md#list5.11)
+ [清单 5.12 示例 5.2 中 main() 的实现](极05.md#list5.12)
+ [清单 5.13 创建一个用于保存指针的队列](ch05.md#list5.13)
+ [清单 5.14 使用队列发送指向缓冲区的指针](ch05.md#list5.14)
+ [清单 5.15 使用队列接收指向缓冲区的指针](ch05.md#list5.15)
+ [清单 5.16 用于向 FreeRTOS+TCP 中的 TCP/IP 栈任务发送事件的结构体](ch05.md#list5.16)
+ [清单 5.17 伪代码展示如何使用 IPStackEvent_t 结构体将从网络接收到的数据发送到 TCP/IP 任务](ch05.md#list5.17)
+ [清单 5.18 伪代码展示如何使用 IPStackEvent_t 结构体将接受连接的套接字句柄发送到 TCP/IP 任务](ch05.md#list5.18)
+ [清单 5.19 伪代码展示如何使用 IPStackEvent_t 结构体向 TCP/IP 任务发送网络断开事件](ch05.md#list5.19)
+ [清单 5.20 伪代码展示如何接收和处理 IPStackEvent_t 结构体](ch05.md#list5.20)
+ [清单 5.21 xQueueCreateSet() API 函数原型](ch05.md#list5.21)
+ [清单 5.22 xQueueAddToSet() API 函数原型](ch05.md#list5.22)
+ [清单 5.23 xQueueSelectFromSet() API 函数原型](ch05.md#list5.23)
+ [清单 5.24 示例 5.3 中 main() 的实现](ch05.md#极st5.24)
+ [清单 5.25 示例 5.3 中使用的发送任务](ch05.md#list5.25)
+ [清单 5.26 示例 5.3 中使用的接收任务](ch05.md#list5.26)
+ [清单 5.27 使用包含队列和信号量的队列集](ch05.md#list5.27)
+ [清单 5.28 创建一个用作邮箱的队列](ch05.md#list5.28)
+ [清单 5.29 xQueueOverwrite() API 函数原型](ch05.md#list5.29)
+ [清单 5.30 使用 xQueueOverwrite() API 函数](ch05.md#list5.30)
+ [清单 5.31 xQueuePeek() API 函数原型](ch05.md#list5.31)
+ [清单 5.32 使用 xQueuePeek() API 函数](ch05.md#list5.32)
+ [清单 6.1 软件定时器回调函数原型](ch06.md#list)
+ [清单 6.2 xTimerDelete() API 函数原型](ch06.md#list6.2)
+ [清单 6.3 xTimerCreate() API 函数原型](ch06.md#list6.3)
+ [清单 6.4 xTimerStart() API 函数原型](ch06.md#list6.4)
+ [清单 6.5 创建并启动示例 6.1 中使用的定时器](ch06.md#list6.5)
+ [清单 6.6 示例 6.1 中单次定时器使用的回调函数](ch06.md#list6.5)
+ [清单 6.7 示例 6.1 中自动重载定时器使用的回调函数](ch06.md#list6.7)
+ [清单 6.8 vTimerSetTimerID() API 函数原型](ch06.md#list6.8)
+ [清单 6.9 pvTimerGetTimerID() API 函数原型](ch06.md#list6.9)
+ [清单 6.10 创建示例 6.2 中使用的定时器](ch06.md#list6.10)
+ [清单 6.11 示例 6.2 中使用的定时器回调函数](ch06.md#list6.11)
+ [清单 6.12 xTimerChangePeriod() API 函数原型](ch06.md#list6.12)
+ [清单 6.13 使用 xTimerChangePeriod()](ch06.md#list6.13)
+ [清单 6.14 xTimerReset() API 函数原型](ch06.md#list6.14)
+ [清单 6.15 示例 6.3 中单次定时器使用的回调函数](ch06.md#list6.15)
+ [清单 极.16 示例 6.3 中用于重置软件定时器的任务](ch06.md#list6.16)
+ [清单 7.1 portEND_SWITCHING_ISR() 宏](ch07.md#list7.1)
+ [清单 7.2 portYIELD_FROM_ISR() 宏](ch07.md#list7.2)
+ [清单 7.3 xSemaphoreCreateBinary() API 函数原型](ch07.md#list7.3)
+ [清单 7.4 xSemaphoreTake() API 函数原型](ch07.md#list7.4)
+ [清单 7.5 xSemaphoreGiveFromISR() API 函数原型](ch07.md#list)
+ [清单 7.6 示例 7.1 中定期生成软件中断的任务的实现](ch07.md#list7.6)
+ [清单 7.7 中断处理被推迟的任务的实现（任务...](ch07.md#list7.7.)
+ [清单 7.8 示例 7.1 中使用的软件中断服务例程](ch07.md#list7.8)
+ [清单 7.9 示例 7.1 中 main() 的实现](ch07.md#list7.9)
+ [清单 7.10 使用 UART 接收的延迟中断处理任务的推荐结构...](ch07.md#list7.10)
+ [清单 7.11 xSemaphoreCreateCounting() API 函数原型](ch07.md#list7.11)
+ [清单 7.12 示例 7.2 中用于创建计数信号量的 xSemaphoreCreateCounting() 调用](ch07.md#list7.12)
+ [清单 7.13 示例 7.2 中使用的中断服务例程的实现](ch07.md#list7.13)
+ [清单 7.14 xTimerPendFunctionCallFromISR() API 函数原型](ch07.md#list7.14)
+ [清单 7.15 传递给 xTimerPendFunctionCallFromISR() 的 xFunctionToPend 参数的函数原型...](ch07.md#list7.15)
+ [清单 7.16 示例 7.3 中使用的软件中断处理程序](ch07.md#list7.16)
+ [清单 7.17 示例 7.3 中执行中断所需的处理函数](ch07.md#list7.17)
+ [清单 7.18 示例 7.3 中 main() 的实现](ch07.md#list7.18)
+ [清单 7.19 xQueueSendToFrontFromISR() API 函数原型](ch07.md#极st7.19)
+ [清单 7.20 xQueueSendToBackFromISR() API 函数原型](ch07.md#list7.20)
+ [清单 7.21 示例 7.4 中向队列写入数据的任务实现](ch07.md#list7.21)
+ [清单 7.22 示例 7.4 中使用的中断服务例程实现](ch07.md#list7.22)
+ [清单 7.23 示例 7.4 中打印从中断服务例程接收到的字符串的任务](ch07.md#list7.23)
+ [清单 7.24 示例 7.4 中的 main() 函数](ch07.md#list7.24)
+ [清单 8.1 读取、修改、写入序列的示例](ch08.md#list8.1)
+ [清单 8.2 可重入函数的示例](ch08.md#list8.2)
+ [清单 8.3 不可重入函数的示例](ch08.md#list8.3)
+ [清单 8.4 使用临界区保护对寄存器的访问](ch08.md#list8.4)
+ [清单 8.5 vPrintString() 的一种可能实现](ch08.md#list8.5)
+ [清单 8.6 在中断服务例程中使用临界区](ch08.md#list8.6)
+ [清单 8.7 vTaskSuspendAll() API 函数原型](ch08.md#list8.7)
+ [清单 8.8 xTaskResumeAll() API 函数原型](ch08.md#list8.8)
+ [清单 8.9 vPrintString() 的实现](ch08.md#list8.9)
+ [清单 8.10 xSemaphoreCreateMutex() API 函数原型](ch08.md#list8.10)
+ [清单 8.11 prvNewPrintString() 的实现](ch08.md#list8.11)
+ [清单 8.12 示例 8.1 中 prvPrintTask() 的实现](ch08.md#list8.12)
+ [清单 8.13 示例 8.1 中 main() 的实现](ch08.md#list8.13)
+ [清单 8.14 创建并使用递归互斥锁](ch08.md#list8.14)
+ [清单 8.15 在紧密循环中使用互斥锁的任务](ch08.md#list8.15)
+ [清单 8.16 确保在循环中使用互斥锁的任务获得更均衡的处理时间...](ch08.md#list8.16)
+ [清单 8.17 滴答钩子函数的名称和原型](ch08.md#list8.17)
+ [清单 8.18 守门员任务](ch08.md#list8.18)
+ [清单 8.19 示例 8.2 的打印任务实现](ch08.md#list8.19)
+ [清单 8.20 滴答钩子实现](ch08.md#list8.20)
+ [清单 8.21 示例 8.2 中 main() 的实现](ch08.md#list8.21)
+ [清单 9.1 xEventGroupCreate() API 函数原型](ch09.md#list9.1)
+ [清单 9.2 xEventGroupSetBits() API 函数原型](ch09.md#list9.2)
+ [清单 9.3 xEventGroupSetBitsFromISR() API 函数原型](ch09.md#list9.3)
+ [清单 9.4 xEventGroupWaitBits() API 函数原型](ch09.md#list9.4)
+ [清单 9.5 xEventGroupGetStaticBuffer() API 函数原型](ch09.md#list9.5)
+ [清单 9.6 示例 9.1 中使用的事件位定义](ch09.md#list9.6)
+ [清单 9.7 示例 9.1 中设置事件组中两个位的任务](ch09.md#list9.7)
+ [清单 9.8 示例 9.1 中设置事件组中第 2 位的中断服务例程](ch09.md#list9.8)
+ [清单 9.9 示例 9.1 中阻塞等待事件位设置的任务](ch09.md#list9.9)
+ [清单 9.10 示例 9.1 中创建事件组和任务](ch09.md#list9.10)
+ [清单 9.11 两个任务相互同步以确保共享 TCP 套接字的伪代码...](ch09.md#list9.11)
+ [清单 9.12 xEventGroupSync() API 函数原型](ch09.md#list9.12)
+ [清单 9.13 示例 9.2 中使用任务的实现](ch09.md#list9.13)
+ [清单 9.14 示例 9.2 中使用的 main() 函数](ch09.md#list9.14)
+ [清单 10.1 xTaskNotifyGive() API 函数原型](ch10.md#list10.1)
+ [清单 10.2 vTaskNotifyGiveFromISR() API 函数原型](ch10.md#list10.2)
+ [清单 10.3 ulTaskNotifyTake() API 函数原型](ch10.md#list10.3)
+ [清单 10.4 中断处理被推迟的任务的实现（任务...](ch10.md#list10.4)
+ [清单 10.5 示例 10.1 中使用的中断服务例程实现](ch10.md#list10.5)
+ [清单 10.6 中断处理被推迟的任务的实现（任务...](ch10.md#list10.6)
+ [清单 10.7 示例 10.2 中使用的中断服务例程实现](ch10.md#list10.7)
+ [清单 10.8 xTaskNotify() 和 xTaskNotifyFromISR() API 函数的原型](ch10.md#list10.8)
+ [清单 10.9 xTaskNotifyWait() API 函数原型](ch10.md#list10.9)
+ [清单 10.10 演示如何在驱动库传输中使用二进制信号量的伪代码...](ch10.md#list10.10)
+ [清单 10.11 演示如何在驱动库传输中使用任务通知的伪代码...](ch10.md#list10.11)
+ [清单 10.12 演示如何在驱动库接收中使用任务通知的伪代码...](ch10.md#list10.12)
+ [清单 10.13 演示如何使用任务通知将值传递给任务的伪代码](ch10.md#list10.13)
+ [清单 10.14 发送到服务器任务的队列上的结构和数据类型](ch10.md#list10.14)
+ [清单 10.15 云读取API函数的实现](ch10.md#list10.15)
+ [清单 10.16 服务器任务处理读取请求](ch10.md#list10.16)
+ [清单 10.17 云写入API函数的实现](ch10.md#list10.17)
+ [清单 10.18 服务器任务处理发送请求](ch10.md#list10.18)
+ [清单 11.1 portSUPPRESS\_TICKS\_AND\_SLEEP 宏的原型](ch11.md#list11.1)
+ [清单 11.2 vPortSuppressTicksAndSleep API 函数原型](ch11.md#list11.2)
+ [清单 11.3 eTaskConfirmSleepModeStatus API 函数原型](ch11.md#list11.3)
+ [清单 11.4 configPRE\_SLEEP\_PROCESSING 宏的原型](ch11.md#list11.4)
+ [清单 11.5 configPOST\_SLEEP\_PROCESSING 宏的原型](ch11.md#list11.5)
+ [清单 11.6 用户自定义 portSUPPRESS\_TICKS\_AND\_SLEEP() 实现的示例](ch11.md#list11.6)
+ [清单 11.7 vApplicationIdleHook API 函数原型](ch11.md#list11.7)
+ [清单 12.1 使用标准C assert() 宏检查 pxMyPointer 是否为 NULL](ch12.md#list12.1)
+ [清单 12.2 在调试器控制下执行时有用的简单 configASSERT() 定义](ch12.md#list12.2)
+ [清单 12.3 记录断言失败源代码行的 configASSERT() 定义](ch12.md#list12.3)
+ [清单 12.4 uxTaskGetSystemState() API 函数原型](极2.md#list12.4)
+ [清单 12.5 TaskStatus\_t 结构体](ch12.md#list12.5)
+ [清单 12.6 vTaskListTasks() API 函数原型](ch12.md#list12.6)
+ [清单 12.7 vTaskList() API 函数原型](ch12.md#list12.7)
+ [清单 12.8 vTaskGetRunTimeStatistics() API 函数原型](ch12.md#list12.8)
+ [清单 12.9 vTaskGetRunTimeStats() API 函数原型](ch12.md#list12.9)
+ [清单 12.10 用于计数定时器溢出的16位定时器溢出中断处理程序](ch12.md#list12.10)
+ [清单 12.11 添加到 FreeRTOSConfig.h 中以启用运行时统计信息收集的宏](ch12.md#list12.11)
+ [清单 12.12 打印收集的运行时统计信息的任务](ch12.md#list12.12)
+ [清单 13.1 uxTaskGetStackHighWaterMark() API 函数原型](ch13.md#list13.1)
+ [清单 13.2 uxTaskGetStackHighWaterMark2() API 函数原型](ch13.md#list13.2)
+ [清单 13.3 堆栈溢出钩子函数原型](ch13.md#list13.3)


## 表格：
+ [表1 项目中需要包含的FreeRTOS源文件](ch02.md#tbl1)
+ [表2 TickType\_t 数据类型和 configTICK\_TYPE\_WIDTH\_IN\_BITS 配置](ch02.md#tbl2)
+ [表3 宏前缀](ch02.md#tbl3)
+ [表4 常见宏定义](ch02.md#tbl4)
+ [表5 FreeRTOSConfig.h 中用于配置内核调度算法的设置](ch04.md#tbl5)
+ [表6 uxBitsToWaitFor 和 xWaitForAllBits 参数的效果](ch09.md#tbl6)

