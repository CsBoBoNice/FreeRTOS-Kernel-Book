# 2 FreeRTOS内核发行版

## 2.1 简介

为了帮助用户熟悉FreeRTOS内核的文件和目录结构，本章内容如下：

- 提供FreeRTOS目录结构的顶层视图。
- 描述任何特定FreeRTOS项目所需的源文件。
- 介绍演示应用程序。
- 提供如何创建新FreeRTOS项目的信息。

此处的描述仅适用于官方的FreeRTOS发行版。本书附带示例的组织结构略有不同。

## 2.2 理解FreeRTOS发行版

### 2.2.1 定义：FreeRTOS移植

FreeRTOS可以使用大约二十种不同的编译器构建，并且可以在四十多种不同的处理器架构上运行。每个支持的编译器和处理器组合被称为一个FreeRTOS移植。

### 2.2.2 构建FreeRTOS

FreeRTOS是一个库，为原本单线程的裸机应用程序提供多任务功能。

FreeRTOS作为一组C源文件提供。一些源文件是所有移植共用的，而其他源文件则特定于某个移植。将这些源文件作为项目的一部分进行构建，可以使FreeRTOS API对你的应用程序可用。每个官方FreeRTOS移植都提供了一个可用作参考的演示应用程序。该演示应用程序已预先配置为构建正确的源文件并包含正确的头文件。

在创建时，每个演示应用程序“开箱即用”，没有编译器错误或警告。如果后续构建工具的更改导致不再如此，请使用FreeRTOS支持论坛（<https://forums.FreeRTOS.org>）告知我们。第2.3节描述了演示应用程序。


### 2.2.3 FreeRTOSConfig.h

配置文件 `FreeRTOSConfig.h` 中定义的常量用于配置 FreeRTOS 内核。请勿直接在源文件中包含 `FreeRTOSConfig.h`！而应包含 `FreeRTOS.h`，它会在适当的时候自动包含 `FreeRTOSConfig.h`。

`FreeRTOSConfig.h` 用于根据特定应用程序的需求定制 FreeRTOS 内核。例如，`FreeRTOSConfig.h` 包含诸如 `configUSE_PREEMPTION` 这样的常量，用于定义 FreeRTOS 是使用协作式调度还是抢占式调度[^1]。

[^1]: 调度算法的详细说明请参见第 4.13 节。

`FreeRTOSConfig.h` 是为特定应用程序定制 FreeRTOS 的，因此它应位于应用程序的目录中，而不是包含 FreeRTOS 源代码的目录中。

FreeRTOS 的主要发行版为每个 FreeRTOS 移植版本提供了一个演示应用程序，每个演示应用程序都有自己的 `FreeRTOSConfig.h` 文件。建议从你所使用的 FreeRTOS 移植版本的演示应用程序提供的 `FreeRTOSConfig.h` 文件开始，然后根据需要进行调整，而不是从头创建该文件。

FreeRTOS 参考手册和 <https://www.freertos.org/a00110.html> 描述了 `FreeRTOSConfig.h` 中出现的常量。并非所有常量都需要包含在 `FreeRTOSConfig.h` 中——如果省略，许多常量会使用默认值。


### 2.2.4 官方发行版

单个 FreeRTOS 库（包括内核）可以从各自的 GitHub 仓库获取，也可以作为 zip 文件存档下载。对于在生产代码中使用 FreeRTOS 来说，单独获取这些库非常方便。不过，对于初学者来说，下载 FreeRTOS 主发行版是更好的选择，因为它包含了库文件和示例项目。

主发行版包含了所有 FreeRTOS 库的源代码、所有 FreeRTOS 内核移植版本以及所有 FreeRTOS 演示项目的项目文件。不要被文件的数量吓到！实际应用程序只需要其中一小部分。

使用 <https://github.com/FreeRTOS/FreeRTOS/releases/latest> 下载包含最新发行版的 zip 文件。或者，使用以下 Git 命令从 GitHub 克隆主发行版，其中包括从各自 Git 仓库作为子模块引入的单个库：

* * *
```
git clone https://github.com/FreeRTOS/FreeRTOS.git --recurse-submodules

git clone git@github.com:FreeRTOS/FreeRTOS.git --recurse-submodules
```
* * *

图 2.1 展示了 FreeRTOS 发行版的第一级和第二级目录结构：

<a name="fig2.1" title="Figure 2.1 Top level directories within the FreeRTOS distribution"></a>

* * *
```
FreeRTOS
│ │
│ ├─Source  包含 FreeRTOS 内核的源文件
│ │
│ └─Demo    包含预配置的、针对特定移植版本的 FreeRTOS 内核演示项目
│
FreeRTOS-Plus
│
├─Source   包含其他 FreeRTOS 和生态系统库的源代码
│
└─Demo     包含其他 FreeRTOS 和生态系统库的演示项目
```
***图 2.1*** *FreeRTOS 发行版中的顶层目录结构*
* * *

发行版中只包含一份 FreeRTOS 内核源文件；所有演示项目都期望在 FreeRTOS/Source 目录中找到内核源文件，如果目录结构被更改，可能会导致构建失败。


### 2.2.5 所有移植通用的 FreeRTOS 源文件

`tasks.c` 和 `list.c` 实现了 FreeRTOS 内核的核心功能，始终是必需的。它们直接位于 FreeRTOS/Source 目录中，如图2.2所示。该目录还包含以下可选的源文件：

- **queue.c**

  `queue.c` 提供了队列和信号量服务，如本书后续章节所述。`queue.c` 几乎总是必需的。

- **timers.c**

  `timers.c` 提供了软件定时器功能，如本书后续章节所述。只有在应用程序使用软件定时器时才需要编译此文件。

- **event_groups.c**

  `event_groups.c` 提供了事件组功能，如本书后续章节所述。只有在应用程序使用事件组时才需要编译此文件。

- **stream_buffer.c**

  `stream_buffer.c` 提供了流缓冲区和消息缓冲区功能，如本书后续章节所述。只有在应用程序使用流缓冲区或消息缓冲区时才需要编译此文件。

- **croutine.c**

  `croutine.c` 实现了 FreeRTOS 协程功能。只有在应用程序使用协程时才需要编译此文件。协程旨在用于非常小的微控制器，现在很少使用。因此，协程不再维护，不建议在新设计中使用。本书中未描述协程。


<a name="fig2.2" title="图 2.2 FreeRTOS 目录树中的核心 FreeRTOS 源文件"></a>

* * *
```
FreeRTOS
│
└─Source
    │
    ├─tasks.c         FreeRTOS 源文件 - 始终必需
    ├─list.c          FreeRTOS 源文件 - 始终必需
    ├─queue.c         FreeRTOS 源文件 - 几乎总是必需
    ├─timers.c        FreeRTOS 源文件 - 可选
    ├─event_groups.c  FreeRTOS 源文件 - 可选
    ├─stream_buffer.c FreeRTOS 源文件 - 可选
    └─croutine.c      FreeRTOS 源文件 - 可选且不再维护
```
***图 2.2*** *FreeRTOS 目录树中的核心 FreeRTOS 源文件*
* * *

需要注意的是，zip 文件分发中使用的文件名可能会导致命名空间冲突，因为许多项目可能已经使用了相同名称的文件。用户可以按需更改文件名，但分发中的文件名不能更改，因为这样做会破坏与现有用户项目以及 FreeRTOS 感知开发工具的兼容性。


### 2.2.6 FreeRTOS 移植相关的源文件

FreeRTOS/Source/portable 目录包含与 FreeRTOS 移植相关的源文件。portable 目录按层级结构组织，首先按编译器分类，然后按处理器架构分类。图 2.3 展示了这一层级结构。

要在使用编译器 '*compiler*' 的 '*architecture*' 架构处理器上运行 FreeRTOS，除了核心的 FreeRTOS 源文件外，还必须构建位于 FreeRTOS/Source/portable/\[*compiler*\]/\[*architecture*\] 目录中的文件。

如第 3 章“堆内存管理”所述，FreeRTOS 也将堆内存分配视为移植层的一部分。如果 `configSUPPORT_DYNAMIC_ALLOCATION` 设置为 0，则不要在项目中包含堆内存分配方案。

FreeRTOS 在 FreeRTOS/Source/portable/MemMang 目录中提供了示例堆分配方案。如果 FreeRTOS 配置为使用动态内存分配，则需要在项目中包含该目录中的一种堆实现源文件，或提供自己的实现。

> **! 不要在项目中包含多个示例堆分配实现。**

<a name="fig2.3" title="图2.3 FreeRTOS目录树中的特定于端口的源文件"></a>

* * *
```
FreeRTOS
│
└─Source
    │
    └─portable 包含所有移植相关源文件的目录
        │
        ├─MemMang 包含替代堆分配源文件的目录
        │
        ├─[compiler 1] 包含特定于编译器 1 的移植文件的目录
        │   │
        │   ├─[architecture 1] 包含编译器 1 架构 1 移植的文件
        │   ├─[architecture 2] 包含编译器 1 架构 2 移植的文件
        │   └─[architecture 3] 包含编译器 1 架构 3 移植的文件
        │
        └─[compiler 2] 包含特定于编译器 2 的移植文件的目录
            │
            ├─[architecture 1] 包含编译器 2 架构 1 移植的文件
            ├─[architecture 2] 包含编译器 2 架构 2 移植的文件
            └─[etc.]
```
***图 2.3*** *FreeRTOS 目录树中的移植相关源文件*
* * *

### 2.2.7 包含路径

FreeRTOS 要求在编译器的包含路径中包含以下三个目录：

1. FreeRTOS 核心内核头文件路径：`FreeRTOS/Source/include`。
2. 所使用的 FreeRTOS 移植版本特定的源文件路径：`FreeRTOS/Source/portable/[*编译器*]/[*架构*]`。
3. 正确的 `FreeRTOSConfig.h` 头文件路径。

### 2.2.8 头文件

使用 FreeRTOS API 的源文件必须包含 `FreeRTOS.h`，随后是根据 API 函数原型需要包含的头文件，例如 `task.h`、`queue.h`、`semphr.h`、`timers.h`、`event_groups.h`、`stream_buffer.h`、`message_buffer.h` 或 `croutine.h`。不要显式包含其他 FreeRTOS 头文件——`FreeRTOS.h` 会自动包含 `FreeRTOSConfig.h`。

## 2.3 演示应用程序

每个 FreeRTOS 移植版本都至少附带一个演示应用程序，这些程序在创建时可以直接构建，没有编译器错误或警告。如果后续构建工具的更改导致无法直接构建，请使用 FreeRTOS 支持论坛（<https://forums.FreeRTOS.org>）告知我们。

> **跨平台支持**：FreeRTOS 在 Windows、Linux 和 MacOS 系统上开发和测试，并支持多种嵌入式与传统工具链。然而，由于版本差异或遗漏的测试，偶尔可能会出现构建错误。请使用 FreeRTOS 支持论坛（<https://forums.FreeRTOS.org>）向我们报告此类错误。

演示应用程序有以下几个用途：

- 提供一个工作正常且预配置的项目示例，包含正确的文件和编译器选项。
- 允许用户以最少的设置或先验知识进行“开箱即用”的实验。
- 展示如何使用 FreeRTOS API。
- 作为创建实际应用程序的基础。
- 对内核实现进行压力测试。

每个演示项目位于 `FreeRTOS/Demo` 目录下的唯一子目录中。子目录的名称表示该演示项目所对应的移植版本。

FreeRTOS.org 网站为每个演示应用程序提供了一个页面，页面内容包括：

- 如何在 FreeRTOS 目录结构中找到演示项目的项目文件。
- 项目配置使用的硬件或模拟器。
- 如何设置硬件以运行演示。
- 如何构建演示。
- 演示的预期行为。

所有演示项目都创建了“通用演示任务”的子集，其实现位于 `FreeRTOS/Demo/Common/Minimal` 目录中。这些通用演示任务旨在展示如何使用 FreeRTOS API 并测试 FreeRTOS 内核移植——它们并不实现任何特定的实用功能。

许多演示项目还可以配置为创建一个简单的“闪烁灯”式启动项目，通常创建两个 RTOS 任务和一个队列。

每个演示项目都包含一个名为 `main.c` 的文件，其中包含 `main()` 函数，该函数在启动 FreeRTOS 内核之前创建演示应用程序任务。有关特定演示的详细信息，请参阅各个 `main.c` 文件中的注释。

<a name="fig2.4" title="图 2.4 演示目录结构"></a>

* * *
```
FreeRTOS
    │
    └─Demo          包含所有演示项目的目录
        │
        ├─[Demo x]  包含构建演示 'x' 的项目文件
        ├─[Demo y]  包含构建演示 'y' 的项目文件
        ├─[Demo z]  包含构建演示 'z' 的项目文件
        └─Common    包含所有演示应用程序构建的通用文件
```
***图 2.4*** *演示目录结构*
* * *


## 2.4 创建 FreeRTOS 项目

### 2.4.1 基于现有演示项目进行适配

每个 FreeRTOS 移植版本都附带至少一个预配置的演示应用程序。建议通过适配现有的演示项目来创建新项目，以确保新项目中包含正确的文件、正确的中断处理程序以及正确的编译器选项。

要从现有演示项目创建新应用程序，请按以下步骤操作：

1. 打开提供的演示项目，并确保其能够按预期构建和运行。

2. 删除实现演示任务的源文件，这些文件位于 `Demo/Common` 目录中。

3. 删除 `main()` 函数中的所有函数调用，仅保留 `prvSetupHardware()` 和 `vTaskStartScheduler()`，如代码清单 2.1 所示。

4. 验证项目是否仍然能够构建。

按照这些步骤操作后，你将创建一个包含正确 FreeRTOS 源文件但未定义任何功能的项目。


<a name="list2.1" title="代码清单 2.1 新 main() 函数的模板"></a>


```c
int main( void )
{
    /* 执行必要的硬件设置。 */
    prvSetupHardware();

    /* --- 可以在此处创建应用程序任务 --- */

    /* 启动已创建的任务。 */
    vTaskStartScheduler();

    /* 只有在堆空间不足无法启动调度程序时，才会执行到这里。 */
    for( ;; );
    return 0;
}
```
***代码清单 2.1*** *新 main() 函数的模板*



### 2.4.2 从零开始创建新项目

如前所述，建议基于现有的演示项目创建新项目。如果不希望这样做，则按照以下步骤创建新项目：

1. 使用您选择的工具链创建一个尚未包含任何 FreeRTOS 源文件的新项目。

2. 确保新项目能够成功构建、下载到目标硬件并执行。

3. 只有在确认已有可运行的项目后，将表 1 中列出的 FreeRTOS 源文件添加到项目中。

4. 将演示项目中使用的 `FreeRTOSConfig.h` 头文件（该文件已为所使用的移植提供）复制到新项目目录中。

5. 将以下目录添加到项目的头文件搜索路径中：
   - FreeRTOS/Source/include
   - FreeRTOS/Source/portable/\[*编译器*\]/\[*架构*\]（其中 \[*编译器*\] 和 \[*架构*\] 与您选择的移植匹配）
   - 包含 `FreeRTOSConfig.h` 头文件的目录

6. 从相关的演示项目中复制编译器的设置。

7. 安装任何可能需要的 FreeRTOS 中断处理程序。请参考描述所使用的移植的网页以及为该移植提供的演示项目。

<a name="tbl1" title="表 1 项目中需要包含的 FreeRTOS 源文件"></a>

* * *
| 文件                            | 位置                          |
|---------------------------------|-------------------------------|
| tasks.c                         | FreeRTOS/Source               |
| queue.c                         | FreeRTOS/Source               |
| list.c                          | FreeRTOS/Source               |
| timers.c                        | FreeRTOS/Source               |
| event\_groups.c                 | FreeRTOS/Source               |
| stream\_buffer.c                | FreeRTOS/Source               |
| 所有 C 和汇编文件                | FreeRTOS/Source/portable/\[编译器\]/\[架构\] |
| heap\_n.c                       | FreeRTOS/Source/portable/MemMang，其中 n 为 1、2、3、4 或 5 |

***表 1*** *项目中需要包含的 FreeRTOS 源文件*
* * *

**关于堆内存的说明：**
 如果 `configSUPPORT_DYNAMIC_ALLOCATION` 为 0，则不要在项目中包含堆内存分配方案。否则，请在项目中包含一个堆内存分配方案，可以是 heap\_*n*.c 文件之一，也可以是您自己提供的方案。更多信息请参阅第 3 章《堆内存管理》。


## 2.5 数据类型与编码风格指南

### 2.5.1 数据类型

每个FreeRTOS移植版本都有一个独特的`portmacro.h`头文件，其中包含（除其他内容外）两个特定移植数据类型的定义：`TickType_t`和`BaseType_t`。以下列表描述了所使用的宏或typedef以及实际类型：

- `TickType_t`

  FreeRTOS配置了一个称为tick中断的周期性中断。

  自FreeRTOS应用程序启动以来发生的tick中断次数称为*tick计数*。tick计数用作时间的度量。

  两次tick中断之间的时间称为*tick周期*。时间被指定为tick周期的倍数。

  `TickType_t`是用于保存tick计数值和指定时间的数据类型。

  `TickType_t`可以是无符号16位类型、无符号32位类型或无符号64位类型，具体取决于FreeRTOSConfig.h中`configTICK_TYPE_WIDTH_IN_BITS`的设置。`configTICK_TYPE_WIDTH_IN_BITS`的设置与架构相关。FreeRTOS移植版本还会检查此设置是否有效。

  在8位和16位架构上使用16位类型可以大大提高效率，但会严重限制可以在FreeRTOS API调用中指定的最大阻塞时间。在32位或64位架构上没有理由使用16位`TickType_t`类型。

  以前使用的`configUSE_16_BIT_TICKS`已被`configTICK_TYPE_WIDTH_IN_BITS`取代，以支持超过32位的tick计数。新设计应使用`configTICK_TYPE_WIDTH_IN_BITS`而不是`configUSE_16_BIT_TICKS`。

   <a name="tbl2" title="表2 TickType_t数据类型与configTICK_TYPE_WIDTH_IN_BITS配置"></a>

   * * *
   | configTICK\_TYPE\_WIDTH\_IN\_BITS | 8位架构 | 16位架构 | 32位架构 | 64位架构 |
   | --- | --- | --- | --- | --- |
   | TICK\_TYPE\_WIDTH\_16_BITS | uint16\_t	| uint16\_t	| uint16\_t	| N/A |
   | TICK\_TYPE\_WIDTH\_32_BITS | uint32\_t	| uint32\_t	| uint32\_t	| N/A |
   | TICK\_TYPE\_WIDTH\_64_BITS | N/A | N/A | uint64\_t | uint64\_t |

   ***表2*** *TickType_t数据类型与configTICK_TYPE_WIDTH_IN_BITS配置*
   * * *

- `BaseType_t`

  这始终定义为架构的最高效数据类型。通常，在64位架构上是64位类型，在32位架构上是32位类型，在16位架构上是16位类型，在8位架构上是8位类型。

  `BaseType_t`通常用于返回值类型，这些返回值仅取非常有限的范围，以及用于`pdTRUE`/`pdFALSE`类型的布尔值。


*FreeRTOS使用的移植特定数据类型列表*


### 2.5.2 变量命名

变量以其类型为前缀：'c' 表示 `char`，'s' 表示 `int16_t`（short），'l' 表示 `int32_t`（long），'x' 表示 `BaseType_t` 以及其他非标准类型（结构体、任务句柄、队列句柄等）。

如果变量是无符号的，则还会加上 'u' 前缀。如果变量是指针，则还会加上 'p' 前缀。例如，`uint8_t` 类型的变量会以 'uc' 为前缀，而指向 `char` 的指针类型（`char *`）变量会以 'pc' 为前缀。

### 2.5.3 函数命名

函数以其返回值类型和定义所在的文件为前缀。例如：

- v**Task**PrioritySet() 返回 *v*oid 类型，并定义在 **tasks**.c 文件中。
- x**Queue**Receive() 返回 *BaseType_t* 类型的变量，并定义在 **queue**.c 文件中。
- pv**Timer**GetTimerID() 返回指向 *v*oid 的指针，并定义在 **timers**.c 文件中。

文件作用域（私有）函数以 'prv' 为前缀。

### 2.5.4 格式化

在某些演示应用程序中使用了制表符，其中每个制表符始终设置为等于四个空格。内核不再使用制表符。


### 2.5.5 宏命名

大多数宏以大写字母书写，并以前缀小写字母表示宏定义的位置。表3提供了前缀的列表。

<a name="tbl3" title="表3 宏前缀"></a>

* * *
| 前缀                                       | 宏定义位置                    |
|----------------------------------------------|--------------------------------|
| port（例如，`portMAX_DELAY`)                | `portable.h` 或 `portmacro.h` |
| task（例如，`taskENTER_CRITICAL()`)         | `task.h`                      |
| pd（例如，`pdTRUE`)                         | `projdefs.h`                  |
| config（例如，`configUSE_PREEMPTION`)       | `FreeRTOSConfig.h`            |
| err（例如，`errQUEUE_FULL`)                 | `projdefs.h`                  |

***表3*** *宏前缀*
* * *

需要注意的是，信号量API几乎完全以一组宏的形式编写，但遵循函数命名约定，而不是宏命名约定。

表4中定义的宏在FreeRTOS源码中广泛使用。

<a name="tbl4" title="表4 常用宏定义"></a>

* * *
| 宏        | 值 |
|--------------|-------|
| `pdTRUE`     | 1     |
| `pdFALSE`    | 0     |
| `pdPASS`     | 1     |
| `pdFAIL`     | 0     |

***表4*** *常用宏定义*
* * *


### 2.5.6 过度类型转换的原因

FreeRTOS 源代码需要与许多不同的编译器兼容，而这些编译器在生成警告的方式和时机上存在差异。特别是，不同的编译器对类型转换的使用方式有不同的要求。因此，FreeRTOS 源代码中包含了比通常情况下更多的类型转换。

