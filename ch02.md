# 2 FreeRTOS 内核分发

## 2.1 引言

为了帮助用户了解FreeRTOS内核文件和目录，本章节：

- 提供FreeRTOS目录结构的高层次视图。
- 描述任何特定FreeRTOS项目所需的源文件。
- 引入演示应用程序。
- 提供如何创建新FreeRTOS项目的信息。

这里的描述仅适用于官方FreeRTOS分发。本书附带的示例使用稍微不同的组织方式。

## 2.2 理解FreeRTOS分发

### 2.2.1 定义：FreeRTOS端口

FreeRTOS可以使用大约二十种不同的编译器构建，并且可以在四十多种不同的处理器架构上运行。每个受支持的编译器和处理器组合称为一个FreeRTOS端口。

### 2.2.2 构建FreeRTOS

FreeRTOS是一个库，为原本是单线程、裸机应用程序提供多任务能力。

FreeRTOS以一组C源文件的形式提供。一些源文件对所有端口都是通用的，而其他一些则是特定于某个端口的。将源文件作为项目的一部分构建，使FreeRTOS API可用于您的应用程序。为每个官方FreeRTOS端口提供了一个可以用作参考的演示应用程序。演示应用程序预配置为构建正确的源文件并包含正确的头文件。

在创建时，每个演示应用程序都能“开箱即用”，没有编译器错误或警告。请使用FreeRTOS支持论坛（<https://forums.FreeRTOS.org>）告知我们，如果随后对构建工具的更改意味着情况不再如此。第2.3节描述了演示应用程序。


### 2.2.3 FreeRTOSConfig.h

在名为 FreeRTOSConfig.h 的头文件中定义的常量用于配置内核。不要在源文件中直接包含 FreeRTOSConfig.h！相反，包含 FreeRTOS.h，它将在适当的时候包含 FreeRTOSConfig.h。

FreeRTOSConfig.h 用于为特定应用程序定制 FreeRTOS 内核。例如，FreeRTOSConfig.h 包含 `configUSE_PREEMPTION` 等常量，定义 FreeRTOS 是使用协作式还是抢占式调度[^1]。

[^1]: 第 4.13 节描述了调度算法。

FreeRTOSConfig.h 为特定应用程序定制 FreeRTOS，因此应将其放置在应用程序的一部分目录中，而不是包含 FreeRTOS 源代码的目录中。

主 FreeRTOS 发行版包含每个 FreeRTOS 端口的演示应用程序，每个演示应用程序都有自己的 FreeRTOSConfig.h 文件。建议从演示应用程序使用的 FreeRTOSConfig.h 开始，然后进行适应，而不是从头创建文件。

FreeRTOS 参考手册和 <https://www.freertos.org/a00110.html> 描述了出现在 FreeRTOSConfig.h 中的常量。不需要在 FreeRTOSConfig.h 中包含所有常量——如果省略，许多常量将获得默认值。


### 2.2.4 官方发行版

单个FreeRTOS库，包括内核，可以从其各自的Github仓库和作为zip文件档案获取。获取单个库的能力在使用FreeRTOS进行生产代码时非常方便。然而，最好下载主FreeRTOS发行版以开始，因为它包含库和示例项目。

主发行版包含所有FreeRTOS库的源代码、所有FreeRTOS内核端口以及所有FreeRTOS演示应用程序的项目文件。不要被文件数量吓倒！应用程序只需要一个小子集。

使用 <https://github.com/FreeRTOS/FreeRTOS/releases/latest> 下载包含最新发行版的zip文件。或者，使用以下Git命令从GitHub克隆主发行版，包括从各自的Git仓库子模块化的单个库：

* * *
```
git clone https://github.com/FreeRTOS/FreeRTOS.git --recurse-submodules

git clone git@github.com:FreeRTOS/FreeRTOS.git --recurse-submodules
```
* * *

图2.1显示了FreeRTOS发行版的第一级和第二级目录：

<a name="fig2.1" title="图2.1 FreeRTOS发行版中的顶级目录"></a>

* * *
```
FreeRTOS
│ │
│ ├─Source  包含FreeRTOS内核源文件
│ │
│ └─Demo    包含预配置和特定于端口的FreeRTOS内核演示项目
│
FreeRTOS-Plus
│
├─Source    包含其他FreeRTOS和生态系统库的源代码
│
└─Demo      包含其他FreeRTOS和生态系统库的演示项目
```
***图2.1*** *FreeRTOS发行版中的顶级目录*
* * *

发行版只包含一份FreeRTOS内核源文件；所有演示项目都期望在FreeRTOS/Source目录中找到内核源文件，并且如果目录结构发生变化，可能无法构建。


### 2.2.5 所有端口通用的FreeRTOS源文件

tasks.c和list.c实现了核心FreeRTOS内核功能，并且总是需要的。它们位于FreeRTOS/Source目录中，如图2.2所示。同一目录还包含以下可选的源文件：

-  **queue.c**

   queue.c提供队列和信号量服务，如本书后面所述。queue.c几乎总是需要的。

-  **timers.c**

   timers.c提供软件定时器功能，如本书后面所述。只有在应用程序使用软件定时器时才需要构建它。

-  **event_groups.c**

   event_groups.c提供事件组功能，如本书后面所述。只有在应用程序使用事件组时才需要构建它。

-  **stream_buffer.c**

   stream_buffer.c提供流缓冲区和消息缓冲区功能，如本书后面所述。只有在应用程序使用流或消息缓冲区时才需要构建它。

-  **croutine.c**

   croutine.c实现了FreeRTOS协程功能。只有在应用程序使用协程时才需要构建它。协程旨在用于非常小的微控制器，现在很少使用。因此，它们不再维护，不建议用于新设计。本书不描述协程。

<a name="fig2.2" title="图2.2 FreeRTOS目录树中的核心FreeRTOS源文件"></a>

* * *
```
FreeRTOS
│
└─Source
    │
    ├─tasks.c         FreeRTOS源文件 - 总是需要
    ├─list.c          FreeRTOS源文件 - 总是需要
    ├─queue.c         FreeRTOS源文件 - 几乎总是需要
    ├─timers.c        FreeRTOS源文件 - 可选
    ├─event_groups.c  FreeRTOS源文件 - 可选
    ├─stream_buffer.c FreeRTOS源文件 - 可选
    └─croutine.c      FreeRTOS源文件 - 可选且不再维护
```
***图2.2*** *FreeRTOS目录树中的核心FreeRTOS源文件*
* * *

已认识到zip文件分发中使用的文件名可能会导致命名空间冲突，因为许多项目已经使用了相同名称的文件。用户可以根据需要更改文件名，但分发中的名称不能更改，因为这样会破坏与现有用户项目以及FreeRTOS感知开发工具的兼容性。


### 2.2.6 特定于端口的FreeRTOS源文件

FreeRTOS/Source/portable目录包含特定于FreeRTOS端口的源文件。portable目录按编译器和处理器架构分层排列。图2.3显示了层次结构。

要在使用编译器'*compiler*'的'*architecture*'架构的处理器上运行FreeRTOS，除了核心FreeRTOS源文件，还必须构建位于FreeRTOS/Source/portable/\[*compiler*\]/\[*architecture*\]目录中的文件。

如第3章堆内存管理所述，FreeRTOS还认为堆内存分配是可移植层的一部分。如果`configSUPPORT_DYNAMIC_ALLOCATION`设置为0，则不包括堆内存分配方案在项目中。

FreeRTOS在FreeRTOS/Source/portable/MemMang目录中提供了示例堆分配方案。如果FreeRTOS配置为使用动态内存分配，则必须在项目中包含该目录中的一个堆实现源文件，或者提供自己的实现。

> **! 不要在项目中包含多个示例堆分配实现。**

<a name="fig2.3" title="图2.3 FreeRTOS目录树中的特定于端口的源文件"></a>

* * *
```
FreeRTOS
│
└─Source
    │
    └─portable 目录包含所有特定于端口的源文件
        │
        ├─MemMang 目录包含替代堆分配源文件
        │
        ├─[compiler 1] 目录包含特定于编译器1的端口文件
        │   │
        │   ├─[architecture 1] 包含编译器1架构1端口的文件
        │   ├─[architecture 2] 包含编译器1架构2端口的文件
        │   └─[architecture 3] 包含编译器1架构3端口的文件
        │
        └─[compiler 2] 目录包含特定于编译器2的端口文件
            │
            ├─[architecture 1] 包含编译器2架构1端口的文件
            ├─[architecture 2] 包含编译器2架构2端口的文件
            └─[etc.]
```
***图2.3*** *FreeRTOS目录树中的特定于端口的源文件*
* * *

### 2.2.7 包含路径

FreeRTOS 需要在编译器的包含路径中包含三个目录。这些目录是：

1. 核心 FreeRTOS 内核头文件的路径，FreeRTOS/Source/include。

2. 特定于使用的 FreeRTOS 端口的源文件的路径，FreeRTOS/Source/portable/\[*compiler*\]/\[*architecture*\]。

3. 正确的 FreeRTOSConfig.h 头文件的路径。

### 2.2.8 头文件

使用 FreeRTOS API 的源文件必须包含 FreeRTOS.h，然后是包含 API 函数原型的头文件——task.h、queue.h、semphr.h、timers.h、event_groups.h、stream_buffer.h、message_buffer.h 或 croutine.h。不要显式包含任何其他 FreeRTOS 头文件——FreeRTOS.h 会自动包含 FreeRTOSConfig.h。


## 2.3 演示应用程序

每个FreeRTOS端口都附带至少一个演示应用程序，在其创建时，可以“开箱即用”，没有编译错误或警告。请使用FreeRTOS支持论坛（<https://forums.FreeRTOS.org>）告知我们，如果随后对构建工具的更改意味着情况不再如此。

> **跨平台支持**：FreeRTOS在Windows、Linux和MacOS系统上开发和测试，并与各种工具链，无论是嵌入式还是传统的。然而，偶尔会出现构建错误，原因是版本差异或遗漏的测试。请使用FreeRTOS支持论坛（<https://forums.FreeRTOS.org>）通知我们任何此类错误。

演示应用程序有几个目的：

- 提供一个工作和预配置的项目示例，包含正确的文件，并设置了正确的编译器选项。
- 允许“开箱即用”的实验，几乎不需要设置或先前的知识。
- 演示如何使用FreeRTOS API。
- 作为创建真实应用程序的基础。
- 对内核的实现进行压力测试。

每个演示项目位于FreeRTOS/Demo目录下的唯一子目录中。子目录的名称指示演示项目与其相关的端口。

FreeRTOS.org网站包含每个演示应用程序的页面。网页包括以下信息：

- 如何在FreeRTOS目录结构中找到演示的项目文件。
- 项目配置为使用的硬件或仿真器。
- 如何设置硬件以运行演示。
- 如何构建演示。
- 演示的预期行为。

所有演示项目都创建了一组“常见演示任务”的子集，其实现位于FreeRTOS/Demo/Common/Minimal目录中。常见演示任务存在于演示如何使用FreeRTOS API和测试FreeRTOS内核端口——它们不实现任何特定的有用功能。

许多演示项目还可以配置为创建一个简单的“闪烁”样式启动项目，通常创建两个RTOS任务和一个队列。

每个演示项目都包括一个名为main.c的文件，其中包含`main()`函数，该函数在启动FreeRTOS内核之前创建演示应用程序任务。有关特定于该演示的信息，请参阅各个main.c文件中的注释。

<a name="fig2.4" title="图2.4 演示目录层次结构"></a>

* * *
```
FreeRTOS
    │
    └─Demo          包含所有演示项目的目录
        │
        ├─[Demo x]  包含构建演示 'x' 的项目文件
        ├─[Demo y]  包含构建演示 'y' 的项目文件
        ├─[Demo z]  包含构建演示 'z' 的项目文件
        └─Common    包含所有演示应用程序构建的文件
```
***图2.4*** *演示目录层次结构*
* * *


## 2.4 创建一个FreeRTOS项目

### 2.4.1 适配一个已提供的演示项目

每个FreeRTOS端口都至少包含一个预配置的演示应用程序。建议通过适配这些现有项目来创建新项目，以确保新项目包含正确的文件、正确的中断处理程序和正确的编译器选项。

要从现有的演示项目创建新应用程序：

1. 打开提供的演示项目，并确保其构建和执行如预期。

2. 删除实现演示任务的源文件，这些文件位于Demo/Common目录中。

3. 删除`main()`中的所有函数调用，除了`prvSetupHardware()`和`vTaskStartScheduler()`，如清单2.1所示。

4. 验证项目是否仍能构建。

按照这些步骤操作，您将创建一个包含正确的FreeRTOS源文件但不定义任何功能的项目。

<a name="list2.1" title="清单2.1 新main()函数的模板"></a>

```c
int main( void )
{
    /* 执行任何必要的硬件设置。 */
    prvSetupHardware();

    /* --- 应用程序任务可以在此创建 --- */

    /* 启动创建的任务运行。 */
    vTaskStartScheduler();

    /* 只有在堆内存不足以启动调度器时，执行才会到达这里。 */
    for( ;; );
    return 0;
}
```
***清单2.1*** *新main()函数的模板*



### 2.4.2 从头创建新项目

如前所述，建议从现有的演示项目创建新项目。如果不希望这样做，则可以按照以下步骤创建新项目：

1. 使用您选择的工具链创建一个尚未包含任何FreeRTOS源文件的新项目。

1. 确保新项目能够构建、下载到目标硬件并执行。

1. 只有在确定已经有一个工作项目后，才将表1中详细说明的FreeRTOS源文件添加到项目中。

1. 将演示项目使用的`FreeRTOSConfig.h`头文件和为所使用的端口提供的文件复制到新项目目录中。

1. 将以下目录添加到项目将搜索以定位头文件的路径中：

   - FreeRTOS/Source/include
   - FreeRTOS/Source/portable/\[*compiler*\]/\[*architecture*\]（其中\[*compiler*\]和\[*architecture*\]适用于您选择的端口）
   - 包含`FreeRTOSConfig.h`头文件的目录

1. 从相关的演示项目复制编译器设置。

1. 安装可能必要的FreeRTOS中断处理程序。使用描述所使用端口的网页和为所使用端口提供的演示项目作为参考。

<a name="tbl1" title="表1 要包含在项目中的FreeRTOS源文件"></a>

* * *
| 文件                            | 位置                     |
|---------------------------------|------------------------------|
| tasks.c                         | FreeRTOS/Source              |
| queue.c                         | FreeRTOS/Source              |
| list.c                          | FreeRTOS/Source              |
| timers.c                        | FreeRTOS/Source              |
| event\_groups.c                 | FreeRTOS/Source              |
| stream\_buffer.c                | FreeRTOS/Source              |
| 所有C和汇编文件       | FreeRTOS/Source/portable/\[compiler\]/\[architecture\] |
| heap\_n.c                       | FreeRTOS/Source/portable/MemMang, 其中n是1、2、3、4或5 |

***表1*** *要包含在项目中的FreeRTOS源文件*
* * *

**关于堆内存的说明：**
如果`configSUPPORT_DYNAMIC_ALLOCATION`为0，则不在项目中包含堆内存分配方案。否则，在项目中包含堆内存分配方案，可以是heap\_*n*.c文件之一，或者是您自己提供的文件。有关更多信息，请参阅第3章，堆内存管理。


## 2.5 数据类型和编码风格指南

### 2.5.1 数据类型

每个FreeRTOS端口都有一个独特的portmacro.h头文件，其中包含（除了其他内容之外）两个端口特定数据类型的定义：`TickType_t`和`BaseType_t`。以下列表描述了所使用的宏或typedef以及实际类型：

- `TickType_t`

  FreeRTOS配置了一个称为时钟中断的周期性中断。

  自FreeRTOS应用程序启动以来发生的时钟中断数称为*时钟计数*。时钟计数用作时间度量。

  两个时钟中断之间的时间称为*时钟周期*。时间以时钟周期的倍数指定。

  `TickType_t`是用于保存时钟计数值和指定时间的数据类型。

  `TickType_t`可以是无符号16位类型、无符号32位类型或无符号64位类型，具体取决于FreeRTOSConfig.h中`configTICK_TYPE_WIDTH_IN_BITS`的设置。`configTICK_TYPE_WIDTH_IN_BITS`的设置是架构相关的。FreeRTOS端口还将检查此设置是否有效。

  使用16位类型可以在8位和16位架构上显著提高效率，但严重限制了可以在FreeRTOS API调用中指定的最大阻塞时间。在32位或64位架构上没有理由使用16位`TickType_t`类型。

  以前对`configUSE_16_BIT_TICKS`的使用已被`configTICK_TYPE_WIDTH_IN_BITS`替换，以支持大于32位的时钟计数。新设计应使用`configTICK_TYPE_WIDTH_IN_BITS`而不是`configUSE_16_BIT_TICKS`。

   <a name="tbl2" title="表2 TickType_t数据类型和configTICK_TYPE_WIDTH_IN_BITS配置"></a>

   * * *
   | configTICK\_TYPE\_WIDTH\_IN\_BITS | 8位架构 | 16位架构 | 32位架构 | 64位架构 |
   | --- | --- | --- | --- | --- |
   | TICK\_TYPE\_WIDTH\_16_BITS | uint16\_t	| uint16\_t	| uint16\_t	| N/A |
   | TICK\_TYPE\_WIDTH\_32_BITS | uint32\_t	| uint32\_t	| uint32\_t	| N/A |
   | TICK\_TYPE\_WIDTH\_64_BITS | N/A | N/A | uint64\_t | uint64\_t |

   ***表2*** *TickType_t数据类型和configTICK_TYPE_WIDTH_IN_BITS配置*
   * * *

- `BaseType_t`

  这总是定义为架构最有效的数据类型。通常，这是64位架构上的64位类型，32位架构上的32位类型，16位架构上的16位类型，8位架构上的8位类型。

  `BaseType_t`通常用于仅接受非常有限范围值的返回类型，以及`pdTRUE`/`pdFALSE`类型的布尔值。

*FreeRTOS使用的端口特定数据类型列表*


### 2.5.2 变量名称

变量前缀为其类型：'c' 表示 `char`，'s' 表示 `int16_t`（短整型），'l' 表示 `int32_t`（长整型），'x' 表示 `BaseType_t` 和任何其他非标准类型（结构、任务句柄、队列句柄等）。

如果变量是无符号的，前缀还会加上 'u'。如果变量是指针，前缀还会加上 'p'。例如，类型为 `uint8_t` 的变量前缀为 'uc'，类型为指向 char 的指针（`char *`）的变量前缀为 'pc'。

### 2.5.3 函数名称

函数前缀为其返回类型和定义所在的文件。例如：

- v**Task**PrioritySet() 返回 *v*oid 类型，定义在 **tasks**.c 中。
- x**Queue**Receive() 返回类型为 *BaseType_t* 的变量，定义在 **queue**.c 中。
- pv**Timer**GetTimerID() 返回指向 *v*oid 的 *p*ointer，定义在 **timers**.c 中。

文件作用域（私有）函数前缀为 'prv'。

### 2.5.4 格式

在某些演示应用程序中使用制表符，其中一个制表符始终等于四个空格。内核不再使用制表符。


### 2.5.5 宏名称

大多数宏以大写字母书写，并以小写字母作为前缀，以指示宏的定义位置。表3提供了前缀列表。

<a name="tbl3" title="表3 宏前缀"></a>

* * *
| 前缀                                       | 宏定义位置   |
|----------------------------------------------|--------------------------------|
| port (例如，`portMAX_DELAY`)          | `portable.h` 或 `portmacro.h`  |
| task (例如，`taskENTER_CRITICAL()`)   | `task.h`                       |
| pd (例如，`pdTRUE`)                   | `projdefs.h`                   |
| config (例如，`configUSE_PREEMPTION`) | `FreeRTOSConfig.h`             |
| err (例如，`errQUEUE_FULL`)           | `projdefs.h`                   |

***表3*** *宏前缀*
* * *

请注意，信号量API几乎完全以一组宏的形式编写，但遵循函数命名约定，而不是宏命名约定。

表4中定义的宏在整个FreeRTOS源代码中使用。

<a name="tbl4" title="表4 常见宏定义"></a>

* * *
| 宏        | 值 |
|--------------|-------|
| `pdTRUE`     | 1     |
| `pdFALSE`    | 0     |
| `pdPASS`     | 1     |
| `pdFAIL`     | 0     |

***表4*** *常见宏定义*
* * *


### 2.5.6 过多类型转换的原因

FreeRTOS源代码可以使用许多不同的编译器进行编译，这些编译器在生成警告的方式和时间上有很大不同。特别是，不同的编译器希望以不同的方式使用类型转换。因此，FreeRTOS源代码包含了比通常情况下更多的类型转换。

