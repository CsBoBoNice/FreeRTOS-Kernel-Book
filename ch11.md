# 11 低功耗支持

## 11.1 功耗节省介绍

FreeRTOS 提供了一种通过 IDLE 任务钩子和无时钟空闲模式轻松进入低功耗模式的方法。

通常，通过使用 IDLE 任务钩子将微控制器置于低功耗状态，可以减少 FreeRTOS 运行的微控制器的功耗。通过这种方法可以实现的功耗节省受限于需要定期退出并重新进入低功耗状态以处理时钟中断的必要性。此外，如果时钟中断的频率过高（从空闲状态唤醒过于频繁），那么进入和退出低功耗状态的每个时钟周期所消耗的能量和时间将超过了除最轻的功耗节省模式之外的任何潜在功耗节省收益。

FreeRTOS 支持一种低功耗状态，允许微控制器定期进入和退出低功耗消耗。FreeRTOS 的无时钟空闲模式在空闲期间（当没有可执行的应用程序任务时）停止周期性时钟中断，这使得 MCU 可以保持在深度功耗节省状态，直到发生中断，或者是 RTOS 内核将任务转换为就绪状态的时间。然后，当重新启动时钟中断时，它对 RTOS 时钟计数值进行校正调整。FreeRTOS 无时钟模式的原理是使 MCU 在执行空闲任务时进入低功耗模式，以节省系统功耗。


## 11.2 FreeRTOS 睡眠模式

FreeRTOS 支持三种睡眠模式：

1. eAbortSleep - 此模式表示任务已准备就绪，上下文切换已挂起或时钟中断已发生但由于调度程序已暂停而挂起。它信号RTOS中止进入睡眠模式。

2. eStandardSleep - 此模式允许进入一种睡眠模式，其持续时间不会超过预期的空闲时间。

3. eNoTasksWaitingTimeout - 当没有任务等待超时时进入此模式，因此可以安全地进入一种只能由外部中断或重置退出的睡眠模式。

## 11.3 函数和启用内置的无时钟空闲功能

通过在 FreeRTOSConfig.h 中将 `configUSE_TICKLESS_IDLE` 定义为 1（适用于支持此功能的端口），启用内置的无时钟空闲功能。可以通过在 FreeRTOSConfig.h 中将 `configUSE_TICKLESS_IDLE` 定义为 2，为任何 FreeRTOS 端口（包括包含内置实现的端口）提供用户定义的无时钟空闲功能。

启用无时钟空闲功能时，当满足以下两个条件时，内核将调用 `portSUPPRESS_TICKS_AND_SLEEP()` 宏：

1. 空闲任务是唯一能够运行的任务，因为所有应用程序任务要么处于阻塞状态，要么处于暂停状态。

2. 在内核将应用程序任务从阻塞状态转换出来之前，至少会经过 n 个完整的时钟周期，其中 n 由 FreeRTOSConfig.h 中的 `configEXPECTED_IDLE_TIME_BEFORE_SLEEP` 定义设置。


### 11.3.1 portSUPPRESS_TICKS_AND_SLEEP() 宏

<a name="list11.1" title="Listing 11.1 The prototype for the portSUPPRESS_TICKS_AND_SLEEP macro"></a>

```c
portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
```
***Listing 11.1*** *The prototype for the portSUPPRESS_TICKS_AND_SLEEP macro*

`portSUPPRESS_TICKS_AND_SLEEP()` 中的 `xExpectedIdleTime` 参数的值等于任务在进入就绪状态之前的总计时周期数。因此，参数值是微控制器可以安全地保持在深度睡眠状态的时间，同时抑制计时中断。

### 11.3.2 vPortSuppressTicksAndSleep 函数

`vPortSuppressTicksAndSleep()` 函数在 FreeRTOS 中定义，可以用来实现无计时模式。该函数在 FreeRTOS Cortex-M 端口层中被弱定义，可以被应用程序编写者覆盖。

<a name="list11.2" title="Listing 11.2 The vPortSuppressTicksAndSleep API function prototype"></a>

```c
void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
```
***Listing 11.2*** *The vPortSuppressTicksAndSleep API function prototype*


### 11.3.3 eTaskConfirmSleepModeStatus 函数

API *eTaskConfirmSleepModeStatus* 返回睡眠模式状态，以确定是否可以继续进入睡眠状态以及是否可以无限期睡眠。此功能仅在 `configUSE_TICKLESS_IDLE` 设置为 1 时可用。

<a name="list11.3" title="Listing 11.3 The eTaskConfirmSleepModeStatus API function prototype"></a>

```c
eSleepModeStatus eTaskConfirmSleepModeStatus( void );
```
***Listing 11.3*** *The eTaskConfirmSleepModeStatus API function prototype*

如果在 `portSUPPRESS_TICKS_AND_SLEEP()` 内部调用 `eTaskConfirmSleepModeStatus()` 时返回 `eNoTasksWaitingTimeout`，则微控制器可以无限期保持在深度睡眠状态。`eTaskConfirmSleepModeStatus()` 仅在以下条件为真时返回 `eNoTasksWaitingTimeout`：

+ 软件定时器未被使用，因此调度程序不需要在未来的任何时间执行定时器回调函数。

+ 所有应用程序任务要么处于挂起状态，要么处于阻塞状态，超时值为 `portMAX_DELAY`，因此调度程序不需要在未来的任何固定时间将任务从阻塞状态转换出来。

为了避免竞争条件，在调用 `portSUPPRESS_TICKS_AND_SLEEP()` 之前暂停 FreeRTOS 调度程序，并在 `portSUPPRESS_TICKS_AND_SLEEP()` 完成时恢复。这确保了在微控制器退出低功耗状态和 `portSUPPRESS_TICKS_AND_SLEEP()` 完成执行之间，应用程序任务不能执行。此外，`portSUPPRESS_TICKS_AND_SLEEP()` 函数必须在定时器停止和进入睡眠模式之间创建一个小的临界区，以确保可以继续进入睡眠模式。`eTaskConfirmSleepModeStatus()` 应该从这个临界区调用。

此外，FreeRTOS 为用户提供了两个其他接口函数，这些函数在 FreeRTOSConfig.h 中定义。这些宏允许应用程序编写者在 MCU 被放置到低功耗状态之前和之后分别添加额外的步骤。


### 11.3.4 configPRE\_SLEEP\_PROCESSING 配置

<a name="list11.4" title="Listing 11.4 The prototype for the configPRE\_SLEEP\_PROCESSING macro"></a>

```c
configPRE_SLEEP_PROCESSING( xExpectedIdleTime )
```
***Listing 11.4*** *The prototype for the configPRE\_SLEEP\_PROCESSING macro*

在用户使MCU进入低功耗模式之前，必须调用 `configPRE_SLEEP_PROCESSING()` 来配置系统参数以减少系统功耗，例如关闭其他外围设备时钟、降低系统频率。

### 11.3.5 configPOST\_SLEEP\_PROCESSING 配置

<a name="list11.5" title="Listing 11.5 The prototype for the configPOST\_SLEEP\_PROCESSING macro"></a>

```c
configPOST_SLEEP_PROCESSING( xExpectedIdleTime )
```
***Listing 11.5*** *The prototype for the configPOST\_SLEEP\_PROCESSING macro*

退出低功耗模式后，用户应该调用 `configPOST_SLEEP_PROCESSING()` 函数来恢复系统的主频率和外围功能。


## 11.4 实现 portSUPPRESS_TICKS_AND_SLEEP() 宏

如果使用的 FreeRTOS 端口没有提供 `portSUPPRESS_TICKS_AND_SLEEP()` 的默认实现，
则应用程序开发者可以通过在 FreeRTOSConfig.h 中定义 `portSUPPRESS_TICKS_AND_SLEEP()` 来提供自己的实现。
如果使用的 FreeRTOS 端口提供了 `portSUPPRESS_TICKS_AND_SLEEP()` 的默认实现，
则应用程序开发者可以通过在 FreeRTOSConfig.h 中定义 `portSUPPRESS_TICKS_AND_SLEEP()` 来覆盖默认实现。

以下是应用程序开发者可能实现 `portSUPPRESS_TICKS_AND_SLEEP()` 的源代码示例。
该示例非常基本，将在内核维护的时间和日历时间之间引入一些滑动。
在示例中显示的函数调用中，只有 `vTaskStepTick()` 和 `eTaskConfirmSleepModeStatus()` 是 FreeRTOS API 的一部分。
其他函数是特定于使用的硬件上的时钟和省电模式，因此必须由应用程序开发者提供。

<a name="list11.6" title="Listing 11.6 An example of a user defined implementation of portSUPPRESS\_TICKS\_AND\_SLEEP()"></a>

```c
/* 首先定义portSUPPRESS_TICKS_AND_SLEEP()宏。参数是内核下次需要执行的时间，以滴答为单位。 */

#define portSUPPRESS_TICKS_AND_SLEEP( xIdleTime ) vApplicationSleep( xIdleTime )

/* 定义由portSUPPRESS_TICKS_AND_SLEEP()调用的函数。 */
void vApplicationSleep( TickType_t xExpectedIdleTime )
{
    unsigned long ulLowPowerTimeBeforeSleep, ulLowPowerTimeAfterSleep;

    eSleepModeStatus eSleepStatus;

    /* 从一个在微控制器处于低功耗状态时仍然可操作的时间源读取当前时间。 */
    ulLowPowerTimeBeforeSleep = ulGetExternalTime();

    /* 停止生成滴答中断的定时器。 */
    prvStopTickInterruptTimer();

    /* 进入一个不会影响将MCU从睡眠模式中唤醒的中断的临界区。 */
    disable_interrupts();

    /* 确保仍然可以进入睡眠模式。 */
    eSleepStatus = eTaskConfirmSleepModeStatus();

    if( eSleepStatus == eAbortSleep )
    {
        /* 自从执行此宏以来，某个任务已被移出阻塞状态，或者正在等待上下文切换。不进入睡眠状态。重新启动滴答并退出临界区。 */
        prvStartTickInterruptTimer();
        enable_interrupts();
    }
    else
    {
        if( eSleepStatus == eNoTasksWaitingTimeout )
        {
            /* 不需要配置一个中断来在未来的固定时间将微控制器从低功耗状态中唤醒。 */
            prvSleep();
        }
        else
        {
            /* 配置一个中断来在内核下次需要执行的时间将微控制器从低功耗状态中唤醒。中断必须由一个在微控制器处于低功耗状态时仍然可操作的源生成。 */
            vSetWakeTimeInterrupt( xExpectedIdleTime );

            /* 进入低功耗状态。 */
            prvSleep();

            /* 确定微控制器实际处于低功耗状态的时间，如果微控制器是由vSetWakeTimeInterrupt()调用配置的中断以外的中断唤醒的，则会小于xExpectedIdleTime。请注意，在调用portSUPPRESS_TICKS_AND_SLEEP()之前暂停调度程序，并在portSUPPRESS_TICKS_AND_SLEEP()返回时恢复调度程序。因此，在此函数完成之前不会执行其他任务。 */
            ulLowPowerTimeAfterSleep = ulGetExternalTime();

            /* 修正内核的滴答计数，以考虑微控制器在低功耗状态下花费的时间。 */
            vTaskStepTick( ulLowPowerTimeAfterSleep - ulLowPowerTimeBeforeSleep );
        }
    }
```
```c

        /* 退出临界区 - 可能可以在prvSleep()调用之后立即执行 */
        enable_interrupts();

        /* 重新启动生成滴答中断的定时器。 */
        prvStartTickInterruptTimer();
    }
}
```
***清单 11.6*** *用户定义的portSUPPRESS_TICKS_AND_SLEEP()实现示例*



## 11.5 空闲任务钩子函数

空闲任务可以选择调用一个应用程序定义的钩子（或回调）函数 - 空闲钩子。
空闲任务以最低优先级运行，因此这样的空闲钩子函数只会在没有更高优先级的任务可以运行时执行。
这使得空闲钩子函数成为将处理器置于低功耗状态的理想位置 - 在没有处理任务时自动节省电源。
只有在FreeRTOSConfig.h中将`configUSE_IDLE_HOOK`设置为1时，空闲钩子才会被调用。

<a name="list11.7" title="清单 11.7 vApplicationIdleHook API函数原型"></a>

```c
void vApplicationIdleHook( void );
```
***清单 11.7*** *vApplicationIdleHook API函数原型*


空闲钩子在空闲任务运行期间会被反复调用。空闲钩子函数绝对不能调用可能导致其阻塞的任何API函数。
此外，如果应用程序使用`vTaskDelete()` API函数，则必须允许空闲任务钩子定期返回，因为空闲任务负责清理RTOS内核为已删除的任务分配的资源。

