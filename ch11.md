# 11 低功耗支持

## 11.1 省电模式介绍

FreeRTOS 提供了一种简单的方法来利用空闲任务钩子和无滴答空闲模式进入低功耗模式。

通常，通过使用空闲任务钩子将微控制器置于低功耗状态，可以减少运行 FreeRTOS 的微控制器的功耗。这种方法实现的节能效果受到需要定期退出并重新进入低功耗状态以处理滴答中断的限制。此外，如果滴答中断的频率过高（从空闲状态唤醒的频率过高），为每个滴答进入和退出低功耗状态所消耗的能量和时间将超过除最轻省电模式外的任何潜在节能收益。

FreeRTOS 支持一种低功耗状态，允许微控制器定期进入和退出低功耗模式。FreeRTOS 的无滴答空闲模式在空闲期间（当没有可执行的应用程序任务时）停止周期性滴答中断，这使得 MCU 能够保持深度省电状态，直到发生中断或 RTOS 内核需要将任务转换到就绪状态。然后，在重新启动滴答中断时，对 RTOS 滴答计数值进行校正调整。FreeRTOS 无滴答模式的原理是让 MCU 在执行空闲任务时进入低功耗模式，以节省系统功耗。


## 11.2 FreeRTOS 睡眠模式

FreeRTOS 支持三种类型的睡眠模式：

1. **eAbortSleep** - 此模式表示某个任务已准备就绪，挂起了一个上下文切换，或者已经发生了一个滴答中断但由于调度器被挂起而未能立即处理。它通知 RTOS 中止进入睡眠模式。

2. **eStandardSleep** - 此模式允许进入一个持续时间不会超过预期空闲时间的睡眠模式。

3. **eNoTasksWaitingTimeout** - 当没有任务在等待超时时，进入此模式，因此可以安全地进入只能通过外部中断或复位退出的睡眠模式。

## 11.3 函数与启用内置 Tickless Idle 功能

通过在 FreeRTOSConfig.h 中将 `configUSE_TICKLESS_IDLE` 定义为 1 来启用内置 Tickless Idle 功能（适用于支持此功能的端口）。对于任何 FreeRTOS 端口（包括那些已经包含内置实现的端口），用户可以通过在 FreeRTOSConfig.h 中将 `configUSE_TICKLESS_IDLE` 定义为 2 来提供自定义的 Tickless Idle 功能。

当 Tickless Idle 功能启用时，内核将在满足以下两个条件时调用 `portSUPPRESS_TICKS_AND_SLEEP()` 宏：

1. 空闲任务是唯一能够运行的任务，因为所有应用程序任务要么处于阻塞状态，要么处于挂起状态。

2. 至少再有 n 个完整的滴答周期后，内核才会将一个应用程序任务从阻塞状态切换出来，其中 n 由 FreeRTOSConfig.h 中的 `configEXPECTED_IDLE_TIME_BEFORE_SLEEP` 定义设置。


### 11.3.1 portSUPPRESS\_TICKS\_AND\_SLEEP() 宏

<a name="list11.1" title="Listing 11.1 The prototype for the portSUPPRESS\_TICKS\_AND\_SLEEP macro"></a>

```c
portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
```
***清单 11.1*** *portSUPPRESS\_TICKS\_AND\_SLEEP 宏的原型*

`portSUPPRESS_TICKS_AND_SLEEP()` 中的 `xExpectedIdleTime` 参数值等于任务被移动到就绪状态之前的总滴答周期数。因此，该参数值表示微控制器在抑制滴答中断的情况下可以安全保持深度睡眠状态的时间。

### 11.3.2 vPortSuppressTicksAndSleep 函数

`vPortSuppressTicksAndSleep()` 函数在 FreeRTOS 中定义，可用于实现无滴答模式。该函数在 FreeRTOS Cortex-M 移植层中被弱定义，应用程序开发者可以重写该函数。

<a name="list11.2" title="Listing 11.2 The vPortSuppressTicksAndSleep API function prototype"></a>

```c
void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
```
***清单 11.2*** *vPortSuppressTicksAndSleep API 函数的原型*


### 11.3.3 eTaskConfirmSleepModeStatus 函数

API *eTaskConfirmSleepModeStatus* 返回睡眠模式状态，以确定是否可以继续进行睡眠以及是否可以无限期睡眠。该功能仅在 `configUSE_TICKLESS_IDLE` 设置为 1 时可用。

<a name="list11.3" title="Listing 11.3 The eTaskConfirmSleepModeStatus API function prototype"></a>

```c
eSleepModeStatus eTaskConfirmSleepModeStatus( void );
```
***清单 11.3*** *eTaskConfirmSleepModeStatus API 函数原型*


如果在 `portSUPPRESS_TICKS_AND_SLEEP()` 中调用 `eTaskConfirmSleepModeStatus()` 时返回 `eNoTasksWaitingTimeout`，则微控制器可以无限期保持在深度睡眠状态。`eTaskConfirmSleepModeStatus()` 仅在以下条件为真时返回 `eNoTasksWaitingTimeout`：

+ 未使用软件定时器，因此调度器不会在未来任何时间执行定时器回调函数。

+ 所有应用程序任务要么处于挂起状态，要么处于阻塞状态且超时值为 `portMAX_DELAY`，因此调度器不会在未来任何固定时间将任务从阻塞状态转换出来。

为了避免竞态条件，FreeRTOS 调度器在调用 `portSUPPRESS_TICKS_AND_SLEEP()` 之前被挂起，并在 `portSUPPRESS_TICKS_AND_SLEEP()` 完成后恢复。这确保了在微控制器退出低功耗状态和 `portSUPPRESS_TICKS_AND_SLEEP()` 完成执行之间，应用程序任务不能执行。此外，`portSUPPRESS_TICKS_AND_SLEEP()` 函数需要在定时器停止和进入睡眠模式之间创建一个小的临界区，以确保可以安全地进入睡眠模式。`eTaskConfirmSleepModeStatus()` 应在此临界区内调用。

此外，FreeRTOS 还为用户提供了在 FreeRTOSConfig.h 中定义的其他两个接口函数。这些宏允许应用程序编写者分别在 MCU 进入低功耗状态之前和之后添加额外的步骤。


### 11.3.4 configPRE\_SLEEP\_PROCESSING 配置

<a name="list11.4" title="Listing 11.4 The prototype for the configPRE\_SLEEP\_PROCESSING macro"></a>

```c
configPRE_SLEEP_PROCESSING( xExpectedIdleTime )
```
***清单 11.4*** *configPRE\_SLEEP\_PROCESSING 宏的原型*

在用户使 MCU 进入低功耗模式之前，必须调用 `configPRE_SLEEP_PROCESSING()` 来配置系统参数以降低系统功耗，例如关闭其他外设时钟、降低系统频率。

### 11.3.5 configPOST\_SLEEP\_PROCESSING 配置

<a name="list11.5" title="Listing 11.5 The prototype for the configPOST\_SLEEP\_PROCESSING macro"></a>

```c
configPOST_SLEEP_PROCESSING( xExpectedIdleTime )
```
***清单 11.5*** *configPOST\_SLEEP\_PROCESSING 宏的原型*

在退出低功耗模式后，用户应调用 `configPOST_SLEEP_PROCESSING()` 函数以恢复系统主频和外设功能。


## 11.4 实现 `portSUPPRESS_TICKS_AND_SLEEP()` 宏

如果使用的 FreeRTOS 移植版本没有提供 `portSUPPRESS_TICKS_AND_SLEEP()` 的默认实现，那么应用程序开发者可以通过在 FreeRTOSConfig.h 中定义 `portSUPPRESS_TICKS_AND_SLEEP()` 来提供自己的实现。如果使用的 FreeRTOS 移植版本已经提供了 `portSUPPRESS_TICKS_AND_SLEEP()` 的默认实现，那么应用程序开发者仍然可以通过在 FreeRTOSConfig.h 中定义该宏来覆盖默认实现。

以下源代码展示了应用程序开发者如何实现 `portSUPPRESS_TICKS_AND_SLEEP()`。该示例较为基础，可能会导致内核维护的时间与实际日历时间之间出现一些偏差。在示例中，只有 `vTaskStepTick()` 和 `eTaskConfirmSleepModeStatus()` 是 FreeRTOS API 的一部分。其他函数与硬件上的时钟和低功耗模式相关，因此必须由应用程序开发者提供。

<a name="list11.6" title="代码清单 11.6 用户自定义的 portSUPPRESS\_TICKS\_AND\_SLEEP() 实现示例"></a>

```c
/* 首先定义 portSUPPRESS_TICKS_AND_SLEEP() 宏。参数为内核下次需要执行的时间，以 tick 为单位。 */

#define portSUPPRESS_TICKS_AND_SLEEP( xIdleTime ) vApplicationSleep( xIdleTime )

/* 定义由 portSUPPRESS_TICKS_AND_SLEEP() 调用的函数。 */
void vApplicationSleep( TickType_t xExpectedIdleTime )
{
    unsigned long ulLowPowerTimeBeforeSleep, ulLowPowerTimeAfterSleep;

    eSleepModeStatus eSleepStatus;

    /* 从在微控制器处于低功耗状态时仍可运行的时间源中读取当前时间。 */
    ulLowPowerTimeBeforeSleep = ulGetExternalTime();

    /* 停止生成 tick 中断的定时器。 */
    prvStopTickInterruptTimer();

    /* 进入一个不会影响将 MCU 从睡眠模式唤醒的中断的临界区。 */
    disable_interrupts();

    /* 确认是否仍然可以进入睡眠模式。 */
    eSleepStatus = eTaskConfirmSleepModeStatus();

    if( eSleepStatus == eAbortSleep )
    {
        /* 自从执行此宏以来，有任务已从阻塞状态移出，或者有上下文切换被挂起。不进入睡眠状态。重新启动 tick 并退出临界区。 */
        prvStartTickInterruptTimer();
        enable_interrupts();
    }
    else
    {
        if( eSleepStatus == eNoTasksWaitingTimeout )
        {
            /* 不需要配置中断以在固定时间将微控制器从低功耗状态唤醒。 */
            prvSleep();
        }
        else
        {
            /* 配置一个中断，以在内核下次需要执行时将微控制器从低功耗状态唤醒。该中断必须由在微控制器处于低功耗状态时仍可运行的源生成。 */
            vSetWakeTimeInterrupt( xExpectedIdleTime );

            /* 进入低功耗状态。 */
            prvSleep();

            /* 确定微控制器实际处于低功耗状态的时间，如果微控制器被非 vSetWakeTimeInterrupt() 配置的中断唤醒，则该时间将小于 xExpectedIdleTime。
               请注意，在调用 portSUPPRESS_TICKS_AND_SLEEP() 之前调度器被挂起，在 portSUPPRESS_TICKS_AND_SLEEP() 返回时恢复。因此，在此函数完成之前，其他任务不会执行。 */
            ulLowPowerTimeAfterSleep = ulGetExternalTime();

            /* 修正内核的 tick 计数，以反映微控制器在低功耗状态中度过的时间。 */
            vTaskStepTick( ulLowPowerTimeAfterSleep - ulLowPowerTimeBeforeSleep );
        }

        /* 退出临界区——可能在 prvSleep() 调用后立即执行。 */
        enable_interrupts();

        /* 重新启动生成 tick 中断的定时器。 */
        prvStartTickInterruptTimer();
    }
}
```
***代码清单 11.6*** *用户自定义的 portSUPPRESS\_TICKS\_AND\_SLEEP() 实现示例*


## 11.5 空闲任务钩子函数

空闲任务可以选择性地调用一个由应用程序定义的钩子（或回调）函数——空闲钩子。空闲任务以最低优先级运行，因此该空闲钩子函数只有在没有更高优先级的任务可以运行时才会被执行。这使得空闲钩子函数成为将处理器置于低功耗状态的理想位置——每当没有处理任务需要执行时，即可自动实现节能。只有在FreeRTOSConfig.h中将`configUSE_IDLE_HOOK`设置为1时，空闲钩子函数才会被调用。

<a name="list11.7" title="代码清单 11.7 vApplicationIdleHook API函数原型"></a>

```c
void vApplicationIdleHook( void );
```
***代码清单 11.7*** *vApplicationIdleHook API函数原型*

只要空闲任务在运行，空闲钩子函数就会被重复调用。至关重要的是，空闲钩子函数不能调用任何可能导致其阻塞的API函数。此外，如果应用程序使用了`vTaskDelete()` API函数，则必须允许空闲任务钩子函数定期返回，因为空闲任务负责清理RTOS内核为已删除任务分配的资源。

