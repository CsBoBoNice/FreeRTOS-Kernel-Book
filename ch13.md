# 13 故障排除

## 13.1 章节介绍和范围

本章节重点介绍了新用户在使用 FreeRTOS 时遇到的常见问题。首先，它着重关注三个多年来最常引发支持请求的问题：不正确的中断优先级分配、栈溢出以及不恰当的 printf() 使用。然后，它以常见问题解答 (FAQ) 的形式，简要地触及其他常见错误、其可能的原因以及解决方案。

> *使用 `configASSERT()` 可以通过立即捕获和识别许多常见的错误来源来提高生产力。强烈建议在开发或调试 FreeRTOS 应用程序时定义 `configASSERT()`。`configASSERT()` 在第 12.2 节中进行了描述。*


## 13.2 中断优先级

> *注意：这是支持请求的首要原因，并且在大多数端口中定义 `configASSERT()` 将立即捕获此错误！*

如果所使用的 FreeRTOS 端口支持中断嵌套，并且中断服务例程使用 FreeRTOS API，那么*至关重要*的是将中断的优先级设置为等于或低于 `configMAX_SYSCALL_INTERRUPT_PRIORITY`，如第 7.8 节“中断嵌套”中所述。未能做到这一点将导致无效的临界区，进而导致间歇性故障。

如果要在以下处理器上运行 FreeRTOS 时要特别小心：

- 中断优先级默认具有最高的可能优先级，这在某些 ARM Cortex 处理器和其他处理器中是这种情况。在这些处理器上，使用 FreeRTOS API 的中断的优先级不能未初始化。

- 数字较高的优先级编号代表逻辑较低的中断优先级，这可能看起来违反直觉，因此会造成困惑。同样，这在 ARM Cortex 处理器和其他处理器中是这种情况。

- 例如，在这样的处理器上，以优先级 5 执行的中断本身可能被具有优先级 4 的中断中断。因此，如果 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 设置为 5，则可以使用 FreeRTOS API 的任何中断只能分配大于或等于 5 的数字优先级。在这种情况下，优先级 5 或 6 是有效的，但优先级 3 绝对无效。

  ![](media/image91.png)

- 不同的库实现期望以不同的方式指定中断的优先级。同样，这与针对 ARM Cortex 处理器设计的库特别相关，因为这些库在将优先级写入硬件寄存器之前会进行位移。某些库将执行位移，而其他库则期望在将优先级传递到库函数之前执行位移。

- 同一架构的不同实现实现了不同数量的中断优先级位。例如，一个制造商的 Cortex-M 处理器可能实现 3 个优先级位，而另一个制造商的 Cortex-M 处理器可能实现 4 个优先级位。

- 定义中断优先级的位可以分为定义抢占优先级和定义子优先级。确保所有位都用于指定抢占优先级，因此不要使用子优先级。

在某些 FreeRTOS 端口中，`configMAX_SYSCALL_INTERRUPT_PRIORITY` 有替代名称 `configMAX_API_CALL_INTERRUPT_PRIORITY`。


## 13.3 栈溢出

栈溢出是支持请求的第二大来源。FreeRTOS 提供了多种功能来协助捕获和调试与栈相关的问题[^28]。

[^28]: 这些功能在 FreeRTOS Windows 端口中不可用。

### 13.3.1 `uxTaskGetStackHighWaterMark()` API 函数

每个任务都维护自己的栈，其总大小在任务创建时指定。`uxTaskGetStackHighWaterMark()` 用于查询任务使用的栈空间是否接近其分配的栈空间。这个值被称为栈的“高水位标记”。

<a name="list13.1" title="列表 13.1 `uxTaskGetStackHighWaterMark()` API 函数原型"></a>

```c
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );
```
***列表 13.1*** *`uxTaskGetStackHighWaterMark()` API 函数原型*

**`uxTaskGetStackHighWaterMark()` 参数和返回值**

- `xTask`

  正在查询其栈高水位标记的任务的句柄（主题任务）——有关获取任务句柄的信息，请参阅 `xTaskCreate()` API 函数的 `pxCreatedTask` 参数。

  任务可以通过在有效任务句柄处传递 NULL 来查询其自己的栈高水位标记。

- 返回值

  任务使用的栈空间会随着任务执行和中断处理而增长和缩小。`uxTaskGetStackHighWaterMark()` 返回自任务开始执行以来可用剩余栈空间的最小值。这是在栈使用达到最大（或最深）值时剩余的栈空间量。高水位标记越接近零，任务就越接近栈溢出。

可以代替 `uxTaskGetStackHighWaterMark()` 使用 `uxTaskGetStackHighWaterMark2()` API，它们唯一的区别在于返回值类型。

<a name="list13.2" title="列表 13.2 `uxTaskGetStackHighWaterMark2()` API 函数原型"></a>

```c
configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask );
```
***列表 13.2*** *`uxTaskGetStackHighWaterMark2()` API 函数原型*

使用 `configSTACK_DEPTH_TYPE` 允许应用程序编写者控制用于栈深度的类型。

### 13.3.2 运行时栈检查—概述

FreeRTOS 包含三种可选的运行时栈检查机制。这些机制由 FreeRTOSConfig.h 中的编译时配置常量 `configCHECK_FOR_STACK_OVERFLOW` 控制。这两种方法都会增加执行上下文切换所需的时间。

栈溢出钩子（或栈溢出回调）是一个函数，当内核检测到栈溢出时，它会调用该函数。要使用栈溢出钩子函数：

1. 在 FreeRTOSConfig.h 中将 `configCHECK_FOR_STACK_OVERFLOW` 设置为 1、2 或 3，如以下子节所述。

2. 提供钩子函数的实现，使用列表 13.3 中显示的精确函数名称和原型。

<a name="list13.3" title="列表 13.3 栈溢出钩子函数原型"></a>

```c
void vApplicationStackOverflowHook( TaskHandle_t *pxTask, signed char *pcTaskName );
```
***列表 13.3*** *The stack overflow hook function prototype*

栈溢出钩子旨在简化栈错误的捕获和调试，但在发生栈溢出时，实际上无法从中恢复。该函数的参数将发生栈溢出的任务的句柄和名称传递到钩子函数中。

栈溢出钩子从中断上下文中调用。

某些微控制器在检测到错误的内存访问时会生成故障异常，并且有可能在内核有机会调用栈溢出钩子函数之前触发故障。


### 13.3.3 运行时栈检查—方法 1

当 `configCHECK_FOR_STACK_OVERFLOW` 设置为 1 时，选择方法 1。

每次任务被切换出去时，其整个执行上下文都会被保存到其栈中。这很可能是在栈使用量达到峰值的时间点。当 `configCHECK_FOR_STACK_OVERFLOW` 设置为 1 时，内核会检查在保存上下文后，栈指针是否仍然在有效的栈空间范围内。如果发现栈指针超出其有效范围，则会调用栈溢出钩子。

方法 1 执行速度很快，但可能会错过上下文切换之间发生的栈溢出。

### 13.3.4 运行时栈检查—方法 2

方法 2 执行额外的检查，这些检查已经为方法 1 描述过。当 `configCHECK_FOR_STACK_OVERFLOW` 设置为 2 时，选择方法 2。

当任务被创建时，其栈会被填充一个已知的模式。方法 2 测试任务栈空间的最后 20 个有效字节，以验证该模式是否未被覆盖。如果任何 20 个字节已从其预期值更改，则会调用栈溢出钩子函数。

方法 2 的执行速度不如方法 1 快，但仍然相对较快，因为只需要测试 20 个字节。最有可能的是，它会捕获所有栈溢出；但是，有可能（尽管可能性很小）会遗漏一些溢出。

### 13.3.4 运行时栈检查—方法 3

当 `configCHECK_FOR_STACK_OVERFLOW` 设置为 3 时，选择方法 3。

此方法仅适用于选定的端口。当可用时，此方法启用 ISR 栈检查。当检测到 ISR 栈溢出时，会触发断言。请注意，在这种情况下，不会调用栈溢出钩子函数，因为它特定于任务栈，而不是 ISR 栈。

## 13.4 printf() 和 sprintf() 的使用

通过 `printf()` 进行日志记录是常见的错误来源，并且，
对此一无所知，应用程序开发人员通常会添加进一步的 `printf()` 调用来辅助调试，从而加剧问题。

许多交叉编译器供应商将提供适用于小型嵌入式系统的 `printf()` 实现。即使在那种情况下，该实现可能也不具备线程安全，很可能不适合在中断服务例程中使用，并且，取决于输出方向，执行时间可能相对较长。

如果无法使用专门为小型嵌入式系统设计的 `printf()` 实现，而是使用通用的 `printf()` 实现，则必须特别小心，因为：

- 仅仅包含对 `printf()` 或 `sprintf()` 的调用就可以大大增加应用程序可执行文件的大小。

- `printf()` 和 `sprintf()` 可能会调用 `malloc()`，如果使用了除 heap_3 之外的内存分配方案，则这可能无效。有关更多信息，请参见第 3.2 节，示例内存分配方案。

- `printf()` 和 `sprintf()` 可能需要比通常需要的更大的栈空间。


### 13.4.1 printf-stdarg.c

许多 FreeRTOS 演示项目使用一个名为 printf-stdarg.c 的文件，它提供了一个最小且栈效率高的 `sprintf()` 实现，可以替代标准库版本。在大多数情况下，这将允许为调用 `sprintf()` 和相关函数的每个任务分配一个更小的栈空间。

printf-stdarg.c 还提供了一种机制，可以将 `printf()` 输出定向到端口，逐个字符地输出，虽然速度较慢，但可以进一步减少栈的使用量。

请注意，FreeRTOS 下载中包含的并非所有 `printf-stdarg.c` 版本都实现了 `snprintf()`。未实现 `snprintf()` 的版本会简单地忽略缓冲区大小参数，因为它们直接映射到 `sprintf()`。

printf-stdarg.c 是开源的，但由第三方拥有，因此其许可证与 FreeRTOS 许可证分开。许可证条款包含在源文件的顶部。

## 13.5 其他常见的错误来源

### 13.5.1 症状：向演示程序添加一个简单任务会导致演示程序崩溃

创建任务需要从堆中获取内存。许多演示应用程序项目将堆的大小设置为刚好足够创建演示任务——因此，在任务创建后，将没有足够的堆空间供任何进一步的任务、队列、事件组或信号量添加。

空闲任务，以及可能还有 RTOS 守护进程任务，会在调用 `vTaskStartScheduler()` 时自动创建。`vTaskStartScheduler()` 仅在剩余的堆内存不足以创建这些任务时才会返回。在 `vTaskStartScheduler()` 调用后包含一个空循环 `[ for(;;); ]` 可以使此错误更容易调试。

为了能够添加更多任务，您必须要么增加堆的大小，要么删除一些现有的演示任务。堆大小的增加始终受到可用 RAM 数量的限制。有关更多信息，请参见第 3.2 节，示例内存分配方案。


### 13.5.2 症状：在中断服务例程中使用API函数导致应用程序崩溃

除非API函数名称以 '...FromISR()' 结尾，否则请勿在中断服务例程中使用API函数。特别是，除非使用中断安全宏，否则请勿在中断中创建临界区。有关更多信息，请参见第 7.2 节，从ISR中使用FreeRTOS API。

在支持中断嵌套的 FreeRTOS 端口中，请勿在具有高于 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 割り当てられた中断优先级的中断中使用任何API函数。有关更多信息，请参见第 7.8 节，中断嵌套。

### 13.5.3 症状：有时应用程序会在中断服务例程中崩溃

首先要检查的是中断是否导致堆栈溢出。某些端口仅在任务中检查堆栈溢出，而不在中断中检查。

中断的定义和使用方式因端口和编译器而异。因此，要检查的第二个问题是中断服务例程中使用的语法、宏和调用约定是否完全符合所用端口的文档页面描述，以及端口提供的演示应用程序中的演示。

如果应用程序运行在数值较低的优先级数字表示逻辑高优先级的处理器上，请确保为每个中断分配的优先级考虑到这一点，因为这可能会显得违反直觉。如果应用程序运行在默认将每个中断的优先级设置为最大可能优先级的处理器上，请确保每个中断的优先级未保留在其默认值。有关更多信息，请参见第 7.8 节，中断嵌套，和第 13.2 节，中断优先级。


### 13.5.4 症状：尝试启动第一个任务时，调度器崩溃

确保已安装 FreeRTOS 中断处理程序。请参阅所用 FreeRTOS 端口的文档页面以获取信息，以及端口提供的演示应用程序以获取示例。

某些处理器必须处于特权模式，调度器才能启动。实现此目的的最简单方法是在调用 main() 之前，在 C 启动代码中将处理器置于特权模式。

### 13.5.5 症状：中断意外地保持禁用状态，或者临界区嵌套不正确

如果在调度器启动之前调用 FreeRTOS API 函数，则中断将被故意保持禁用状态，并且在第一个任务开始执行之前，将不会再次启用。这是为了保护系统免受在系统初始化期间尝试使用 FreeRTOS API 函数的中断造成的崩溃，此时调度器可能处于不一致状态。

请勿使用任何其他方法（如调用 `taskENTER_CRITICAL()` 和 `taskEXIT_CRITICAL()`）来更改微控制器的中断使能位或优先级标志。这些宏会跟踪其调用嵌套深度，以确保仅当调用嵌套完全回滚到零时，中断才能再次启用。请注意，某些库函数本身可能会使能和禁用中断。


### 13.5.6 症状：应用程序在调度器启动之前崩溃

可能导致上下文切换的中断服务例程，在调度器启动之前不能被允许执行。同样适用于任何尝试向 FreeRTOS 对象（如队列或信号量）发送或接收的中断服务例程。在调度器启动之后，才能发生上下文切换。

许多 API 函数在调度器启动之后才能被调用。最好将 API 使用限制在创建对象（如任务、队列和信号量）上，而不是使用这些对象，直到调用 `vTaskStartScheduler()` 为止。

### 13.5.7 症状：在调度器挂起时或在临界区内部调用 API 函数会导致应用程序崩溃

通过调用 `vTaskSuspendAll()` 挂起调度器，并通过调用 `xTaskResumeAll()` 恢复（取消挂起）调度器。通过调用 `taskENTER_CRITICAL()` 进入临界区，并通过调用 `taskEXIT_CRITICAL()` 退出临界区。

不要在调度器挂起时或在临界区内部调用 API 函数。

## 13.6 其他调试步骤

如果遇到未在上述常见原因中描述的问题，您可以尝试以下一些调试步骤。

- 定义 `configASSERT()`，并在应用程序的 FreeRTOSConfig 文件中启用 malloc 失败检查和堆栈溢出检查。
- 检查 FreeRTOS API 的返回值，以确保它们成功。
- 检查与调度器相关的配置，例如 `configUSE_TIME_SLICING` 和 `configUSE_PREEMPTION` 是否已根据应用程序要求正确设置。
- [此页面](https://www.freertos.org/Debugging-Hard-Faults-On-Cortex-M-Microcontrollers.html)
  提供了有关在 Cortex-M 微控制器上调试硬错误的详细信息。

