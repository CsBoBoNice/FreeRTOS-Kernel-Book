# 13 故障排除

## 13.1 章节介绍和范围

本章节突出了新手用户在使用FreeRTOS时遇到的最常见问题。首先，它集中讨论了三个问题，这些问题在多年来被证明是支持请求的最常见来源：错误的中断优先级分配、栈溢出和不当使用printf()。然后，它简要地、以常见问题解答的形式，涉及其他常见错误、它们可能的原因及其解决方案。

> 使用 `configASSERT()` 可以通过立即捕获和识别许多最常见的错误来源来提高生产力。 强烈建议在开发或调试FreeRTOS应用程序时定义 `configASSERT()`。 `configASSERT()` 在12.2节中有描述。


## 13.2 中断优先级

> *注意：这是支持请求的主要原因，并且在大多数端口中定义 `configASSERT()` 将立即捕获错误！*

如果使用的FreeRTOS端口支持中断嵌套，并且中断服务程序使用FreeRTOS API，那么中断的优先级必须设置为 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 或更低，如第7.8节中断嵌套中所述。如果不这样做，将导致临界区无效，从而导致间歇性故障。

特别注意在运行FreeRTOS的处理器上：

- 中断优先级默认为最高优先级，这是一些ARM Cortex处理器的情况，可能还有其他处理器。在这样的处理器上，使用FreeRTOS API的中断的优先级不能保持未初始化状态。

- 数值较高的优先级数表示逻辑上较低的中断优先级，这可能会让人感到困惑。这也是ARM Cortex处理器的情况，可能还有其他处理器。

- 例如，在这样的处理器上，优先级为5的中断可以被优先级为4的中断中断。因此，如果 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 设置为5，那么任何使用FreeRTOS API的中断只能分配一个数值上大于或等于5的优先级。在这种情况下，中断优先级5或6是有效的，但中断优先级3是绝对无效的。

  ![](media/image91.png)

- 不同的库实现期望以不同的方式指定中断的优先级。这对于针对ARM Cortex处理器的库特别相关，其中中断优先级在写入硬件寄存器之前会进行位移。一些库会自己进行位移，而另一些库则期望在将优先级传递给库函数之前进行位移。

- 同一架构的不同实现实现不同数量的中断优先级位。例如，一个制造商的Cortex-M处理器可能实现3个优先级位，而另一个制造商的Cortex-M处理器可能实现4个优先级位。

- 定义中断优先级的位可以分为定义抢占优先级的位和定义子优先级的位。确保所有位都分配给指定抢占优先级，以便不使用子优先级。

在一些FreeRTOS端口中，`configMAX_SYSCALL_INTERRUPT_PRIORITY` 有替代名称 `configMAX_API_CALL_INTERRUPT_PRIORITY`。


## 13.3 堆栈溢出

堆栈溢出是支持请求的第二大常见来源。FreeRTOS提供了几个功能来帮助捕获和调试与堆栈相关的问题[^28]。

[^28]: 这些功能在FreeRTOS Windows端口中不可用。

### 13.3.1 uxTaskGetStackHighWaterMark() API函数

每个任务都维护自己的堆栈，其总大小在创建任务时指定。`uxTaskGetStackHighWaterMark()`用于查询任务是否接近溢出分配给它的堆栈空间。这个值称为堆栈的“高水位标记”。

<a name="list13.1" title="Listing 13.1 The uxTaskGetStackHighWaterMark() API function prototype"></a>

```c
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );
```
***Listing 13.1*** *The uxTaskGetStackHighWaterMark() API function prototype*

**uxTaskGetStackHighWaterMark() 参数和返回值**

- `xTask`

  正在查询其堆栈高水位标记的任务的句柄（主题任务）——有关获取任务句柄的信息，请参阅`xTaskCreate()` API函数的pxCreatedTask参数。

  任务可以通过在有效任务句柄的位置传递NULL来查询自己的堆栈高水位标记。

- 返回值

  任务执行和处理中断时，任务使用的堆栈量会增加和减少。`uxTaskGetStackHighWaterMark()`返回自任务开始执行以来可用的最小剩余堆栈空间量。这是当堆栈使用量达到最大（或最深）值时保持未使用的堆栈量。高水位标记越接近零，任务就越接近溢出其堆栈。

可以使用`uxTaskGetStackHighWaterMark2()` API代替`uxTaskGetStackHighWaterMark()`，它仅在返回类型上有所不同。

<a name="list13.2" title="Listing 13.2 The uxTaskGetStackHighWaterMark2() API function prototype"></a>

```c
configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask );
```
***Listing 13.2*** *The uxTaskGetStackHighWaterMark2() API function prototype*

使用`configSTACK_DEPTH_TYPE`允许应用程序编写器控制用于堆栈深度的类型。

### 13.3.2 运行时堆栈检查—概述

FreeRTOS 包含三种可选的运行时堆栈检查机制。这些机制由 `configCHECK_FOR_STACK_OVERFLOW` 编译时配置常量在 FreeRTOSConfig.h 中控制。这两种方法都会增加上下文切换所需的时间。

堆栈溢出钩子（或堆栈溢出回调）是一个函数，当内核检测到堆栈溢出时会被调用。要使用堆栈溢出钩子函数：

1. 将 `configCHECK_FOR_STACK_OVERFLOW` 设置为 1、2 或 3，如下面的子节所述。

1. 提供钩子函数的实现，使用清单 13.3 中显示的精确函数名称和原型。

<a name="list13.3" title="清单 13.3 堆栈溢出钩子函数原型"></a>

```c
void vApplicationStackOverflowHook( TaskHandle_t *pxTask, signed char *pcTaskName );
```
***清单 13.3*** *堆栈溢出钩子函数原型*

堆栈溢出钩子提供了捕获和调试堆栈错误的方法，但当发生堆栈溢出时，实际上没有办法恢复。函数的参数将溢出堆栈的任务的句柄和名称传递给钩子函数。

堆栈溢出钩子从中断的上下文中调用。

某些微控制器在检测到不正确的内存访问时会生成故障异常，并且在内核有机会调用堆栈溢出钩子函数之前，可能会触发故障。


### 13.3.3 运行时堆栈检查—方法1

当 `configCHECK_FOR_STACK_OVERFLOW` 设置为 1 时，选择方法 1。

每次任务被交换出时，其整个执行上下文都会保存到其堆栈中。这很可能是堆栈使用量达到峰值的时刻。当 `configCHECK_FOR_STACK_OVERFLOW` 设置为 1 时，内核会检查在保存上下文后堆栈指针是否仍在有效堆栈空间内。如果发现堆栈指针超出其有效范围，则调用堆栈溢出钩子。

方法 1 执行速度快，但可能会错过上下文切换之间发生的堆栈溢出。

### 13.3.4 运行时堆栈检查—方法2

方法 2 执行额外的检查，这些检查已经在方法 1 中描述过。当 `configCHECK_FOR_STACK_OVERFLOW` 设置为 2 时，选择方法 2。

创建任务时，其堆栈会填充已知模式。方法 2 测试任务堆栈空间的最后 20 个字节的有效性，以验证该模式是否被覆盖。如果 20 个字节中的任何一个改变了其预期值，则调用堆栈溢出钩子函数。

方法 2 的执行速度不如方法 1 快，但仍然相对较快，因为只测试 20 个字节。它很可能会捕获所有堆栈溢出；然而，可能（但极不可能）会错过一些溢出。

### 13.3.4 运行时堆栈检查—方法 3

当 `configCHECK_FOR_STACK_OVERFLOW` 设置为 3 时，选择方法 3。

此方法仅适用于选定的端口。当可用时，此方法启用 ISR 堆栈检查。当检测到 ISR 堆栈溢出时，会触发一个断言。请注意，在这种情况下不会调用堆栈溢出钩子函数，因为它特定于任务堆栈而不是 ISR 堆栈。

## 13.4 使用 `printf()` 和 `sprintf()`

通过 `printf()` 进行日志记录是错误的常见来源，开发人员往往会添加更多的 `printf()` 调用来帮助调试，从而加剧问题。

许多交叉编译器供应商都会提供一个适用于小型嵌入式系统的 `printf()` 实现。即使在这种情况下，实现可能不具备线程安全性，可能不适合在中断服务例程内部使用，并且根据输出的目标，执行时间可能相对较长。

如果没有专门为小型嵌入式系统设计的 `printf()` 实现，而是使用通用的 `printf()` 实现，则需要特别注意：

- 仅包含对 `printf()` 或 `sprintf()` 的调用，可能会显著增加应用程序可执行文件的大小。

- `printf()` 和 `sprintf()` 可能会调用 `malloc()`，如果使用的内存分配方案不是 heap_3，则可能无效。有关更多信息，请参阅第 3.2 节，示例内存分配方案。

- `printf()` 和 `sprintf()` 可能需要比通常所需的堆栈大得多。


### 13.4.1 Printf-stdarg.c

许多FreeRTOS演示项目使用一个名为printf-stdarg.c的文件，该文件提供了一个最小且堆栈高效的`sprintf()`实现，可以替代标准库版本。在大多数情况下，这将允许为调用`sprintf()`及相关函数的每个任务分配一个更小的堆栈。

printf-stdarg.c还提供了一种机制，可以逐字符将`printf()`的输出定向到端口，尽管速度较慢，但可以进一步减少堆栈的使用。

请注意，FreeRTOS下载中包含的`printf-stdarg.c`的所有副本并不都实现了`snprintf()`。没有实现`snprintf()`的副本会忽略缓冲区大小参数，因为它们直接映射到`sprintf()`。

printf-stdarg.c是开源的，但由第三方所有，因此与FreeRTOS单独许可。许可条款包含在源文件的顶部。

## 13.5 其他常见错误来源

### 13.5.1 症状：向演示中添加一个简单任务会导致演示崩溃

创建任务需要从堆中获取内存。许多演示应用程序项目将堆的大小调整为刚好足够创建演示任务——因此，在创建任务后，将没有足够的堆空间来添加任何进一步的任务、队列、事件组或信号量。

空闲任务和可能的RTOS守护任务在调用`vTaskStartScheduler()`时会自动创建。`vTaskStartScheduler()`仅在没有足够的堆内存来创建这些任务时才会返回。在调用`vTaskStartScheduler()`后包含一个空循环`[ for(;;); ]`可以使调试此错误更容易。

要能够添加更多任务，必须增加堆大小，或者删除一些现有的演示任务。堆大小的增加将始终受可用RAM量的限制。有关更多信息，请参阅第3.2节，示例内存分配方案。


### 13.5.2 症状：在中断中使用API函数导致应用程序崩溃

在中断服务例程中不要使用API函数，除非API函数的名称以'...FromISR()'结尾。特别是，在中断中不要创建临界区，除非使用中断安全的宏。有关更多信息，请参阅第7.2节，从ISR使用FreeRTOS API。

在支持中断嵌套的FreeRTOS端口中，不要在分配的中断优先级高于`configMAX_SYSCALL_INTERRUPT_PRIORITY`的中断中使用任何API函数。有关更多信息，请参阅第7.8节，中断嵌套。

### 13.5.3 症状：有时应用程序在中断服务例程中崩溃

首先要检查的是中断是否导致堆栈溢出。某些端口只在任务中检查堆栈溢出，而不在中断中检查。

中断的定义和使用方式在端口和编译器之间有所不同。因此，第二件要检查的事情是中断服务例程中使用的语法、宏和调用约定是否与所使用端口的文档页面上描述的完全相同，并且与端口提供的演示应用程序中展示的完全相同。

如果应用程序在使用数值较低的优先级数来表示逻辑上较高优先级的处理器上运行，则确保分配给每个中断的优先级考虑到这一点，因为这可能会显得反直觉。如果应用程序在默认每个中断的优先级为最大可能优先级的处理器上运行，则确保每个中断的优先级不保留其默认值。有关更多信息，请参阅第7.8节，中断嵌套，和第13.2节，中断优先级。


### 13.5.4 症状：调度器在尝试启动第一个任务时崩溃

确保已安装FreeRTOS中断处理程序。有关信息，请参阅所使用的FreeRTOS端口的文档页面，以及为该端口提供的演示应用程序示例。

某些处理器在启动调度器之前必须处于特权模式。实现这一点的最简单方法是在调用main()之前，在C启动代码中将处理器置于特权模式。

### 13.5.5 症状：中断意外地被禁用，或者关键部分无法正确嵌套

如果在调度器启动之前调用了FreeRTOS API函数，则中断将故意被禁用，并且在第一个任务开始执行之前不会再次启用。这样做是为了保护系统免受在系统初始化期间尝试使用FreeRTOS API函数的中断引起的崩溃，此时调度器可能处于不一致的状态。

不要使用任何其他方法（例如调用`taskENTER_CRITICAL()`和`taskEXIT_CRITICAL()`）来更改微控制器的中断使能位或优先级标志。这些宏会计数它们的调用嵌套深度，以确保中断仅在调用嵌套完全展开为零时才重新启用。请注意，某些库函数可能会自己启用和禁用中断。


### 13.5.6 症状：应用程序在调度器启动之前崩溃

可能导致上下文切换的中断服务例程在调度器启动之前不应被允许执行。同样，任何尝试向FreeRTOS对象（如队列或信号量）发送或接收的中断服务例程也适用。在调度器启动之前不能发生上下文切换。

许多API函数在调度器启动之前不能被调用。最好在调用`vTaskStartScheduler()`之前，限制API的使用范围为创建对象（如任务、队列和信号量），而不是使用这些对象。

### 13.5.7 症状：在调度器暂停或在临界区内调用API函数会导致应用程序崩溃

调度器通过调用`vTaskSuspendAll()`暂停，并通过调用`xTaskResumeAll()`恢复（取消暂停）。临界区通过调用`taskENTER_CRITICAL()`进入，并通过调用`taskEXIT_CRITICAL()`退出。

在调度器暂停或在临界区内不要调用API函数。

## 13.6 附加调试步骤

如果遇到未在上述常见原因中涵盖的问题，可以尝试使用以下调试步骤。

- 在应用程序的FreeRTOSConfig文件中定义`configASSERT()`，启用内存分配失败检查和栈溢出检查。
- 检查FreeRTOS API的返回值，以确保它们成功。
- 检查与调度器相关的配置，如`configUSE_TIME_SLICING`和`configUSE_PREEMPTION`，确保它们根据应用程序要求正确设置。
- [此页面](https://www.freertos.org/Debugging-Hard-Faults-On-Cortex-M-Microcontrollers.html) 提供了有关在Cortex-M微控制器上调试硬故障的详细信息。

