# 13 故障排除

## 13.1 章节介绍与范围

本章重点介绍FreeRTOS新手用户最常遇到的问题。首先，它聚焦于多年来被证明是支持请求最频繁来源的三个问题：中断优先级分配错误、堆栈溢出以及不恰当地使用`printf()`。随后，以FAQ形式简要提及其他常见错误、可能的原因及其解决方案。

> *使用`configASSERT()`可以立即捕获并识别许多最常见的错误来源，从而提高工作效率。强烈建议在开发或调试FreeRTOS应用程序时定义`configASSERT()`。`configASSERT()`在第12.2节中有详细描述。*

## 13.2 中断优先级

> *注意：这是支持请求的首要原因，在大多数移植版本中，定义`configASSERT()`会立即捕获此错误！*

如果使用的FreeRTOS移植版本支持中断嵌套，并且中断服务程序使用了FreeRTOS API，那么*必须*将该中断的优先级设置为等于或低于`configMAX_SYSCALL_INTERRUPT_PRIORITY`，如第7.8节“中断嵌套”中所述。未能做到这一点将导致临界区失效，从而引发间歇性故障。

如果在以下处理器上运行FreeRTOS，请特别注意：

- 中断优先级默认设置为最高优先级，一些ARM Cortex处理器（可能还有其他处理器）就是这种情况。在此类处理器上，不能未初始化使用FreeRTOS API的中断的优先级。

- 数值高的优先级表示逻辑上低的中断优先级，这可能看起来违反直觉，因此容易引起混淆。ARM Cortex处理器（可能还有其他处理器）也存在这种情况。

- 例如，在此类处理器上，优先级为5的中断可以被优先级为4的中断打断。因此，如果`configMAX_SYSCALL_INTERRUPT_PRIORITY`设置为5，任何使用FreeRTOS API的中断只能分配数值上大于或等于5的优先级。在这种情况下，优先级为5或6的中断是有效的，但优先级为3的中断绝对无效。

  ![](media/image91.png)

- 不同的库实现期望以不同的方式指定中断优先级。这一点尤其适用于针对ARM Cortex处理器的库，在这些库中，中断优先级在被写入硬件寄存器之前会进行位移。一些库会自行执行位移，而其他库则期望在将优先级传递给库函数之前执行位移。

- 相同架构的不同实现可能实现不同数量的中断优先级位。例如，一个制造商的Cortex-M处理器可能实现3个优先级位，而另一个制造商的Cortex-M处理器可能实现4个优先级位。

- 定义中断优先级的位可能分为定义抢占优先级和子优先级的位。确保所有位都用于指定抢占优先级，以便不使用子优先级。

在某些FreeRTOS移植版本中，`configMAX_SYSCALL_INTERRUPT_PRIORITY`的别名为`configMAX_API_CALL_INTERRUPT_PRIORITY`。


## 13.3 栈溢出

栈溢出是支持请求的第二大常见来源。FreeRTOS 提供了多项功能，以帮助捕获和调试与栈相关的问题[^28]。

[^28]: 这些功能在 FreeRTOS 的 Windows 移植版本中不可用。

### 13.3.1 uxTaskGetStackHighWaterMark() API 函数

每个任务都维护自己的栈，其总大小在任务创建时指定。`uxTaskGetStackHighWaterMark()` 用于查询任务已接近溢出分配给它的栈空间的程度。该值称为栈的“高水位标记”。

<a name="list13.1" title="Listing 13.1 The uxTaskGetStackHighWaterMark() API function prototype"></a>

```c
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );
```
***清单 13.1*** *uxTaskGetStackHighWaterMark() API 函数原型*

**uxTaskGetStackHighWaterMark() 参数和返回值**

- `xTask`

  正在查询栈高水位标记的任务的句柄（目标任务）——有关获取任务句柄的信息，请参阅 `xTaskCreate()` API 函数的 pxCreatedTask 参数。

  任务可以通过传递 NULL 来代替有效的任务句柄来查询自己的栈高水位标记。

- 返回值

  任务使用的栈量随着任务的执行和中断的处理而增长和收缩。`uxTaskGetStackHighWaterMark()` 返回自任务开始执行以来可用的剩余栈空间的最小值。这是栈使用量达到其最大（或最深）值时剩余的未使用栈量。高水位标记越接近零，任务越接近溢出其栈。

可以使用 `uxTaskGetStackHighWaterMark2()` API 代替 `uxTaskGetStackHighWaterMark()`，两者的区别仅在于返回类型。


<a name="list13.2" title="Listing 13.2 The uxTaskGetStackHighWaterMark2() API function prototype"></a>

```c
configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask );
```
***清单 13.2*** *uxTaskGetStackHighWaterMark2() API 函数原型*

使用 `configSTACK_DEPTH_TYPE` 允许应用程序编写者控制用于栈深度的类型。

### 13.3.2 运行时堆栈检查——概述

FreeRTOS 包含三种可选的运行时堆栈检查机制。这些机制由 FreeRTOSConfig.h 中的 `configCHECK_FOR_STACK_OVERFLOW` 编译时配置常量控制。两种方法都会增加执行上下文切换所需的时间。

堆栈溢出钩子函数（或堆栈溢出回调函数）是内核在检测到堆栈溢出时调用的函数。要使用堆栈溢出钩子函数：

1. 在 FreeRTOSConfig.h 中将 `configCHECK_FOR_STACK_OVERFLOW` 设置为 1、2 或 3，如下文所述。

2. 提供钩子函数的实现，使用代码清单 13.3 中所示的函数名称和原型。

<a name="list13.3" title="代码清单 13.3 堆栈溢出钩子函数原型"></a>

```c
void vApplicationStackOverflowHook( TaskHandle_t *pxTask, signed char *pcTaskName );
```
***代码清单 13.3*** *堆栈溢出钩子函数原型*

堆栈溢出钩子函数的作用是使捕获和调试堆栈错误更加容易，但当堆栈溢出发生时，实际上无法从中恢复。该函数的参数将堆栈溢出的任务的句柄和名称传递给钩子函数。

堆栈溢出钩子函数在中断上下文中被调用。

某些微控制器在检测到错误的内存访问时会生成故障异常，并且可能在内核有机会调用堆栈溢出钩子函数之前触发故障。


### 13.3.3 运行时栈检查——方法 1

当 `configCHECK_FOR_STACK_OVERFLOW` 设置为 1 时，选择方法 1。

每次任务被切换出时，其完整的执行上下文都会保存到其栈中。此时栈的使用量很可能达到峰值。当 `configCHECK_FOR_STACK_OVERFLOW` 设置为 1 时，内核会在上下文保存后检查栈指针是否仍在有效的栈空间内。如果发现栈指针超出其有效范围，则调用栈溢出钩子函数。

方法 1 执行速度快，但可能会遗漏在上下文切换之间发生的栈溢出。

### 13.3.4 运行时栈检查——方法 2

方法 2 在方法 1 的基础上执行额外的检查。当 `configCHECK_FOR_STACK_OVERFLOW` 设置为 2 时，选择方法 2。

在任务创建时，其栈会被填充为已知的模式。方法 2 会测试任务栈空间的最后 20 个有效字节，以验证该模式是否被覆盖。如果这 20 个字节中的任何一个与预期值不符，则调用栈溢出钩子函数。

方法 2 的执行速度不如方法 1 快，但由于仅测试 20 个字节，仍然相对较快。它很可能捕获所有栈溢出；然而，也有可能（尽管概率极低）遗漏某些溢出情况。

### 13.3.4 运行时堆栈检查——方法 3

当 `configCHECK_FOR_STACK_OVERFLOW` 设置为 3 时，将选择方法 3。

该方法仅适用于特定移植版本。当可用时，该方法支持 ISR（中断服务程序）堆栈检查。当检测到 ISR 堆栈溢出时，将触发断言。注意，堆栈溢出钩子函数在此情况下不会被调用，因为它仅适用于任务堆栈，而非 ISR 堆栈。

## 13.4 `printf()` 和 `sprintf()` 的使用

通过 `printf()` 进行日志记录是常见的错误来源，而应用程序开发者在未意识到这一点的情况下，通常会添加更多的 `printf()` 调用来辅助调试，从而加剧了问题。

许多交叉编译器供应商会提供适用于小型嵌入式系统的 `printf()` 实现。即便如此，该实现可能不是线程安全的，可能不适合在中断服务程序中使用，并且根据输出的目标位置，执行时间可能相对较长。

如果未能使用专为小型嵌入式系统设计的 `printf()` 实现，而是使用了通用的 `printf()` 实现，则必须特别小心，因为：

- 仅包含对 `printf()` 或 `sprintf()` 的调用，就可能大幅增加应用程序可执行文件的大小。

- `printf()` 和 `sprintf()` 可能会调用 `malloc()`，如果使用的内存分配方案不是 heap\_3，则可能无效。更多信息请参见第 3.2 节“示例内存分配方案”。

- `printf()` 和 `sprintf()` 可能需要的堆栈大小是正常情况下的许多倍。


### 13.4.1 Printf-stdarg.c

许多FreeRTOS演示项目使用了一个名为`printf-stdarg.c`的文件，该文件提供了一个最小化且栈效率高的`sprintf()`实现，可以替代标准库版本。在大多数情况下，这将允许为调用`sprintf()`及相关函数的每个任务分配更小的栈空间。

`printf-stdarg.c`还提供了一种机制，可以将`printf()`输出逐字符定向到端口，虽然速度较慢，但能进一步减少栈的使用。

需要注意的是，并非所有FreeRTOS下载中包含的`printf-stdarg.c`副本都实现了`snprintf()`。未实现`snprintf()`的副本会直接映射到`sprintf()`，因此会忽略缓冲区大小参数。

`printf-stdarg.c`是开源的，但由第三方所有，因此其许可与FreeRTOS分开。许可条款包含在源文件的顶部。

## 13.5 其他常见错误来源

### 13.5.1 现象：向演示项目中添加一个简单任务导致程序崩溃

创建任务需要从堆中分配内存。许多演示应用项目将堆的大小精确设置为仅够创建演示任务——因此，在任务创建后，将没有足够的堆空间用于添加更多的任务、队列、事件组或信号量。

空闲任务以及可能的RTOS守护任务会在调用`vTaskStartScheduler()`时自动创建。只有在没有足够堆内存供这些任务创建时，`vTaskStartScheduler()`才会返回。在调用`vTaskStartScheduler()`后包含一个空循环`[ for(;;); ]`可以使此错误更易于调试。

为了能够添加更多任务，你必须增加堆大小，或者移除一些现有的演示任务。堆大小的增加始终受限于可用RAM的大小。更多信息请参见第3.2节“示例内存分配方案”。


### 13.5.2 症状：在中断中使用 API 函数导致应用程序崩溃

不要在中断服务例程中使用 API 函数，除非该 API 函数的名称以 `...FromISR()` 结尾。特别是，除非使用中断安全的宏，否则不要在中断中创建临界区。更多信息，请参阅第 7.2 节《在 ISR 中使用 FreeRTOS API》。

在支持中断嵌套的 FreeRTOS 移植版本中，不要在优先级高于 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 的中断中使用任何 API 函数。更多信息，请参阅第 7.8 节《中断嵌套》。

### 13.5.3 症状：应用程序有时在中断服务例程中崩溃

首先需要检查的是中断是否导致栈溢出。某些移植版本只检查任务中的栈溢出，而不检查中断中的栈溢出。

中断的定义和使用方式因移植版本和编译器的不同而有所差异。因此，第二件需要检查的事情是确保中断服务例程中使用的语法、宏和调用约定与所用移植版本的文档页面描述完全一致，并且与移植版本提供的演示应用程序中的示例完全一致。

如果应用程序运行在使用低数值优先级表示高逻辑优先级的处理器上，请确保为每个中断分配的优先级考虑到了这一点，因为这可能会违反直觉。如果应用程序运行在将每个中断的优先级默认设置为最大可能优先级的处理器上，请确保每个中断的优先级没有保持默认值。更多信息，请参阅第 7.8 节《中断嵌套》和第 13.2 节《中断优先级》。


### 13.5.4 现象：调度器在尝试启动第一个任务时崩溃

确保已安装 FreeRTOS 的中断处理程序。请参考所使用的 FreeRTOS 移植版本的文档页面以获取相关信息，并参考移植版本提供的示例应用程序。

某些处理器在调度器启动之前必须处于特权模式。最简单的方法是在 C 启动代码中将处理器置入特权模式，即在 `main()` 函数被调用之前完成此操作。

### 13.5.5 现象：中断意外地保持禁用状态，或临界区嵌套不正确

如果在调度器启动之前调用了 FreeRTOS API 函数，那么中断将有意保持禁用状态，并且在第一个任务开始执行之前不会重新启用。这样做是为了防止在系统初始化期间、调度器启动之前以及调度器可能处于不一致状态时，尝试使用 FreeRTOS API 函数的中断导致系统崩溃。

不要使用除 `taskENTER_CRITICAL()` 和 `taskEXIT_CRITICAL()` 之外的任何方法来修改微控制器中断使能位或优先级标志。这些宏会记录它们的调用嵌套深度，以确保只有在调用嵌套完全恢复到零时才会重新启用中断。请注意，某些库函数本身可能会启用和禁用中断。


### 13.5.6 症状：应用程序在调度器启动之前就崩溃了

在调度器启动之前，不得允许可能导致上下文切换的中断服务例程执行。同样，任何尝试发送或接收 FreeRTOS 对象（如队列或信号量）的中断服务例程也不得在调度器启动之前执行。上下文切换只能在调度器启动之后发生。

许多 API 函数在调度器启动之前不能调用。最好将 API 的使用限制在创建任务、队列和信号量等对象上，而不是在调用 `vTaskStartScheduler()` 之前使用这些对象。

### 13.5.7 症状：在调度器挂起时或在临界区内调用 API 函数导致应用程序崩溃

调度器通过调用 `vTaskSuspendAll()` 挂起，并通过调用 `xTaskResumeAll()` 恢复（取消挂起）。临界区通过调用 `taskENTER_CRITICAL()` 进入，并通过调用 `taskEXIT_CRITICAL()` 退出。

不要在调度器挂起时或在临界区内调用 API 函数。

## 13.6 额外的调试步骤

如果你遇到上述常见原因未涵盖的问题，可以尝试以下一些调试步骤。

- 在应用程序的 FreeRTOSConfig 文件中定义 `configASSERT()`，启用 malloc 失败检查和堆栈溢出检查。
- 检查 FreeRTOS API 的返回值，确保这些调用成功。
- 检查与调度器相关的配置，如 `configUSE_TIME_SLICING` 和 `configUSE_PREEMPTION`，确保它们根据应用程序需求正确设置。
- [此页面](https://www.freertos.org/Debugging-Hard-Faults-On-Cortex-M-Microcontrollers.html) 提供了关于调试 Cortex-M 微控制器上硬故障的详细信息。

