# 6 软件定时器管理

## 6.1 章节介绍与范围

软件定时器用于在设定的未来时间或按固定频率定期执行某个函数。由软件定时器执行的函数称为软件定时器的回调函数。

软件定时器由 FreeRTOS 内核实现并控制。它们不需要硬件支持，与硬件定时器或硬件计数器无关。

需要注意的是，遵循 FreeRTOS 的创新设计理念以确保最高效率，软件定时器在未实际执行回调函数时不会占用任何处理时间。

软件定时器功能是可选的。要包含软件定时器功能，需执行以下步骤：

1. 将 FreeRTOS 源文件 FreeRTOS/Source/timers.c 作为项目的一部分进行构建。

2. 在应用程序的 FreeRTOSConfig.h 头文件中定义以下常量：

- `configUSE_TIMERS`

  在 FreeRTOSConfig.h 中将 `configUSE_TIMERS` 设置为 1。

- `configTIMER_TASK_PRIORITY`

  设置定时器服务任务的优先级，范围为 0 到 (`configMAX_PRIORITIES` - 1)。

- `configTIMER_QUEUE_LENGTH`

  设置定时器命令队列在任何时刻可以容纳的未处理命令的最大数量。

- `configTIMER_TASK_STACK_DEPTH`

  设置分配给定时器服务任务的栈大小（以字为单位，而非字节）。

### 6.1.1 范围

本章内容包括：

- 软件定时器与任务特性的比较。
- RTOS守护任务。
- 定时器命令队列。
- 一次性软件定时器与周期性软件定时器的区别。
- 如何创建、启动、重置和更改软件定时器的周期。

## 6.2 软件定时器回调函数

软件定时器回调函数以C函数的形式实现。它们的唯一特殊之处在于其原型，必须返回`void`，并且以软件定时器的句柄作为唯一参数。回调函数的原型如[清单6.1](#list)所示。

<a name="list" title="清单6.1 软件定时器回调函数原型"></a>

```c
void ATimerCallback( TimerHandle_t xTimer );
```
***清单6.1*** *软件定时器回调函数原型*

软件定时器回调函数从头到尾执行，并以正常方式退出。它们应保持简短，并且不得进入阻塞状态。

> *注意：正如将看到的，软件定时器回调函数在FreeRTOS调度器启动时自动创建的任务上下文中执行。因此，软件定时器回调函数绝不能调用会导致调用任务进入阻塞状态的FreeRTOS API函数。可以调用诸如`xQueueReceive()`之类的函数，但前提是函数的`xTicksToWait`参数（指定函数的阻塞时间）设置为0。不得调用诸如`vTaskDelay()`之类的函数，因为调用`vTaskDelay()`将始终使调用任务进入阻塞状态。*


## 6.3 软件定时器的属性和状态

### 6.3.1 软件定时器的周期

软件定时器的“周期”是指从软件定时器启动到其回调函数执行之间的时间间隔。

### 6.3.2 单次定时器和自动重载定时器

软件定时器有两种类型：

1. 单次定时器

   单次定时器启动后，其回调函数仅执行一次。单次定时器可以手动重新启动，但不会自动重启。

2. 自动重载定时器

   自动重载定时器启动后，每次到期时都会自动重新启动，从而实现其回调函数的周期性执行。

图6.1展示了单次定时器和自动重载定时器在行为上的差异。虚线垂直线表示定时器中断发生的时间。

<a name="fig6.1" title="Figure 6.1 单次定时器和自动重载软件定时器的行为差异"></a>

* * *
![](media/image38.png)
***图6.1*** *单次定时器和自动重载软件定时器的行为差异*
* * *

参考图6.1：

- 定时器1

  定时器1是一个周期为6个滴答的单次定时器。它在时间t1启动，因此其回调函数在6个滴答后的时间t7执行。由于定时器1是单次定时器，其回调函数不会再次执行。

- 定时器2

  定时器2是一个周期为5个滴答的自动重载定时器。它在时间t1启动，因此其回调函数在时间t1之后的每5个滴答执行一次。在图6.1中，这分别发生在时间t6、t11和t16。


### 6.3.3 软件定时器状态

软件定时器可以处于以下两种状态之一：

- **休眠状态**

  休眠状态的软件定时器存在，可以通过其句柄引用，但它并未运行，因此其回调函数不会执行。

- **运行状态**

  运行状态的软件定时器将在其进入运行状态或最后一次重置后经过与其周期相等的时间后执行其回调函数。

图 6.2 和图 6.3 分别展示了自动重载定时器和一次性定时器在休眠状态和运行状态之间可能的转换。两张图的关键区别在于定时器到期后进入的状态：自动重载定时器执行其回调函数后重新进入运行状态，而一次性定时器执行其回调函数后进入休眠状态。

<a name="fig6.2" title="Figure 6.2 Auto-reload software timer states and transitions"></a>
<a name="fig6.3" title="Figure 6.3 One-shot software timer states and transitions"></a>

* * *
![](media/image39.png)
***图 6.2*** *自动重载软件定时器的状态与转换*

![](media/image40.png)
***图 6.3*** *一次性软件定时器的状态与转换*
* * *

`xTimerDelete()` API 函数用于删除定时器。定时器可以在任何时候被删除。函数原型如清单 6.2 所示。

<a name="list6.2" title="Listing 6.2 The xTimerDelete() API function prototype"></a>

```c
BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xTicksToWait );
```
***清单 6.2*** *xTimerDelete() API 函数原型*


**xTimerDelete() 参数与返回值**

- `xTimer`

  要删除的定时器的句柄。

- `xTicksToWait`

  指定调用任务在阻塞状态下等待删除命令成功发送到定时器命令队列的时间（以 tick 为单位），该参数在调用 `xTimerDelete()` 时如果队列已满的情况下生效。如果 `xTimerDelete()` 在调度器启动之前被调用，则 `xTicksToWait` 将被忽略。

- 返回值

  有两种可能的返回值：

  - `pdPASS`

    如果命令成功发送到定时器命令队列，则返回 `pdPASS`。

  - `pdFAIL`

    如果即使在 `xBlockTime` tick 之后仍无法将删除命令发送到定时器命令队列，则返回 `pdFAIL`。


## 6.4 软件定时器的上下文

### 6.4.1 RTOS守护进程（定时器服务）任务

所有软件定时器回调函数都在同一个RTOS守护进程（或称“定时器服务”）任务[^10]的上下文中执行。

[^10]: 该任务过去被称为“定时器服务任务”，因为最初它仅用于执行软件定时器回调函数。现在，该任务也用于其他用途，因此它被更通用的名称“RTOS守护进程任务”所取代。

守护进程任务是一个标准的FreeRTOS任务，在调度器启动时自动创建。其优先级和堆栈大小分别由`configTIMER_TASK_PRIORITY`和`configTIMER_TASK_STACK_DEPTH`这两个编译时配置常量设置。这两个常量均在FreeRTOSConfig.h文件中定义。

软件定时器回调函数不得调用会导致调用任务进入阻塞状态的FreeRTOS API函数，因为这样做会导致守护进程任务进入阻塞状态。

### 6.4.2 定时器命令队列

软件定时器API函数通过一个名为“定时器命令队列”的队列，将命令从调用任务发送到守护进程任务。如图6.4所示。命令的示例包括“启动定时器”、“停止定时器”和“重置定时器”。

定时器命令队列是一个标准的FreeRTOS队列，在调度器启动时自动创建。定时器命令队列的长度由FreeRTOSConfig.h文件中的`configTIMER_QUEUE_LENGTH`编译时配置常量设置。

<a name="fig6.4" title="图6.4 软件定时器API函数使用定时器命令队列与RTOS守护进程任务通信"></a>

* * *
![](media/image41.png)
***图6.4*** *软件定时器API函数使用定时器命令队列与RTOS守护进程任务通信*
* * *


### 6.4.3 守护任务调度

守护任务与任何其他FreeRTOS任务一样被调度；只有当它是能够运行的最高优先级任务时，它才会处理命令或执行定时器回调函数。图6.5和图6.6展示了`configTIMER_TASK_PRIORITY`设置如何影响执行模式。

图6.5展示了当守护任务的优先级低于调用`xTimerStart()` API函数的任务的优先级时的执行模式。

<a name="fig6.5" title="图6.5 当调用xTimerStart()的任务优先级高于守护任务优先级时的执行模式"></a>

* * *
![](media/image42.png)
***图6.5*** *当调用xTimerStart()的任务优先级高于守护任务优先级时的执行模式*
* * *

参考图6.5，其中任务1的优先级高于守护任务的优先级，且守护任务的优先级高于空闲任务的优先级：

1. 在时间t1

   任务1处于运行状态，守护任务处于阻塞状态。

如果向定时器命令队列发送了命令，守护任务将离开阻塞状态，此时它将处理该命令；或者如果软件定时器到期，此时它将执行软件定时器的回调函数。

1. 在时间 t2

   任务1调用 `xTimerStart()`。

   `xTimerStart()` 向定时器命令队列发送命令，导致守护任务离开阻塞状态。任务1的优先级高于守护任务的优先级，因此守护任务不会抢占任务1。

   任务1仍处于运行状态，而守护任务已离开阻塞状态并进入就绪状态。

1. 在时间 t3

   任务1完成执行 `xTimerStart()` API 函数。任务1从函数开始到函数结束执行了 `xTimerStart()`，期间一直处于运行状态，未离开运行状态。

1. 在时间 t4

   任务1调用了一个导致其进入阻塞状态的 API 函数。此时，守护任务成为就绪状态中优先级最高的任务，因此调度器选择守护任务进入运行状态。随后，守护任务开始处理由任务1发送到定时器命令队列的命令。

> *注意：软件定时器的到期时间是从'启动定时器'命令发送到定时器命令队列的时间开始计算的——而不是从守护任务从定时器命令队列接收到'启动定时器'命令的时间开始计算的。*

1. 在时间 t5

   守护任务已经完成了对由任务1发送给它的命令的处理，并尝试从定时器命令队列接收更多数据。定时器命令队列为空，因此守护任务重新进入阻塞状态。如果向定时器命令队列发送了命令，或者某个软件定时器到期，守护任务将再次离开阻塞状态。

   空闲任务现在是就绪态中优先级最高的任务，因此调度器选择空闲任务作为进入运行态的任务。

图6.6展示了一个与图6.5所示类似的场景，但这次守护任务的优先级高于调用`xTimerStart()`的任务的优先级。

<a name="fig6.6" title="图 6.6 调用xTimerStart()的任务优先级低于守护任务优先级时的执行模式"></a>

* * *
![](media/image43.png)
***图 6.6*** *调用xTimerStart()的任务优先级低于守护任务优先级时的执行模式*
* * *

参考图 6.6，其中守护任务的优先级高于任务1的优先级，而任务1的优先级又高于空闲任务的优先级：

1. 在时间 t1

   如前所述，任务1处于运行状态，而守护任务处于阻塞状态。

1. 在时间 t2

   任务1调用 `xTimerStart()`。

   `xTimerStart()` 向定时器命令队列发送命令，导致守护任务离开阻塞状态。由于守护任务的优先级高于任务1的优先级，调度器选择守护任务进入运行状态。

   任务1在完成 `xTimerStart()` 函数的执行之前被守护任务抢占，现在处于就绪状态。

守护任务开始处理由任务1发送到定时器命令队列的命令。

1. 在时间t3

   守护任务已完成处理由任务1发送的命令，并尝试从定时器命令队列接收更多数据。定时器命令队列为空，因此守护任务重新进入阻塞状态。

   任务1现在是就绪状态中优先级最高的任务，因此调度器选择任务1进入运行状态。

1. 在时间t4

   任务1在完成执行`xTimerStart()`函数之前被守护任务抢占，只有在重新进入运行状态后，任务1才退出（从）`xTimerStart()`函数。

1. 在时间t5

   任务1调用一个API函数，导致其进入阻塞状态。空闲任务现在是就绪状态中优先级最高的任务，因此调度器选择空闲任务进入运行状态。

在图6.5所示的场景中，任务1向定时器命令队列发送命令与守护任务接收并处理命令之间有一段时间间隔。而在图6.6所示的场景中，守护任务在任务1从发送命令的函数返回之前已接收并处理了由任务1发送的命令。

发送到定时器命令队列的命令包含一个时间戳。该时间戳用于记录从应用程序任务发送命令到守护任务处理同一命令之间经过的任何时间。例如，如果发送一个“启动定时器”命令来启动一个周期为10个节拍的定时器，时间戳用于确保定时器在命令发送后10个节拍到期，而不是在守护任务处理命令后10个节拍到期。

## 6.5 创建和启动软件定时器

### 6.5.1 xTimerCreate() API 函数

FreeRTOS 还包括 `xTimerCreateStatic()` 函数，它在编译时静态分配创建定时器所需的内存：软件定时器在使用前必须显式创建。

软件定时器由 `TimerHandle_t` 类型的变量引用。`xTimerCreate()` 用于创建软件定时器，并返回一个 `TimerHandle_t` 来引用它创建的软件定时器。软件定时器在创建时处于休眠状态。

软件定时器可以在调度器运行之前创建，也可以在调度器启动后从任务中创建。

[第2.5节：数据类型和编码风格指南](ch02.md#25-data-types-and-coding-style-guide) 描述了所使用的数据类型和命名约定。

<a name="list6.3" title="Listing 6.3 The xTimerCreate() API function prototype"></a>

```c
TimerHandle_t xTimerCreate( const char * const pcTimerName,
                            const TickType_t xTimerPeriodInTicks,
                            const BaseType_t xAutoReload,
                            void * const pvTimerID,
                            TimerCallbackFunction_t pxCallbackFunction );
```
***清单6.3*** *xTimerCreate() API 函数原型*

**xTimerCreate() 参数和返回值**

- `pcTimerName`

  定时器的描述性名称。FreeRTOS 不以任何方式使用此名称。它纯粹作为调试辅助工具包含在内。通过人类可读的名称来识别定时器比通过其句柄来识别要简单得多。

- `xTimerPeriodInTicks`

  以节拍为单位的定时器周期。可以使用 `pdMS_TO_TICKS()` 宏将以毫秒为单位的时间转换为以节拍为单位的时间。不能为0。

- `xAutoReload`

  将 `xAutoReload` 设置为 `pdTRUE` 以创建自动重载定时器。将 `xAutoReload` 设置为 `pdFALSE` 以创建一次性定时器。

- `pvTimerID`

  每个软件定时器都有一个ID值。ID是一个void指针，应用程序编写者可以将其用于任何目的。当多个软件定时器使用相同的回调函数时，ID特别有用，因为它可以提供定时器特定的存储。本章中的示例演示了定时器ID的使用。

  `pvTimerID` 为正在创建的定时器的ID设置初始值。

- `pxCallbackFunction`

  软件定时器回调函数是符合清单6.1中所示原型的C函数。`pxCallbackFunction` 参数是指向将用作正在创建的软件定时器的回调函数的函数指针（实际上就是函数名称）。

- 返回值

  如果返回NULL，则无法创建软件定时器，因为FreeRTOS没有足够的堆内存来分配必要的数据结构。

  如果返回非NULL值，则表示软件定时器已成功创建。返回的值是所创建定时器的句柄。

  第3章提供了关于堆内存管理的更多信息。


### 6.5.2 xTimerStart() API 函数

`xTimerStart()` 用于启动处于休眠状态的软件定时器，或重置（重新启动）处于运行状态的软件定时器。`xTimerStop()` 用于停止处于运行状态的软件定时器。停止软件定时器相当于将定时器转换为休眠状态。

`xTimerStart()` 可以在调度器启动之前调用，但这样做时，软件定时器只有在调度器启动时才会真正开始运行。

> *注意：切勿从中断服务例程中调用 `xTimerStart()`。在此情况下应使用中断安全版本 `xTimerStartFromISR()`。*

<a name="list6.4" title="Listing 6.4 The xTimerStart() API function prototype"></a>

```c
BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );
```
***代码清单 6.4*** *xTimerStart() API 函数原型*

**xTimerStart() 参数和返回值**

- `xTimer`

  要启动或重置的软件定时器的句柄。该句柄是通过调用 `xTimerCreate()` 创建软件定时器时返回的。

- `xTicksToWait`

  `xTimerStart()` 使用定时器命令队列向守护任务发送“启动定时器”命令。`xTicksToWait` 指定了调用任务在定时器命令队列已满的情况下，为等待队列空间可用而应保持在阻塞状态的最长时间。

  如果 `xTicksToWait` 为零且定时器命令队列已满，`xTimerStart()` 将立即返回。

  阻塞时间以时钟周期为单位指定，因此它所代表的绝对时间取决于时钟频率。可以使用宏 `pdMS_TO_TICKS()` 将以毫秒为单位的时间转换为以时钟周期为单位的时间。

  如果在 `FreeRTOSConfig.h` 中将 `INCLUDE_vTaskSuspend` 设置为 1，那么将 `xTicksToWait` 设置为 `portMAX_DELAY` 将导致调用任务无限期地保持在阻塞状态（无超时），以等待定时器命令队列中的空间可用。

  如果在调度器启动之前调用 `xTimerStart()`，则 `xTicksToWait` 的值将被忽略，并且 `xTimerStart()` 的行为就像 `xTicksToWait` 被设置为零一样。

- 返回值

  可能有两种返回值：

  - `pdPASS`

    仅当“启动定时器”命令成功发送到定时器命令队列时，才会返回`pdPASS`。

    如果守护任务的优先级高于调用`xTimerStart()`的任务的优先级，调度器将确保在`xTimerStart()`返回之前处理启动命令。这是因为一旦定时器命令队列中有数据，守护任务将抢占调用`xTimerStart()`的任务。

    如果指定了阻塞时间（`xTicksToWait`不为零），则调用任务可能会被置于阻塞状态，以等待定时器命令队列中出现可用空间，但如果在阻塞时间到期之前成功将数据写入定时器命令队列，函数仍会返回`pdPASS`。

  - `pdFAIL`

    如果由于定时器命令队列已满而无法写入“启动定时器”命令，则将返回`pdFAIL`。

如果指定了阻塞时间（`xTicksToWait` 不为零），则调用任务将被置于阻塞状态，等待守护任务在定时器命令队列中腾出空间，但在该情况发生之前，指定的阻塞时间已到期。

<a name="example6.1" title="示例 6.1 创建单次触发和自动重载定时器"></a>
---
***示例 6.1*** *创建单次触发和自动重载定时器*

---

本示例创建并启动了一个单次触发定时器和一个自动重载定时器，如清单 6.5 所示。

<a name="list6.5" title="清单 6.5 创建并启动示例 6.1 中使用的定时器"></a>

```c
/* 分配给单次触发定时器和自动重载定时器的周期分别为 3.333 秒和半秒。 */
#define mainONE_SHOT_TIMER_PERIOD pdMS_TO_TICKS( 3333 )
#define mainAUTO_RELOAD_TIMER_PERIOD pdMS_TO_TICKS( 500 )

int main( void )
{
    TimerHandle_t xAutoReloadTimer, xOneShotTimer;
    BaseType_t xTimer1Started, xTimer2Started;

    /* 创建单次触发定时器，并将创建的定时器句柄存储在 xOneShotTimer 中。 */
    xOneShotTimer = xTimerCreate(
        /* 软件定时器的文本名称 - FreeRTOS 不使用该名称。 */
                                  "OneShot",
        /* 软件定时器的周期（以 tick 为单位）。 */
                                   mainONE_SHOT_TIMER_PERIOD,
        /* 将 uxAutoRealod 设置为 pdFALSE 以创建一个单次触发软件定时器。 */
                                   pdFALSE,
        /* 本示例不使用定时器 ID。 */
                                   0,
        /* 用于创建软件定时器的回调函数。 */
                                   prvOneShotTimerCallback );

    /* 创建自动重载定时器，并将创建的定时器句柄存储在 xAutoReloadTimer 中。 */
    xAutoReloadTimer = xTimerCreate(
        /* 软件定时器的文本名称 - FreeRTOS 不使用该名称。 */
                                     "AutoReload",
        /* 软件定时器的周期（以 tick 为单位）。 */
                                     mainAUTO_RELOAD_TIMER_PERIOD,
        /* 将 uxAutoRealod 设置为 pdTRUE 以创建一个自动重载定时器。 */
                                     pdTRUE,
        /* 本示例不使用定时器 ID。 */
                                     0,
        /* 用于创建软件定时器的回调函数。 */
                                     prvAutoReloadTimerCallback );

    /* 检查软件定时器是否创建成功。 */
    if( ( xOneShotTimer != NULL ) && ( xAutoReloadTimer != NULL ) )
    {
        /* 启动软件定时器，阻塞时间设置为 0（无阻塞时间）。
           调度器尚未启动，因此此处指定的任何阻塞时间都会被忽略。 */
        xTimer1Started = xTimerStart( xOneShotTimer, 0 );
        xTimer2Started = xTimerStart( xAutoReloadTimer, 0 );

        /* xTimerStart() 的实现使用定时器命令队列，如果定时器命令队列已满，xTimerStart() 将失败。
           定时器服务任务在调度器启动后才会创建，因此发送到命令队列的所有命令将在调度器启动后才会处理。
           检查两次 xTimerStart() 调用是否成功。 */
        if( ( xTimer1Started == pdPASS ) && ( xTimer2Started == pdPASS ) )
        {
            /* 启动调度器。 */
            vTaskStartScheduler();
        }
    }

    /* 通常，不应执行到此处。 */
    for( ;; );
}
```
***清单 6.5*** *创建并启动示例 6.1 中使用的定时器*


定时器的回调函数在每次被调用时仅打印一条消息。单次触发定时器回调函数的实现如清单 6.6 所示，自动重载定时器回调函数的实现如清单 6.7 所示。

<a name="list6.5" title="Listing 6.6 示例6.1中单次定时器使用的回调函数"></a>

```c
static void prvOneShotTimerCallback( TimerHandle_t xTimer )
{
    TickType_t xTimeNow;

    /* 获取当前的tick计数。 */
    xTimeNow = xTaskGetTickCount();

    /* 输出字符串以显示回调函数执行的时间。 */
    vPrintStringAndNumber( "单次定时器回调函数执行", xTimeNow );

    /* 文件作用域变量。 */
    ulCallCount++;
}
```
***列表6.6*** *示例6.1中单次定时器使用的回调函数*


<a name="list6.7" title="Listing 6.7 示例6.1中自动重载定时器使用的回调函数"></a>

```c
static void prvAutoReloadTimerCallback( TimerHandle_t xTimer )
{
    TickType_t xTimeNow;

    /* 获取当前的tick计数。 */
    xTimeNow = xTaskGetTickCount();

    /* 输出字符串以显示回调函数执行的时间。 */
    vPrintStringAndNumber( "自动重载定时器回调函数执行", xTimeNow);

    ulCallCount++;
}
```
***列表6.7*** *示例6.1中自动重载定时器使用的回调函数*

执行此示例将生成如图6.7所示的输出。图6.7显示了自动重载定时器的回调函数以固定的500个tick周期执行（`mainAUTO_RELOAD_TIMER_PERIOD`在列表6.5中设置为500），而单次定时器的回调函数仅在tick计数为3333时执行一次（`mainONE_SHOT_TIMER_PERIOD`在列表6.5中设置为3333）。

<a name="fig6.7" title="Figure 6.7 执行示例6.1时产生的输出"></a>

* * *
![](media/image44.jpg)
***图6.7*** *执行示例6.1时产生的输出*
* * *



## 6.6 定时器ID

每个软件定时器都有一个ID，这是一个标签值，应用程序编写者可以将其用于任何目的。ID存储在一个空指针（`void *`）中，因此它可以直接存储整数值、指向任何其他对象，或者用作函数指针。

在创建软件定时器时，会为ID分配一个初始值，之后可以使用`vTimerSetTimerID()` API函数更新ID，并使用`pvTimerGetTimerID()` API函数查询ID。

与其他软件定时器API函数不同，`vTimerSetTimerID()`和`pvTimerGetTimerID()`直接访问软件定时器——它们不会向定时器命令队列发送命令。


### 6.6.1 vTimerSetTimerID() API函数


<a name="list6.8" title="代码清单6.8 vTimerSetTimerID() API函数原型"></a>

```c
void vTimerSetTimerID( const TimerHandle_t xTimer, void *pvNewID );
```
***代码清单6.8*** *vTimerSetTimerID() API函数原型*


**vTimerSetTimerID() 参数**

- `xTimer`

  正在更新新ID值的软件定时器的句柄。该句柄是从用于创建软件定时器的`xTimerCreate()`调用中返回的。

- `pvNewID`

  软件定时器ID将被设置的值。


### 6.6.2 pvTimerGetTimerID() API 函数

<a name="list6.9" title="Listing 6.9 The pvTimerGetTimerID() API function prototype"></a>

```c
void *pvTimerGetTimerID( const TimerHandle_t xTimer );
```
***清单 6.9*** *pvTimerGetTimerID() API 函数原型*

**pvTimerGetTimerID() 参数和返回值**

- `xTimer`

  被查询的软件定时器的句柄。该句柄由用于创建软件定时器的 `xTimerCreate()` 调用返回。

- 返回值

  被查询的软件定时器的 ID。

<a name="example6.2" title="Example 6.2 Using the callback function parameter and the software timer ID"></a>
---
***示例 6.2*** *使用回调函数参数和软件定时器 ID*

---

同一个回调函数可以分配给多个软件定时器。在这种情况下，回调函数参数用于确定是哪个软件定时器触发了超时。

示例 6.1 使用了两个独立的回调函数：一个用于一次性定时器，另一个用于自动重载定时器。示例 6.2 实现了与示例 6.1 类似的功能，但为两个软件定时器分配了同一个回调函数。

示例6.2中使用的`main()`函数与示例6.1中使用的`main()`函数几乎完全相同。唯一的区别在于软件定时器的创建位置。这一区别如代码清单6.10所示，其中`prvTimerCallback()`被用作两个定时器的回调函数。

<a name="list6.10" title="代码清单6.10 创建示例6.2中使用的定时器"></a>

```c
/* 创建单次定时器软件定时器，并将句柄存储在xOneShotTimer中。 */
xOneShotTimer = xTimerCreate( "OneShot",
                              mainONE_SHOT_TIMER_PERIOD,
                              pdFALSE,
                              /* 定时器的ID初始化为NULL。 */
                              NULL,
                              /* prvTimerCallback()被两个定时器使用。 */
                              prvTimerCallback );

/* 创建自动重载软件定时器，并将句柄存储在xAutoReloadTimer中。 */
xAutoReloadTimer = xTimerCreate( "AutoReload",
                                 mainAUTO_RELOAD_TIMER_PERIOD,
                                 pdTRUE,
                                 /* 定时器的ID初始化为NULL。 */
                                 NULL,
                                 /* prvTimerCallback()被两个定时器使用。 */
                                 prvTimerCallback );
```
***代码清单6.10*** *创建示例6.2中使用的定时器*

`prvTimerCallback()`将在任一定时器到期时执行。`prvTimerCallback()`的实现使用函数的参数来确定它是由于单次定时器到期还是自动重载定时器到期而被调用。

`prvTimerCallback()` 还展示了如何使用软件定时器ID作为定时器特定的存储；每个软件定时器在其ID中保存了它已过期的次数，自动重载定时器使用该计数在第五次执行时停止自身。

`prvTimerCallback()` 的实现如清单6.9所示。

<a name="list6.11" title="清单6.11 示例6.2中使用的定时器回调函数"></a>

```c
static void prvTimerCallback( TimerHandle_t xTimer )
{
    TickType_t xTimeNow;
    uint32_t ulExecutionCount;

    /* 该软件定时器已过期的次数存储在其ID中。获取ID，递增它，然后将其保存为
       新的ID值。ID是一个void指针，因此将其转换为uint32_t。 */
    ulExecutionCount = ( uint32_t ) pvTimerGetTimerID( xTimer );
    ulExecutionCount++;
    vTimerSetTimerID( xTimer, ( void * ) ulExecutionCount );

    /* 获取当前的tick计数。 */
    xTimeNow = xTaskGetTickCount();

    /* 一次性定时器的句柄在创建定时器时存储在xOneShotTimer中。将传入此函数的句柄与
       xOneShotTimer进行比较，以确定是哪个定时器过期，然后输出一个字符串以显示
       回调执行的时间。 */
    if( xTimer == xOneShotTimer )
    {
        vPrintStringAndNumber( "一次性定时器回调执行", xTimeNow );
    }
    else
    {
        /* xTimer不等于xOneShotTimer，因此它一定是自动重载定时器过期了。 */
        vPrintStringAndNumber( "自动重载定时器回调执行", xTimeNow);

        if( ulExecutionCount == 5 )
        {
            /* 在自动重载定时器执行5次后停止它。此回调函数在RTOS守护任务的上下文中
               执行，因此不能调用任何可能导致守护任务进入阻塞状态的函数。因此使用了
               0的阻塞时间。 */
            xTimerStop( xTimer, 0 );
        }
    }
}
```
***清单6.11*** *示例6.2中使用的定时器回调函数*


示例6.2的输出如图6.8所示。可以看到自动重载定时器只执行了五次。

<a name="fig6.8" title="图6.8 执行示例6.2时产生的输出"></a>

* * *
![](media/image45.jpg)
***图6.8*** *执行示例6.2时产生的输出*
* * *

## 6.7 修改定时器周期

每个官方的FreeRTOS移植版本都提供了一个或多个示例项目。大多数示例项目都是自检的，并且使用LED来提供项目状态的视觉反馈；如果自检始终通过，则LED缓慢切换，如果自检曾经失败，则LED快速切换。

一些示例项目在任务中执行自检，并使用`vTaskDelay()`函数来控制LED切换的速率。其他示例项目在软件定时器回调函数中执行自检，并使用定时器的周期来控制LED切换的速率。

### 6.7.1 xTimerChangePeriod() API函数

使用`xTimerChangePeriod()`函数来更改软件定时器的周期。

如果使用`xTimerChangePeriod()`更改正在运行的定时器的周期，则定时器将使用新的周期值重新计算其到期时间。重新计算的到期时间是相对于调用`xTimerChangePeriod()`的时间，而不是相对于定时器最初启动的时间。

如果使用`xTimerChangePeriod()`来更改处于休眠状态（未运行）的定时器的周期，那么该定时器将计算一个到期时间，并转换到运行状态（定时器将开始运行）。

> *注意：永远不要从中断服务例程中调用`xTimerChangePeriod()`。应使用其中断安全版本`xTimerChangePeriodFromISR()`来代替。*

<a name="list6.12" title="Listing 6.12 The xTimerChangePeriod() API function prototype"></a>

```c
BaseType_t xTimerChangePeriod( TimerHandle_t xTimer,
                               TickType_t xNewPeriod,
                               TickType_t xTicksToWait );
```
***代码清单 6.12*** *xTimerChangePeriod() API 函数原型*

**xTimerChangePeriod() 参数和返回值**

- `xTimer`

  正在更新新周期值的软件定时器的句柄。该句柄由用于创建软件定时器的`xTimerCreate()`调用返回。

- `xTimerPeriodInTicks`

  软件定时器的新周期，以tick为单位指定。可以使用`pdMS_TO_TICKS()`宏将以毫秒为单位的时间转换为以tick为单位的时间。

- `xTicksToWait`

  `xTimerChangePeriod()`使用定时器命令队列向守护任务发送“更改周期”命令。`xTicksToWait`指定调用任务在定时器命令队列已满的情况下，应保持在阻塞状态以等待队列空间可用的最大时间。

  如果`xTicksToWait`为零且定时器命令队列已满，`xTimerChangePeriod()`将立即返回。

  可以使用`pdMS_TO_TICKS()`宏将以毫秒为单位的时间转换为以tick为单位的时间。

  如果在FreeRTOSConfig.h中将`INCLUDE_vTaskSuspend`设置为1，则将`xTicksToWait`设置为`portMAX_DELAY`将导致调用任务无限期地保持在阻塞状态（无超时），以等待定时器命令队列中的空间可用。

如果 `xTimerChangePeriod()` 在调度器启动之前被调用，那么 `xTicksToWait` 的值将被忽略，并且 `xTimerChangePeriod()` 的行为会如同 `xTicksToWait` 被设置为零一样。

- 返回值

  可能有两种返回值：

  - `pdPASS`

    只有当数据成功发送到定时器命令队列时，`pdPASS` 才会被返回。

    如果指定了阻塞时间（`xTicksToWait` 不为零），那么在函数返回之前，调用任务可能会被置于阻塞状态以等待定时器命令队列中有可用空间，但数据在阻塞时间到期之前成功写入了定时器命令队列。

  - `pdFAIL`

    如果由于队列已满而无法将“更改周期”命令写入定时器命令队列，`pdFAIL` 将被返回。

    如果指定了阻塞时间（`xTicksToWait` 不为零），那么调用任务将被置于阻塞状态以等待守护任务在队列中腾出空间，但在该情况发生之前，指定的阻塞时间已到期。

列表6.13展示了FreeRTOS示例中如何在软件定时器回调函数中使用自检功能，并通过`xTimerChangePeriod()`在自检失败时增加LED的切换频率。执行自检的软件定时器被称为“检查定时器”。

<a name="list6.13" title="列表6.13 使用xTimerChangePeriod()"></a>

```c
/* 检查定时器的初始周期为3000毫秒，导致LED每3秒切换一次。
   如果自检功能检测到意外状态，则将检查定时器的周期更改为200毫秒，
   从而使LED的切换频率大幅提高。 */
const TickType_t xHealthyTimerPeriod = pdMS_TO_TICKS( 3000 );
const TickType_t xErrorTimerPeriod = pdMS_TO_TICKS( 200 );

/* 检查定时器使用的回调函数。 */
static void prvCheckTimerCallbackFunction( TimerHandle_t xTimer )
{
    static BaseType_t xErrorDetected = pdFALSE;

    if( xErrorDetected == pdFALSE )
    {
        /* 尚未检测到错误。再次运行自检功能。
           该函数要求示例中创建的每个任务报告其状态，
           并检查所有任务是否仍在运行（从而能够正确报告其状态）。 */
        if( CheckTasksAreRunningWithoutError() == pdFAIL )
        {
            /* 一个或多个任务报告了意外状态。可能发生了错误。
               减少检查定时器的周期以提高此回调函数的执行频率，
               从而也提高LED的切换频率。此回调函数在RTOS守护任务的上下文中执行，
               因此使用阻塞时间为0，以确保守护任务不会进入阻塞状态。 */
            xTimerChangePeriod(
                  xTimer,            /* 正在更新的定时器 */
                  xErrorTimerPeriod, /* 定时器的新周期 */
                  0 );               /* 发送此命令时不阻塞 */

            /* 标记已检测到错误。 */
            xErrorDetected = pdTRUE;
        }
    }

    /* 切换LED。LED的切换频率取决于此函数的调用频率，
       而调用频率由检查定时器的周期决定。如果CheckTasksAreRunningWithoutError()
       曾经返回pdFAIL，定时器的周期将从3000毫秒减少到200毫秒。 */
    ToggleLED();
}
```
***列表6.13*** *使用xTimerChangePeriod()*


## 6.8 复位软件定时器

复位软件定时器意味着重新启动定时器；定时器的到期时间会根据定时器复位的时间重新计算，而不是根据定时器最初启动的时间。这一点在图6.9中得到了展示，图中显示了一个周期为6的定时器被启动，随后复位了两次，最终到期并执行其回调函数。

<a name="fig6.9" title="图6.9 启动并复位一个周期为6个滴答的软件定时器"></a>

* * *
![](media/image46.png)
***图6.9*** *启动并复位一个周期为6个滴答的软件定时器*
* * *

参考图6.9：

- 定时器1在时间t1启动。它的周期为6，因此最初计算其回调函数的执行时间为t7，即启动后6个滴答。

- 定时器1在达到时间t7之前被复位，即在其到期并执行回调函数之前。定时器1在时间t5被复位，因此其回调函数的执行时间重新计算为t11，即复位后6个滴答。

- 定时器1在达到时间t11之前再次被复位，即在其到期并执行回调函数之前。定时器1在时间t9被复位，因此其回调函数的执行时间重新计算为t15，即最后一次复位后6个滴答。

- 定时器1没有再次被复位，因此它在时间t15到期，并相应地执行其回调函数。


### 6.8.1 xTimerReset() API 函数

定时器可以通过 `xTimerReset()` API 函数进行重置。

`xTimerReset()` 也可用于启动处于休眠状态的定时器。

> *注意：切勿从中断服务例程中调用 `xTimerReset()`。应使用其替代版本 `xTimerResetFromISR()`。*

<a name="list6.14" title="Listing 6.14 The xTimerReset() API function prototype"></a>

```c
BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );
```
***代码清单 6.14*** *xTimerReset() API 函数原型*

**xTimerReset() 参数和返回值**

- `xTimer`

  要重置或启动的软件定时器的句柄。该句柄由创建软件定时器时调用的 `xTimerCreate()` 返回。

- `xTicksToWait`

  `xTimerReset()` 使用定时器命令队列向守护任务发送“重置”命令。如果队列已满，`xTicksToWait` 指定调用任务在阻塞状态下等待定时器命令队列空间变为可用的最长时间。

`xTimerReset()` 会在 `xTicksToWait` 为零且定时器命令队列已满时立即返回。

如果 `FreeRTOSConfig.h` 中的 `INCLUDE_vTaskSuspend` 设置为 1，那么将 `xTicksToWait` 设置为 `portMAX_DELAY` 会导致调用任务无限期地保持在阻塞状态（无超时），以等待定时器命令队列中有可用空间。

- 返回值

  有两种可能的返回值：

  - `pdPASS`

    仅当数据成功发送到定时器命令队列时，才会返回 `pdPASS`。

    如果指定了阻塞时间（`xTicksToWait` 不为零），则调用任务可能会在函数返回前被置于阻塞状态，以等待定时器命令队列中有可用空间，但数据在阻塞时间到期前成功写入定时器命令队列。

  - `pdFAIL`

    如果由于队列已满而无法将“重置”命令写入定时器命令队列，则会返回 `pdFAIL`。

如果指定了阻塞时间（`xTicksToWait`不为零），那么调用任务将被置于阻塞状态，以等待守护任务在队列中腾出空间，但在这种情况发生之前，指定的阻塞时间已过期。

<a name="example6.3" title="示例 6.3 重置软件定时器"></a>
---
***示例 6.3*** *重置软件定时器*

---

本示例模拟了手机背光的行为。背光：

- 在按下按键时打开。

- 只要在一定时间内再次按下按键，背光将保持打开状态。

- 如果在特定时间内没有按下按键，背光将自动关闭。

使用一次性软件定时器来实现此行为：

- 当按下按键时，[模拟的]背光被打开，并在软件定时器的回调函数中关闭。

- 每次按下按键时，软件定时器都会被重置。

- 因此，为防止背光关闭而必须按下按键的时间段等于软件定时器的周期；如果定时器到期之前没有因按键按下而重置定时器，则定时器的回调函数将执行，背光将被关闭。

`xSimulatedBacklightOn` 变量用于保存背光状态。  
`xSimulatedBacklightOn` 设置为 `pdTRUE` 表示背光开启，  
设置为 `pdFALSE` 表示背光关闭。

软件定时器回调函数如代码清单 6.15 所示。


<a name="list6.15" title="代码清单 6.15 示例 6.3 中使用的单次定时器回调函数"></a>

```c
static void prvBacklightTimerCallback( TimerHandle_t xTimer )
{
    TickType_t xTimeNow = xTaskGetTickCount();

    /* 背光定时器到期，关闭背光。 */
    xSimulatedBacklightOn = pdFALSE;

    /* 打印背光关闭的时间。 */
    vPrintStringAndNumber(
            "定时器到期，关闭背光的时间\t\t", xTimeNow );
}
```
***代码清单 6.15*** *示例 6.3 中使用的单次定时器回调函数*


示例 6.3 创建了一个任务来轮询键盘[^11]。该任务如代码清单 6.16 所示，但由于下一段所述的原因，  
代码清单 6.16 并不代表一种最优的设计。

[^11]: 在Windows控制台上打印或读取按键都会导致Windows系统调用的执行。Windows系统调用，包括使用Windows控制台、磁盘或TCP/IP栈，可能会对FreeRTOS Windows移植版的行为产生不利影响，通常应避免使用。

使用FreeRTOS可以让你的应用程序成为事件驱动的。事件驱动设计非常高效地利用处理时间，因为只有在事件发生时才会使用处理时间，而不会浪费处理时间去轮询未发生的事件。示例6.3无法实现事件驱动，因为在FreeRTOS Windows移植版中处理键盘中断并不实际，因此不得不使用效率较低的轮询技术。如果代码清单6.16是一个中断服务程序，那么应该使用`xTimerResetFromISR()`代替`xTimerReset()`。


<a name="list6.16" title="代码清单6.16 用于重置示例6.3中软件定时器的任务"></a>

```c
static void vKeyHitTask( void *pvParameters )
{
    const TickType_t xShortDelay = pdMS_TO_TICKS( 50 );
    TickType_t xTimeNow;

    vPrintString( "按下按键以打开背光。\r\n" );

    /* 理想情况下，应用程序应该是事件驱动的，并使用中断来处理按键。在FreeRTOS Windows移植版中使用键盘中断并不实际，因此该任务用于轮询按键。 */
    for( ;; )
    {
        /* 是否有按键被按下？ */
        if( _kbhit() != 0 )
        {
            /* 按键被按下。记录时间。 */
            xTimeNow = xTaskGetTickCount();

            if( xSimulatedBacklightOn == pdFALSE )
            {

                /* 背光已关闭，因此将其打开并打印打开时间。 */
                xSimulatedBacklightOn = pdTRUE;
                vPrintStringAndNumber(
                    "按键按下，打开背光，时间\t\t",
                    xTimeNow );
            }
            else
            {
                /* 背光已经打开，因此打印一条消息，说明定时器即将重置，并打印重置时间。 */
                vPrintStringAndNumber(
                    "按键按下，重置软件定时器，时间\t\t",
                    xTimeNow );
            }

            /* 重置软件定时器。如果背光之前是关闭的，那么此调用将启动定时器。如果背光之前是打开的，那么此调用将重启定时器。在实际应用中，可能会在中断中读取按键。如果此函数是一个中断服务程序，那么必须使用xTimerResetFromISR()代替xTimerReset()。 */
            xTimerReset( xBacklightTimer, xShortDelay );

            /* 读取并丢弃被按下的按键——这个简单示例不需要它。 */
            ( void ) _getch();
        }
    }
}
```
***代码清单6.16*** *用于重置示例6.3中软件定时器的任务*

执行示例6.3时产生的输出如图6.10所示。参考图6.10：

- 第一次按键发生在tick计数为812时。此时背光被打开，一次性定时器启动。

- 在计数器的值为1813、3114、4015和5016时，发生了进一步的按键操作。所有这些按键操作都导致在定时器到期之前重置了定时器。

- 当计数器的值达到10016时，定时器到期。此时，背光被关闭。


<a name="fig6.10" title="图6.10 执行示例6.3时产生的输出"></a>

* * *
![](media/image47.jpg)
***图6.10*** *执行示例6.3时产生的输出*
* * *

从图6.10中可以看出，定时器的周期为5000个计数；在最后一次按键操作后的5000个计数时，背光被关闭，也就是在定时器最后一次重置后的5000个计数时。


