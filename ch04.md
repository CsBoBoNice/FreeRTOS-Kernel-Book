# 4 任务管理

## 4.1 介绍

### 4.1.1 范围

本章内容包括：

- FreeRTOS 如何为应用程序中的每个任务分配处理时间。
- FreeRTOS 如何选择在任何给定时间应执行哪个任务。
- 每个任务的相对优先级如何影响系统行为。
- 任务可以存在的状态。

本章还讨论了：

- 如何实现任务。
- 如何创建一个或多个任务实例。
- 如何使用任务参数。
- 如何更改已创建任务的优先级。
- 如何删除任务。
- 如何使用任务实现周期性处理。（后续章节将描述如何使用软件定时器实现相同功能。）
- 空闲任务何时执行以及如何使用它。

本章介绍的概念是理解如何使用 FreeRTOS 以及 FreeRTOS 应用程序行为的基础。因此，这是本书中最详细的章节。

## 4.2 任务函数

任务以 C 函数的形式实现。任务必须实现如代码清单 4.1 所示的函数原型，该函数接受一个 void 指针参数并返回 void。

<a name="list4.1" title="代码清单 4.1 任务函数原型"></a>

```c
void vATaskFunction( void * pvParameters );
```

***代码清单 4.1*** *任务函数原型*

每个任务本身都是一个独立的程序。它有一个入口点，通常在一个无限循环中永远运行，并且不会退出。代码清单 4.2 展示了一个典型任务的结构。

FreeRTOS 任务不允许以任何方式从其实现函数中返回。它不能包含 `return` 语句，也不允许执行到其实现函数的末尾。如果任务不再需要，应显式删除，如代码清单 4.2 所示。

单个任务函数定义可用于创建任意数量的任务，其中每个创建的任务都是一个独立的执行实例。每个实例都有自己的栈，因此任务内部定义的任何自动（栈）变量都有自己的副本。

<a name="list4.2" title="代码清单 4.2 典型任务函数的结构"></a>

```c
void vATaskFunction( void * pvParameters )
{
    /*
     * 栈分配的变量可以在函数内部正常声明。
     * 使用此示例函数创建的每个任务实例都将在任务栈上分配自己的 lStackVariable 实例。
     */
    long lStackVariable = 0;

    /*
     * 与栈分配的变量不同，使用 `static` 关键字声明的变量由链接器分配到内存中的特定位置。
     * 这意味着所有调用 vATaskFunction 的任务将共享相同的 lStaticVariable 实例。
     */
    static long lStaticVariable = 0;

    for( ;; )
    {
        /* 实现任务功能的代码将放在这里。 */
    }

    /*
     * 如果任务实现代码退出了上述循环，则任务必须在到达其实现函数末尾之前被删除。
     * 当 `NULL` 作为参数传递给 vTaskDelete() API 函数时，表示要删除的任务是调用（当前）任务。
     */
    vTaskDelete( NULL );
}
```

***代码清单 4.2*** *典型任务函数的结构*

## 4.3 顶层任务状态

一个应用程序可能由多个任务组成。如果运行该应用程序的处理器是单核的，那么在任何给定时间只能有一个任务在执行。这意味着任务可能处于以下两种状态之一：*运行中* 和 *未运行*。我们首先考虑这种简化的模型。本章后面部分将描述 *未运行* 状态的几个子状态。

当处理器正在执行某个任务的代码时，该任务处于 *运行中* 状态。当任务处于 *未运行* 状态时，任务被暂停，并且其状态已被保存，以便在调度器决定它应该进入 *运行中* 状态时，任务可以恢复执行。当任务恢复执行时，它将从离开 *运行中* 状态时即将执行的指令处继续执行。


<a name="fig4.1" title="Figure 4.1 Top level task states and transitions"></a>

***
![](media/figure_4.1_top_level_task_states.png)
***图 4.1*** *顶层任务状态及其转换*
***

一个任务从 *未运行* 状态转换到 *运行中* 状态被称为 "切换入" 或 "交换入"。相反，一个任务从 *运行中* 状态转换到 *未运行* 状态被称为 "切换出" 或 "交换出"。FreeRTOS 调度器是唯一可以将任务在 *运行中* 状态和 *未运行* 状态之间进行切换的实体。

## 4.4 任务创建

创建任务可以使用六个 API 函数：
`xTaskCreate()`、
`xTaskCreateStatic()`、
`xTaskCreateRestricted()`、
`xTaskCreateRestrictedStatic()`、
`xTaskCreateAffinitySet()`，以及
`xTaskCreateStaticAffinitySet()`。

每个任务需要两块 RAM：一块用于存储任务控制块（TCB），另一块用于存储其栈。名称中包含 "Static" 的 FreeRTOS API 函数使用预先分配的 RAM 块，这些 RAM 块作为参数传递给函数。相反，名称中不包含 "Static" 的 API 函数会在运行时从系统堆中动态分配所需的 RAM。

某些 FreeRTOS 端口支持任务在 "受限" 或 "非特权" 模式下运行。名称中包含 "Restricted" 的 FreeRTOS API 函数创建的任务对系统内存的访问权限受限。名称中不包含 "Restricted" 的 API 函数创建的任务在 "特权模式" 下运行，可以访问系统的整个内存映射。

支持对称多处理（SMP）的 FreeRTOS 端口允许不同任务在同一 CPU 的多个核心上同时运行。对于这些端口，您可以使用名称中包含 "Affinity" 的函数指定任务将在哪个核心上运行。

FreeRTOS 任务创建的 API 函数相当复杂。本文档中的大多数示例使用 `xTaskCreate()`，因为它是这些函数中最简单的一个。

### 4.4.1 xTaskCreate() API 函数

清单 4.3 展示了 `xTaskCreate()` API 函数的原型。
`xTaskCreateStatic()` 还有两个额外的参数，分别指向预分配的内存，用于保存任务的数据结构和栈。
[第 2.5 节：数据类型和编码风格指南](ch02.md#25-data-types-and-coding-style-guide) 描述了所使用的数据类型和命名约定。

<a name="list4.3" title="清单 4.3 xTaskCreate() API 函数原型"></a>

```c
BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,
                        const char * const pcName,
                        configSTACK_DEPTH_TYPE usStackDepth,
                        void * pvParameters,
                        UBaseType_t uxPriority,
                        TaskHandle_t * pxCreatedTask );
```

***清单 4.3*** *xTaskCreate() API 函数原型*

**xTaskCreate() 参数及返回值：**

- `pvTaskCode`

  任务就是永不退出的 C 函数，因此通常实现为一个无限循环。`pvTaskCode` 参数是一个指向实现任务的函数的指针（实际上就是函数名）。

- `pcName`

  任务的描述性名称。FreeRTOS 不会以任何方式使用该名称，它仅作为调试辅助工具包含在内。通过人类可读的名称来标识任务比通过其句柄来标识要简单得多。

  应用程序定义的常量 `configMAX_TASK_NAME_LEN` 定义了任务名称的最大长度，包括 NULL 终止符。如果提供更长的字符串，字符串将被截断。

- `usStackDepth`

  指定为任务分配的堆栈大小。使用 `xTaskCreateStatic()` 而不是 `xTaskCreate()` 以使用预分配的内存而不是动态分配的内存。

  请注意，该值指定堆栈可以容纳的字数，而不是字节数。例如，如果堆栈宽度为 32 位且 `usStackDepth` 为 128，则 `xTaskCreate()` 会分配 512 字节的堆栈空间（128 * 4 字节）。

  `configSTACK_DEPTH_TYPE` 是一个宏，允许应用程序编写者指定用于保存堆栈大小的数据类型。如果未定义，`configSTACK_DEPTH_TYPE` 默认为 `uint16_t`，因此如果堆栈深度乘以堆栈宽度大于 65535（最大的 16 位数字），请在 `FreeRTOSConfig.h` 中将 `configSTACK_DEPTH_TYPE` 定义为 `unsigned long` 或 `size_t`。

[第13.3节 栈溢出](ch13.md#133-stack-overflow)描述了一种选择最佳栈大小的实用方法。

- `pvParameters`

  实现任务的函数接受一个`void *`类型的参数。`pvParameters`是通过该参数传递给任务的值。

- `uxPriority`

  定义任务的优先级。0为最低优先级，`(configMAX_PRIORITIES – 1)`为最高优先级。[第4.5节](#45-task-priorities)描述了用户定义的`configMAX_PRIORITIES`常量。

  如果定义的`uxPriority`大于`(configMAX_PRIORITIES – 1)`，它将被限制为`(configMAX_PRIORITIES – 1)`。

- `pxCreatedTask`

  指向存储创建任务句柄的位置的指针。该句柄可用于未来的API调用，例如更改任务优先级或删除任务。

  `pxCreatedTask`是一个可选参数，如果不需要任务句柄，可以将其设置为NULL。

- 返回值

  有两种可能的返回值：

  - `pdPASS`

    表示任务已成功创建。

- `pdFAIL`

    这表示没有足够的堆内存来创建任务。[第3章](ch03.md#3-heap-memory-management)提供了更多关于堆内存管理的信息。

<a name="example4.1" title="示例 4.1 创建任务"></a>
---
***示例 4.1*** *创建任务*

---

以下示例演示了创建两个简单任务并启动这些新任务所需的步骤。这些任务通过使用一个简单的忙循环来创建周期延迟，定期打印出一个字符串。两个任务以相同的优先级创建，除了打印的字符串不同外，其他完全相同——参见清单4.4和清单4.5中的实现。关于在任务中使用`printf()`的警告，请参阅第8章。

<a name="list4.4" title="清单 4.4 示例 4.1 中使用的第一个任务的实现"></a>

```c
void vTask1( void * pvParameters )
{
    /* ulCount 被声明为 volatile 以确保它不会被优化掉。 */
    volatile unsigned long ulCount;

    for( ;; )
    {
        /* 打印当前任务的名称。 */
        vPrintLine( "Task 1 is running" );

        /* 延迟一段时间。 */
        for( ulCount = 0; ulCount < mainDELAY_LOOP_COUNT; ulCount++ )
        {
            /*
             * 这个循环只是一个非常简单的延迟实现。里面没有任何操作。
             * 后面的示例将用适当的延迟/睡眠函数替换这个简单的循环。
             */
        }
    }
}
```

***清单 4.4*** *示例 4.1 中使用的第一个任务的实现*

<a name="list4.5" title="清单 4.5 示例 4.1 中使用的第二个任务的实现"></a>

```c
void vTask2( void * pvParameters )
{
    /* ulCount 被声明为 volatile 以确保它不会被优化掉。 */
    volatile unsigned long ulCount;

    /* 与大多数任务一样，此任务在一个无限循环中实现。 */
    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( "Task 2 is running" );

        /* 延迟一段时间。 */
        for( ulCount = 0; ulCount < mainDELAY_LOOP_COUNT; ulCount++ )
        {
            /*
             * 这个循环只是一个非常简单的延迟实现。里面没有任何操作。
             * 后面的示例将用适当的延迟/睡眠函数替换这个简单的循环。
             */
        }
    }
}
```

***清单 4.5*** *示例 4.1 中使用的第二个任务的实现*

`main()`函数在启动调度器之前创建了这些任务——参见清单4.6中的实现。

<a name="list4.6" title="代码清单 4.6 启动示例 4.1 的任务"></a>

```c
int main( void )
{
    /*
     * 在此处声明的变量在启动 FreeRTOS 调度器后可能不再存在。
     * 不要尝试从任务中访问在 main() 使用的栈上声明的变量。
     */

    /*
     * 创建两个任务之一。请注意，实际应用程序应检查 xTaskCreate() 调用的
     * 返回值，以确保任务创建成功。
     */
    xTaskCreate( vTask1,  /* 指向实现任务的函数的指针。*/
                 "Task 1",/* 任务的文本名称。 */
                 1000,    /* 栈深度（以字为单位）。 */
                 NULL,    /* 此示例不使用任务参数。 */
                 1,       /* 此任务将以优先级 1 运行。 */
                 NULL );  /* 此示例不使用任务句柄。 */

    /* 以完全相同的方式和相同的优先级创建另一个任务。*/
    xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL );

    /* 启动调度器，使任务开始执行。 */
    vTaskStartScheduler();

    /*
     * 如果一切正常，main() 将不会到达这里，因为调度器现在
     * 将运行已创建的任务。如果 main() 到达这里，则说明
     * 没有足够的堆内存来创建空闲任务或定时器任务
     * （本书后面会介绍）。第 3 章提供了有关堆内存管理的更多信息。
     */
    for( ;; );
}
```

***代码清单 4.6*** *启动示例 4.1 的任务*

执行该示例将产生如图 4.2 所示的输出。

<a name="fig4.2" title="图4.2 执行示例4.1时产生的输出"></a>

***

```console
C:\Temp>rtosdemo
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
```

***图4.2*** *执行示例4.1时产生的输出[^4]*

***

[^4]: 截图中显示每个任务在执行前都准确地打印了一次其消息。这是使用FreeRTOS Windows模拟器产生的人工场景。Windows模拟器并非真正的实时系统。此外，写入Windows控制台需要相对较长的时间，并导致一系列Windows系统调用。在真实的嵌入式目标上执行相同的代码，并使用快速且非阻塞的打印函数，可能会导致每个任务在被切换出去以允许另一个任务运行之前，多次打印其字符串。

图4.2展示了两个任务看似同时执行的情况；然而，这两个任务都在同一个处理器核心上执行，因此实际情况并非如此。实际上，这两个任务都在快速进入和退出*运行*状态。由于两个任务以相同的优先级运行，因此它们共享同一个处理器核心的时间。图4.3展示了它们实际的执行模式。

图4.3底部的箭头表示时间从t1开始流逝。彩色线条展示了每个时间点正在执行的任务——例如，任务1在t1到t2之间执行。

在任何时刻，只有一个任务可以处于*运行*状态。因此，当一个任务进入*运行*状态（任务被切换进来），另一个任务则会进入*非运行*状态（任务被切换出去）。


<a name="fig4.3" title="图4.3 例4.1中两个任务的实际执行模式"></a>

***
![](media/figure_4.3_example_4.1_execution_pattern.png)
***图4.3*** *例4.1中两个任务的实际执行模式*
***

例4.1在启动调度器之前，通过`main()`函数创建了两个任务。也可以在一个任务内部创建另一个任务。例如，任务2可以在任务1内部创建，如代码清单4.7所示。

<a name="list4.7" title="清单 4.7 在调度器启动后从另一个任务中创建任务"></a>

```c
void vTask1( void * pvParameters )
{
    const char *pcTaskName = "Task 1 is running\r\n";
    volatile unsigned long ul; /* volatile 确保 ul 不会被优化掉。 */

    /*
     * 如果此任务代码正在执行，则调度器肯定已经启动。
     * 在进入无限循环之前创建另一个任务。
     */
    xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL );

    for( ;; )
    {
        /* 打印出此任务的名称。 */
        vPrintLine( pcTaskName );

        /* 延迟一段时间。 */
        for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
        {
            /*
             * 这个循环只是一个非常粗略的延迟实现。
             * 里面没有任何操作。后面的示例将用适当的
             * 延迟/睡眠函数替换这个粗略的循环。
             */
        }
    }
}
```

***清单 4.7*** *在调度器启动后从另一个任务中创建任务*

<a name="example4.2" title="示例 4.2 使用任务参数"></a>
---
***示例 4.2*** *使用任务参数*

---

在示例 4.1 中创建的两个任务几乎完全相同，它们之间的唯一区别是打印出的文本字符串。如果创建单个任务实现的两个实例，并使用任务参数将字符串传递给每个实例，则可以消除这种重复。

示例 4.2 将示例 4.1 中使用的两个任务函数替换为一个名为 `vTaskFunction()` 的单一任务函数，如代码清单 4.8 所示。请注意，任务参数被强制转换为 `char *` 类型，以获取任务应打印的字符串。


<a name="list4.8" title="代码清单 4.8 示例 4.2 中用于创建两个任务的单一任务函数"></a>

```c
void vTaskFunction( void * pvParameters )
{

    char *pcTaskName;
    volatile unsigned long ul; /* volatile 确保 ul 不会被优化掉。 */

    /*
     * 要打印的字符串通过参数传入。将其强制转换为字符指针。
     */
    pcTaskName = ( char * ) pvParameters;

    /* 与大多数任务一样，此任务在一个无限循环中实现。 */
    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( pcTaskName );

        /* 延迟一段时间。 */
        for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
        {
            /*
             * 此循环只是一个非常粗糙的延迟实现。在这里没有任何操作。
             * 后续练习将用适当的延迟/睡眠函数替换此粗糙循环。
             */
        }
    }
}
```

***代码清单 4.8*** *示例 4.2 中用于创建两个任务的单一任务函数*

代码清单 4.9 创建了两个由 `vTaskFunction()` 实现的任务实例，使用任务的参数向每个任务传递不同的字符串。这两个任务在 FreeRTOS 调度器的控制下独立执行，并拥有各自的栈，因此也拥有各自的 `pcTaskName` 和 `ul` 变量副本。

<a name="list4.9" title="Listing 4.9 The main() function for Example 2"></a>


```c
/*
 * 定义将作为任务参数传递的字符串。这些字符串被定义为const且不在main()使用的栈上，
 * 以确保任务执行时它们仍然有效。
 */
static const char * pcTextForTask1 = "Task 1 is running";
static const char * pcTextForTask2 = "Task 2 is running";

int main( void )
{
    /*
     * 此处声明的变量在启动FreeRTOS调度器后可能不再存在。
     * 不要尝试从任务中访问在main()使用的栈上声明的变量。
     */

    /* 创建两个任务中的一个。 */
    xTaskCreate( vTaskFunction,             /* 指向实现任务的函数的指针。 */
                 "Task 1",                  /* 任务的文本名称。仅用于调试。 */
                 1000,                      /* 栈深度 - 小型微控制器将使用比这少得多的栈。 */
                 ( void * ) pcTextForTask1, /* 使用任务参数将文本传递到任务中。 */
                 1,                         /* 此任务将以优先级1运行。 */
                 NULL );                    /* 此示例中未使用任务句柄。 */

    /*
     * 以完全相同的方式创建另一个任务。注意，这次是从相同的任务实现（vTaskFunction）
     * 创建多个任务。只有传递的参数值不同。正在创建同一任务定义的两个实例。
     */
    xTaskCreate( vTaskFunction,
                 "Task 2",
                 1000,
                 ( void * ) pcTextForTask2,
                 1,
                 NULL );

    /* 启动调度器，使任务开始执行。 */
    vTaskStartScheduler();

    /*
     * 如果一切顺利，main()不会到达这里，因为调度器将运行创建的任务。
     * 如果main()确实到达这里，那么没有足够的堆内存来创建空闲任务或定时器任务
     * （本书后面会介绍）。第3章提供了更多关于堆内存管理的信息。
     */
    for( ;; )
    {
    }
}
```

***代码清单4.9*** *示例2的main()函数*


示例4.2的输出与图4.2中示例1的输出完全相同。

## 4.5 任务优先级

FreeRTOS 调度器始终确保优先级最高的可运行任务被选中进入 *运行* 状态。相同优先级的任务将轮流进入和退出 *运行* 状态。

用于创建任务的 API 函数中的 `uxPriority` 参数决定了任务的初始优先级。`vTaskPrioritySet()` API 函数可以在任务创建后更改其优先级。

应用程序定义的编译时配置常量 `configMAX_PRIORITIES` 设置了可用优先级的数量。较低的数值表示低优先级任务，优先级 0 为最低优先级——因此有效优先级范围为 0 到 `(configMAX_PRIORITIES – 1)`。任意数量的任务可以共享相同的优先级。

FreeRTOS 调度器有两种实现用于选择 *运行* 状态任务的算法，`configMAX_PRIORITIES` 的最大允许值取决于所使用的实现：

### 4.5.1 通用调度器

通用调度器使用 C 语言编写，可以与所有 FreeRTOS 架构移植版本兼容。它对 `configMAX_PRIORITIES` 没有上限限制。通常建议尽量减少 `configMAX_PRIORITIES` 的值，因为更多的优先级值会占用更多 RAM 并导致最坏情况下的执行时间更长。

### 4.5.2 架构优化的调度器

架构优化的实现采用特定架构的汇编代码编写，其性能优于通用的 C 语言实现，并且在所有 `configMAX_PRIORITIES` 值下的最坏执行时间相同。

架构优化的实现限制了 `configMAX_PRIORITIES` 的最大值：在 32 位架构上为 32，在 64 位架构上为 64。与通用方法一样，建议将 `configMAX_PRIORITIES` 保持在最低可行的值，因为更高的值需要更多的 RAM。

在 FreeRTOSConfig.h 中将 `configUSE_PORT_optimized_TASK_SELECTION` 设置为 1 以使用架构优化的实现，或设置为 0 以使用通用实现。并非所有 FreeRTOS 移植版本都支持架构优化的实现。对于支持架构优化的移植版本，如果未定义 `configUSE_PORT_optimized_TASK_SELECTION`，则默认值为 1；对于不支持的移植版本，如果未定义 `configUSE_PORT_optimized_TASK_SELECTION`，则默认值为 0。

## 4.6 时间测量与Tick中断

[第4.12节，调度算法](#412-scheduling-algorithms)描述了一个称为“时间片”的可选功能。时间片已在目前展示的示例中使用，并且是这些示例输出中观察到的行为。在这些示例中，两个任务以相同的优先级创建，并且两个任务始终能够运行。因此，每个任务执行一个“时间片”，在时间片开始时进入*运行*状态，在时间片结束时退出*运行*状态。在图4.3中，t1和t2之间的时间等于一个时间片。

调度器在每个时间片结束时执行，以选择下一个要运行的任务[^5]。为此，使用了一个称为“tick中断”的周期性中断。编译时配置常量`configTICK_RATE_HZ`用于设置tick中断的频率，从而也决定了每个时间片的长度。例如，将`configTICK_RATE_HZ`设置为100（Hz）会导致每个时间片持续10毫秒。两次tick中断之间的时间称为“tick周期”——因此一个时间片等于一个tick周期。

[^5]: 需要注意的是，时间片的结束并不是调度器选择新任务运行的唯一时机。正如我们将在本书中展示的，当当前执行的任务进入*阻塞*状态，或者当某个中断将更高优先级的任务移动到*就绪*状态时，调度器也会立即选择一个新的任务来运行。

图4.4对图4.3进行了扩展，展示了调度器的执行过程。在图4.4中，顶部的线条显示了调度器的执行时间，细箭头展示了从任务到滴答中断，再从滴答中断返回到另一个任务的执行顺序。

`configTICK_RATE_HZ`的最佳值取决于具体的应用，但通常设置为100。

<a name="fig4.4" title="图4.4 扩展的执行序列，展示滴答中断的执行"></a>

***
![](media/figure_4.4_expanded_execution_sequence_with_tick_interrupt.png)
***图4.4*** *扩展的执行序列，展示滴答中断的执行*
***

FreeRTOS API调用以滴答周期的倍数指定时间，通常简称为“滴答”。`pdMS_TO_TICKS()`宏将指定的毫秒时间转换为滴答时间。可用的分辨率取决于定义的滴答频率，如果滴答频率高于1KHz（即`configTICK_RATE_HZ`大于1000），则不能使用`pdMS_TO_TICKS()`。代码清单4.10展示了如何使用`pdMS_TO_TICKS()`将指定的200毫秒时间转换为等效的滴答时间。

<a name="list4.10" title="清单 4.10 使用 pdMS\_TO\_TICKS() 宏将 200 毫秒转换为..."></a>

```c
/*
 * pdMS_TO_TICKS() 以毫秒为单位的时间作为其唯一参数，
 * 并计算为等效的 tick 周期时间。此示例展示了
 * xTimeInTicks 被设置为与 200 毫秒等效的 tick 周期数。
 */
TickType_t xTimeInTicks = pdMS_TO_TICKS( 200 );
```

***清单 4.10*** *使用 pdMS\_TO\_TICKS() 宏将 200 毫秒转换为等效的 tick 周期时间*

使用 `pdMS_TO_TICKS()` 以毫秒为单位指定时间，而不是直接使用 tick，可以确保应用程序中指定的时间在 tick 频率改变时不会发生变化。

'tick 计数' 是自调度器启动以来发生的 tick 中断的总数，假设 tick 计数未溢出。用户应用程序在指定延迟周期时无需考虑溢出问题，因为 FreeRTOS 在内部管理时间一致性。

[第4.12节：调度算法](#412-scheduling-algorithms)  
描述了影响调度器何时选择新任务运行以及何时执行时钟中断的配置常量。

<a name="example4.3" title="示例4.3 优先级实验"></a>
---
***示例4.3*** *优先级实验*

---

调度器始终确保能够运行的优先级最高的任务被选中进入*运行*状态。到目前为止的示例中创建了两个相同优先级的任务，因此它们依次进入和退出*运行*状态。本示例将探讨当任务具有不同优先级时会发生什么。清单4.11展示了用于创建任务的代码，第一个任务的优先级为1，第二个任务的优先级为2。实现这两个任务的单个函数没有改变；它仍然定期打印字符串，并使用空循环来创建延迟。

<a name="list4.11" title="清单4.11 创建两个不同优先级的任务"></a>

```c
/*
 * 定义将作为任务参数传递的字符串。
 * 这些字符串被定义为const且不在栈上，以确保任务执行时它们仍然有效。
 */
static const char * pcTextForTask1 = "Task 1 is running";
static const char * pcTextForTask2 = "Task 2 is running";

int main( void )
{
    /* 创建第一个任务，优先级为1。 */
    xTaskCreate( vTaskFunction,             /* 任务函数        */
                 "Task 1",                  /* 任务名称        */
                 1000,                      /* 任务栈深度      */
                 ( void * ) pcTextForTask1, /* 任务参数        */
                 1,                         /* 任务优先级      */
                 NULL );

    /* 创建第二个任务，优先级为2。 */
    xTaskCreate( vTaskFunction,             /* 任务函数        */
                 "Task 2",                  /* 任务名称        */
                 1000,                      /* 任务栈深度      */
                 ( void * ) pcTextForTask2, /* 任务参数        */
                 2,                         /* 任务优先级      */
                 NULL );

    /* 启动调度器，使任务开始执行。 */
    vTaskStartScheduler();

    /* 不会执行到这里。 */
    return 0;
}
```

***清单4.11*** *创建两个不同优先级的任务*

图4.5展示了示例4.3的输出结果。

调度器总是选择可以运行的最高优先级任务。任务2的优先级高于任务1，并且始终可以运行；因此，调度器总是选择任务2，而任务1永远不会执行。任务1被认为是被任务2“饿死”了处理时间——它无法打印其字符串，因为它从未处于*运行*状态。


<a name="fig4.5" title="图 4.5 以不同优先级运行两个任务"></a>

***
```console
C:\Temp>rtosdemo
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
```

***图 4.5*** *以不同优先级运行两个任务*
***

任务2始终可以运行，因为它不需要等待任何东西——它要么在空循环中循环，要么向终端输出。


<a name="fig4.6" title="图 4.6 当一个任务的优先级高于另一个任务时的执行模式"></a>

***
![](media/figure_4.6_execution_pattern_higher_priority_task.png)
***图 4.6*** *当一个任务的优先级高于另一个任务时的执行模式（来自示例4.3）*


## 4.7 扩展*非运行*状态

到目前为止，创建的任务始终有需要处理的工作，并且从不需要等待任何东西——由于它们从不需要等待，因此它们总是能够进入*运行*状态。这种“连续处理”的任务实用性有限，因为它们只能在最低优先级下创建。如果它们在更高的优先级下运行，它们将阻止所有更低优先级的任务运行。

为了使这些任务变得实用，必须将它们重写为事件驱动型。事件驱动型任务只有在事件触发后才有工作（处理）要执行，在此之前无法进入*运行*状态。调度程序总是选择能够运行的最高优先级任务。如果由于一个高优先级任务正在等待事件而无法被选中，调度程序则必须转而选择一个能够运行的低优先级任务。因此，编写事件驱动型任务意味着可以在不同优先级下创建任务，而不会让最高优先级的任务剥夺所有低优先级任务的处理时间。

### 4.7.1 *阻塞*状态

等待事件的任务被称为处于“阻塞”状态，这是*非运行*状态的一个子状态。

任务可以进入*阻塞*状态以等待两种不同类型的事件：

1. 时间事件——这些事件发生在延迟时间结束或到达绝对时间时。例如，任务可能进入*阻塞*状态以等待10毫秒过去。

2. 同步事件——这些事件源于另一个任务或中断。例如，任务可能进入*阻塞*状态以等待数据到达队列。同步事件涵盖了广泛的事件类型。

FreeRTOS中的队列、二进制信号量、计数信号量、互斥锁、递归互斥锁、事件组、流缓冲区、消息缓冲区和直接任务通知都可以创建同步事件。后续章节将详细介绍这些功能。

任务可以以超时的方式阻塞在同步事件上，从而同时阻塞在两种类型的事件上。例如，任务可以选择最多等待10毫秒以等待数据到达队列。如果数据在10毫秒内到达或10毫秒过去后没有数据到达，任务将离开*阻塞*状态。

### 4.7.2 *挂起*状态

*挂起*状态也是*非运行*状态的一个子状态。处于挂起状态的任务对调度程序不可用。进入挂起状态的唯一途径是通过调用`vTaskSuspend()` API函数，而退出挂起状态的唯一途径是通过调用`vTaskResume()`或`xTaskResumeFromISR()` API函数。大多数应用程序不会使用挂起状态。

### 4.7.3 *就绪*状态

处于*非运行*状态且未被*阻塞*或*挂起*的任务被称为处于*就绪*状态。这些任务可以运行，因此处于“就绪”状态，但当前并未处于*运行*状态。

### 4.7.4 完善状态转换图

图4.7在简化状态图的基础上进行了扩展，包含了本节描述的所有*非运行*子状态。到目前为止，示例中创建的任务尚未使用*阻塞*或*挂起*状态。它们仅在*就绪*状态和*运行*状态之间进行转换，如图4.7中的粗线所示。

<a name="fig4.7" title="Figure 4.7 Full task state machine"></a>

***
![](media/figure_4.7_full_task_state_machine.png)
***图 4.7*** *完整的任务状态机*
***

<a name="example4.4" title="Example 4.4 Using the Blocked state to create a delay"></a>
---
***示例 4.4*** *使用 *Blocked* 状态创建延迟</i></h3>

---

到目前为止，示例中创建的所有任务都是“周期性的”——它们延迟一段时间，然后打印出字符串，再次延迟，依此类推。延迟是通过非常粗糙的空循环生成的——任务轮询一个递增的循环计数器，直到达到固定值。示例 4.3 清楚地展示了这种方法的缺点。高优先级任务在执行空循环时保持在 *Running* 状态，“饿死”了低优先级任务的任何处理时间。

任何形式的轮询还有其他几个缺点，尤其是其低效性。在轮询期间，任务实际上没有工作要做，但仍然使用了最大的处理时间，因此浪费了处理器周期。示例 4.4 通过将轮询空循环替换为调用 `vTaskDelay()` API 函数来纠正这种行为，其原型如代码清单 4.12 所示。新的任务定义如代码清单 4.13 所示。请注意，`vTaskDelay()` API 函数仅在 FreeRTOSConfig.h 中将 `INCLUDE_vTaskDelay` 设置为 1 时可用。

`vTaskDelay()` 将调用任务置于 *阻塞* 状态，持续固定的时钟中断次数。在 *阻塞* 状态下，任务不会占用任何处理时间，因此任务只在有实际工作需要完成时才会占用处理时间。


<a name="list4.12" title="Listing 4.12 The vTaskDelay() API function prototype"></a>


```c
void vTaskDelay( TickType_t xTicksToDelay );
```

***代码清单 4.12*** *vTaskDelay() API 函数原型*

**vTaskDelay 参数:**

- `xTicksToDelay`

  调用任务在重新进入就绪状态之前，将在 *阻塞* 状态下停留的时钟中断次数。

  例如，如果任务在时钟计数为 10,000 时调用 `vTaskDelay( 100 )`，那么它将立即进入 *阻塞* 状态，并保持在 *阻塞* 状态，直到时钟计数达到 10,100。

  宏 `pdMS_TO_TICKS()` 可用于将以毫秒为单位的时间转换为以时钟滴答为单位的时间。例如，调用 `vTaskDelay( pdMS_TO_TICKS( 100 ) )` 将使调用任务在 *阻塞* 状态下停留 100 毫秒。

<a name="list4.13" title="代码清单 4.13 在将空循环延迟替换为调用vTaskDelay()后的示例任务源代码"></a>

```c
void vTaskFunction( void * pvParameters )
{
    char * pcTaskName;
    const TickType_t xDelay250ms = pdMS_TO_TICKS( 250 );

    /*
     * 通过参数传递要打印的字符串。将其强制转换为字符指针。
     */
    pcTaskName = ( char * ) pvParameters;

    /* 与大多数任务一样，此任务在无限循环中实现。 */
    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( pcTaskName );

        /*
         * 延迟一段时间。这里使用了vTaskDelay()调用，
         * 该调用将任务置于阻塞状态，直到延迟周期结束。
         * 参数接受以“滴答”为单位的时间，而pdMS_TO_TICKS()宏
         * （用于声明xDelay250ms常量）用于将250毫秒转换为等效的滴答时间。
         */
        vTaskDelay( xDelay250ms );
    }
}
```

***代码清单 4.13*** *将空循环延迟替换为调用vTaskDelay()后的示例任务源代码*

尽管两个任务仍以不同的优先级创建，但现在两者都会运行。示例4.4的输出（如图4.8所示）确认了预期的行为。

<a name="fig4.8" title="Figure 4.8 Example 4.4 执行时产生的输出"></a>

***

```console
C:\Temp>rtosdemo
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
```

***图 4.8*** *Example 4.4 执行时产生的输出*
***

图 4.9 中所示的执行顺序解释了为什么两个任务都会运行，尽管它们是以不同的优先级创建的。为了简化，调度器本身的执行被省略了。

当调度器启动时，空闲任务会自动创建，以确保始终至少有一个任务可以运行（至少有一个任务处于*就绪*状态）。[第 4.8 节：空闲任务和空闲任务钩子](#48-the-idle-task-and-the-idle-task-hook)更详细地描述了空闲任务。


<a name="fig4.9" title="Figure 4.9 当任务使用 vTaskDelay() 代替空循环时的执行顺序"></a>

***
![](media/figure_4.9_vTaskDelay_execution_sequence.png)
***图 4.9*** *当任务使用 vTaskDelay() 代替空循环时的执行顺序*
***

只有两个任务的实现发生了变化，其功能并未改变。将图 4.9 与图 4.4 进行比较，可以清楚地看到，这种功能是以一种更加高效的方式实现的。

图4.4展示了任务使用空循环创建延迟时的执行模式，因此它们总是能够运行。结果是，它们共同使用了百分之百的可用处理器时间。图4.9则展示了任务在其延迟期间完全进入*阻塞*状态时的执行模式。它们仅在真正需要执行工作时（在本例中仅需打印一条消息）才使用处理器时间，因此只使用了可用处理时间的极小部分。

在图4.9所示的场景中，每次任务离开*阻塞*状态后，它们会执行一小段时间（少于一个时钟周期），然后重新进入阻塞状态。大多数时候，没有可运行的应用程序任务（没有处于*就绪*状态的应用程序任务），因此也没有应用程序任务可以被选择进入*运行*状态。在这种情况下，空闲任务会运行。分配给空闲任务的处理时间量是系统中空闲处理能力的度量。使用实时操作系统（RTOS）可以显著增加空闲处理能力，只需允许应用程序完全由事件驱动即可。

图4.10中的粗线展示了示例4.4中任务执行的状态转换，每个任务现在都会先经过*阻塞*状态，然后再返回到*就绪*状态。

<a name="fig4.10" title="图4.10 粗线表示示例4.4中任务执行的状态转换..."></a>

***
![](media/figure_4.10_example_4.4_state_machine.png)
***图4.10*** *粗线表示示例4.4中任务执行的状态转换*
***

### 4.7.5 vTaskDelayUntil() API函数

`vTaskDelayUntil()`与`vTaskDelay()`类似。正如刚才所演示的，`vTaskDelay()`的参数指定了任务调用`vTaskDelay()`与任务再次从*阻塞*状态转换出来之间应发生的滴答中断次数。任务在阻塞状态中停留的时间长度由`vTaskDelay()`参数指定，但任务离开阻塞状态的时间相对于调用`vTaskDelay()`的时间而言。

`vTaskDelayUntil()` 的参数指定的是调用任务应从 *阻塞* 状态转移到 *就绪* 状态的确切时间点计数值。当需要固定执行周期时（即希望任务以固定频率周期性执行），应使用 `vTaskDelayUntil()` 这个 API 函数，因为调用任务的解除阻塞时间是绝对的，而不是相对于函数调用时刻的相对时间（如 `vTaskDelay()` 的情况）。


<a name="list4.14" title="Listing 4.14 vTaskDelayUntil() API function prototype"></a>

```c
void vTaskDelayUntil( TickType_t * pxPreviousWakeTime,
                      TickType_t xTimeIncrement );
```

***清单 4.14*** *vTaskDelayUntil() API 函数原型*

**vTaskDelayUntil() 参数**

- `pxPreviousWakeTime`

  该参数的命名基于 `vTaskDelayUntil()` 用于实现周期性且固定频率执行的任务的假设。在这种情况下，`pxPreviousWakeTime` 保存了任务上次离开 *阻塞* 状态（被“唤醒”）的时间。该时间用作计算任务下次应离开 *阻塞* 状态时间的参考点。

`pxPreviousWakeTime`指向的变量会在`vTaskDelayUntil()`函数中自动更新；通常情况下，应用程序代码不会修改该变量，但在首次使用之前必须将其初始化为当前的滴答计数。清单4.15展示了如何初始化该变量。

- `xTimeIncrement`

  此参数的命名基于`vTaskDelayUntil()`用于实现以固定频率周期性执行的任务的假设，而该频率由`xTimeIncrement`值设定。

  `xTimeIncrement`以“滴答”为单位指定。宏`pdMS_TO_TICKS()`可用于将以毫秒为单位的时间转换为以滴答为单位的时间。

<a name="example4.5" title="示例4.5 将示例任务转换为使用vTaskDelayUntil()"></a>
---
***示例4.5*** *将示例任务转换为使用vTaskDelayUntil()*
---

示例4.4中创建的两个任务是周期性任务，但使用`vTaskDelay()`无法保证它们运行的频率是固定的，因为任务离开*阻塞*状态的时间是相对于它们调用`vTaskDelay()`的时间而言的。将任务转换为使用`vTaskDelayUntil()`而不是`vTaskDelay()`可以解决这一潜在问题。

<a name="list4.15" title="示例 4.15 使用 vTaskDelayUntil() 实现的任务示例"></a>

```c
void vTaskFunction( void * pvParameters )
{
    char * pcTaskName;
    TickType_t xLastWakeTime;

    /*
     * 通过参数传入要打印的字符串。将其转换为字符指针。
     */
    pcTaskName = ( char * ) pvParameters;

    /*
     * xLastWakeTime 变量需要用当前的 tick 计数进行初始化。
     * 注意，这是唯一一次显式写入该变量。此后，xLastWakeTime
     * 将在 vTaskDelayUntil() 中自动更新。
     */
    xLastWakeTime = xTaskGetTickCount();

    /* 与大多数任务一样，此任务在一个无限循环中实现。 */
    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( pcTaskName );

        /*
         * 此任务应每 250 毫秒执行一次。与 vTaskDelay() 函数一样，
         * 时间以 tick 为单位测量，pdMS_TO_TICKS() 宏用于将毫秒转换为 tick。
         * xLastWakeTime 在 vTaskDelayUntil() 中自动更新，
         * 因此任务无需显式更新它。
         */
        vTaskDelayUntil( &xLastWakeTime, pdMS_TO_TICKS( 250 ) );
    }
}
```

***示例 4.15*** *使用 vTaskDelayUntil() 实现的任务示例*

示例 4.5 的输出与图 4.8 中示例 4.4 的输出完全相同。

<a name="example4.6" title="Example 4.6 结合阻塞和非阻塞任务"></a>
---
***示例 4.6*** *结合阻塞和非阻塞任务*

---

前面的示例分别探讨了轮询任务和阻塞任务的行为。本示例进一步强化了我们已经提到的关于预期系统行为的观点，并展示了当这两种方案结合时的执行顺序，如下所示：

1. 创建了两个优先级为 1 的任务。这些任务除了持续打印字符串外，不执行任何其他操作。

   这些任务从不调用可能导致它们进入*阻塞*状态的 API 函数，因此它们始终处于就绪或*运行*状态。这种性质的任务被称为“连续处理”任务，因为它们始终有工作要做（尽管在本例中工作非常简单）。
   代码清单 4.16 展示了连续处理任务的源代码。

1. 然后创建了第三个任务，优先级为 2，高于其他两个任务。第三个任务也仅打印字符串，但这一次是周期性地打印，因此它使用 `vTaskDelayUntil()` API 函数在每次打印迭代之间将自己置于*阻塞*状态。

清单 4.17 展示了周期任务的源代码。


<a name="list4.16" title="清单 4.16 示例 4.6 中使用的持续处理任务"></a>


```c
void vContinuousProcessingTask( void * pvParameters )
{
    char * pcTaskName;

    /*
     * 通过参数传递要输出的字符串。将其强制转换为字符指针。
     */
    pcTaskName = ( char * ) pvParameters;

    /* 与大多数任务一样，此任务在无限循环中实现。 */
    for( ;; )
    {
        /*
         * 打印此任务的名称。此任务只是重复执行此操作，
         * 从不阻塞或延迟。
         */
        vPrintLine( pcTaskName );
    }
}
```

***清单 4.16*** *示例 4.6 中使用的持续处理任务*


<a name="list4.17" title="清单 4.17 示例 4.6 中使用的周期任务"></a>


```c
void vPeriodicTask( void * pvParameters )
{
    TickType_t xLastWakeTime;

    const TickType_t xDelay3ms = pdMS_TO_TICKS( 3 );

    /*
     * xLastWakeTime 变量需要用当前滴答计数初始化。
     * 请注意，这是唯一一次显式写入该变量。此后，
     * xLastWakeTime 由 vTaskDelayUntil() API 函数自动管理。
     */
    xLastWakeTime = xTaskGetTickCount();

    /* 与大多数任务一样，此任务在无限循环中实现。 */
    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( "Periodic task is running" );

        /*
         * 任务应每 3 毫秒执行一次——参见此函数中
         * xDelay3ms 的声明。
         */
        vTaskDelayUntil( &xLastWakeTime, xDelay3ms );
    }
}
```

***清单 4.17*** *示例 4.6 中使用的周期任务*

图 4.11 展示了示例 4.6 的输出结果，图 4.12 中的执行序列解释了观察到的行为。

<a name="fig4.11" title="图 4.11 执行示例 4.6 时产生的输出"></a>

***

```console
Continuous task 2 running
Continuous task 2 running
Periodic task is running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 2 running
Continuous task 2 running
Continuous task 2 running
Continuous task 2 running
Continuous task 2 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Continuous task 1 running
Periodic task is running
Continuous task 2 running
Continuous task 2 running
```

***图 4.11*** *执行示例 4.6 时产生的输出*
***


<a name="fig4.12" title="图 4.12 示例 4.6 的执行模式"></a>

***
![](media/figure_4.11_example_4.6_execution_pattern.png)
***图 4.12*** *示例 4.6 的执行模式*
***


## 4.8 空闲任务与空闲任务钩子

在示例4.4中创建的任务大部分时间都处于阻塞状态。在此状态下，它们无法运行，因此不会被调度器选中。

系统中必须始终至少有一个任务能够进入运行状态[^6]。为了确保这一点，调度器在调用`vTaskStartScheduler()`时会自动创建一个空闲任务。空闲任务几乎什么都不做，只是在一个循环中等待，因此，与第一个示例中的任务一样，它始终能够运行。

[^6]: 即使在使用了FreeRTOS的特殊低功耗功能时也是如此，在这种情况下，如果应用程序创建的任务都无法执行，运行FreeRTOS的微控制器将进入低功耗模式。

空闲任务具有最低可能的优先级（优先级为零），以确保它永远不会阻止更高优先级的应用程序任务进入*运行*状态。然而，如果应用程序设计者希望，他们可以创建与空闲任务相同优先级的任务，从而共享空闲任务的优先级。可以通过在`FreeRTOSConfig.h`中配置`configIDLE_SHOULD_YIELD`编译时常量，来防止空闲任务消耗处理时间，从而更有效地将这些时间分配给同样具有优先级0的应用程序任务。第4.12节“调度算法”将详细描述`configIDLE_SHOULD_YIELD`。

以最低优先级运行确保了空闲任务在更高优先级的任务进入就绪状态时，会立即退出*运行*状态。这可以在图4.9中的时间**tn**处看到，空闲任务立即被换出，以允许任务2在离开*阻塞*状态的瞬间执行。可以说任务2抢占了空闲任务。抢占是自动发生的，且被抢占的任务不会察觉到这一点。

> *注意：如果某个任务使用`vTaskDelete()` API函数删除自身，那么必须确保空闲任务不会因为缺乏处理时间而无法运行。这是因为空闲任务负责清理由删除自身的任务所使用的内核资源。*

### 4.8.1 空闲任务钩子函数

可以通过使用空闲钩子（或空闲回调）函数将特定于应用程序的功能直接添加到空闲任务中。空闲钩子函数是由空闲任务在每次循环迭代时自动调用的函数。

空闲任务钩子的常见用途包括：

- 执行低优先级、后台或连续处理功能，而无需为此创建应用程序任务带来的RAM开销。

- 测量空闲处理能力。（空闲任务仅在所有更高优先级的应用程序任务没有工作要执行时运行；因此，测量分配给空闲任务的处理时间可以清晰地表明空闲处理时间。）

- 将处理器置于低功耗模式，提供一种简单且自动的方法，在没有应用程序处理任务时节省功耗（尽管可实现节电效果不如无滴答空闲模式）。

### 4.8.2 空闲任务钩子函数的实现限制

空闲任务钩子函数必须遵守以下规则：

- 空闲任务钩子函数绝不应尝试阻塞或挂起自身。

  *注意：以任何方式阻塞空闲任务都可能导致没有任务能够进入*运行*状态的情况。*

- 如果应用程序任务使用 `vTaskDelete()` API 函数删除自身，那么空闲任务钩子函数必须始终在合理的时间内返回给调用者。这是因为空闲任务负责清理分配给已删除任务的内核资源。如果空闲任务永久停留在空闲钩子函数中，则无法执行此清理操作。

空闲任务钩子函数必须具有如代码清单4.18所示的名称和原型。

<a name="list4.18" title="Listing 4.18 The idle task hook function name and prototype"></a>

```c
void vApplicationIdleHook( void );
```

***代码清单4.18*** *空闲任务钩子函数的名称和原型*

<a name="example4.7" title="Example 4.7 Defining an idle task hook function"></a>
---
***示例4.7*** *定义空闲任务钩子函数</i></h3>

---

在示例4.4中使用阻塞的`vTaskDelay()` API调用产生了大量的空闲时间，即由于两个应用程序任务都处于*阻塞*状态而导致空闲任务执行的时间。示例4.7通过添加一个空闲钩子函数来利用这段空闲时间，其源代码如代码清单4.19所示。

<a name="list4.19" title="Listing 4.19 A very simple Idle hook function"></a>

```c
/* 声明一个将被钩子函数递增的变量。 */
volatile unsigned long ulIdleCycleCount = 0UL;

/*
 * 空闲钩子函数必须命名为 vApplicationIdleHook()，
 * 不接受任何参数，并且返回 void。
 */
void vApplicationIdleHook( void )
{
    /* 该钩子函数仅递增一个计数器。 */
    ulIdleCycleCount++;
}
```

***Listing 4.19*** *一个非常简单的空闲钩子函数*

在 FreeRTOSConfig.h 中，必须将 `configUSE_IDLE_HOOK` 设置为 1，以便调用空闲钩子函数。

实现创建任务的函数经过轻微修改，以输出`ulIdleCycleCount`的值，如代码清单4.20所示。

<a name="list4.20" title="代码清单4.20 示例任务的源代码现在输出ulIdleCycleCount的值"></a>

```c
void vTaskFunction( void * pvParameters )
{
    char * pcTaskName;
    const TickType_t xDelay250ms = pdMS_TO_TICKS( 250 );

    /*
     * 通过参数传递要输出的字符串。将其转换为字符指针。
     */
    pcTaskName = ( char * ) pvParameters;

    /* 与大多数任务一样，此任务在无限循环中实现。 */
    for( ;; )
    {
        /*
         * 输出此任务的名称以及ulIdleCycleCount递增的次数。
         */
        vPrintLineAndNumber( pcTaskName, ulIdleCycleCount );

        /* 延迟250毫秒。 */
        vTaskDelay( xDelay250ms );
    }
}
```

***代码清单4.20*** *示例任务的源代码现在输出ulIdleCycleCount的值*

图4.13显示了示例4.7的输出结果。可以看到，空闲任务钩子函数在应用程序任务的每次迭代之间大约执行了400万次（迭代次数取决于硬件速度）。

<a name="fig4.13" title="图4.13 执行示例4.7时产生的输出"></a>

***

```console
C:\Temp>rtosdemo
Task 2 is running
ulIdleCycleCount = 0
Task 1 is running
ulIdleCycleCount = 0
Task 2 is running
ulIdleCycleCount = 3869504
Task 1 is running
ulIdleCycleCount = 3869504
Task 2 is running
ulIdleCycleCount = 8564623
Task 1 is running
ulIdleCycleCount = 8564623
Task 2 is running
ulIdleCycleCount = 13181489
Task 1 is running
ulIdleCycleCount = 13181489
Task 2 is running
ulIdleCycleCount = 17838406
Task 1 is running
ulIdleCycleCount = 17838406
Task 2 is running
```

***图4.13*** *执行示例4.7时产生的输出*
***


## 4.9 修改任务优先级

### 4.9.1 vTaskPrioritySet() API 函数

`vTaskPrioritySet()` API 函数用于在调度器启动后修改任务的优先级。该函数仅在 FreeRTOSConfig.h 文件中将 `INCLUDE_vTaskPrioritySet` 设置为 1 时可用。


<a name="list4.21" title="Listing 4.21 The vTaskPrioritySet() API function prototype"></a>

```c
void vTaskPrioritySet( TaskHandle_t xTask,
                       UBaseType_t uxNewPriority );
```

***代码清单 4.21*** *vTaskPrioritySet() API 函数原型*

**vTaskPrioritySet() 参数**

- `pxTask`

  需要修改优先级的任务句柄（目标任务）。有关获取任务句柄的信息，请参阅 `xTaskCreate()` API 函数的 `pxCreatedTask` 参数，或 `xTaskCreateStatic()` API 函数的返回值。

  任务可以通过传递 NULL 代替有效的任务句柄来修改自身的优先级。

- `uxNewPriority`

  目标任务将被设置的新优先级。该值会自动被限制为最大可用优先级 `(configMAX_PRIORITIES – 1)`，其中 `configMAX_PRIORITIES` 是在 FreeRTOSConfig.h 头文件中设置的编译时常量。


### 4.9.2 uxTaskPriorityGet() API 函数

`uxTaskPriorityGet()` API 函数用于获取任务的优先级。该函数仅在 FreeRTOSConfig.h 文件中将 `INCLUDE_uxTaskPriorityGet` 设置为 1 时可用。

<a name="list4.22" title="Listing 4.22 The uxTaskPriorityGet() API function prototype"></a>

```c
UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );
```

***代码清单 4.22*** *uxTaskPriorityGet() API 函数原型*

**uxTaskPriorityGet() 参数和返回值**

- `pxTask`

  需要查询优先级的任务的句柄（目标任务）。有关如何获取任务句柄的信息，请参阅 `xTaskCreate()` API 函数的 `pxCreatedTask` 参数，或 `xTaskCreateStatic()` API 函数的返回值。

  任务可以通过传递 NULL 代替有效的任务句柄来查询自身的优先级。

- 返回值

  当前分配给被查询任务的优先级。

<a name="example4.8" title="Example 4.8 Changing task priorities"></a>
---
***示例 4.8*** *更改任务优先级*

---

调度器总是选择最高优先级的 *就绪* 状态任务进入 *运行* 状态。示例 4.8 通过使用 `vTaskPrioritySet()` API 函数来相互更改两个任务的优先级，演示了这一特性。

示例4.8创建了两个不同优先级的任务。这两个任务都没有调用任何可能导致其进入阻塞状态的API函数，因此它们始终处于*就绪*状态或*运行*状态。因此，具有最高相对优先级的任务总是会被调度程序选中进入*运行*状态。

示例4.8的行为如下：

1. 任务1（代码清单4.23）以最高优先级创建，因此它保证会首先运行。任务1打印出几个字符串后，将任务2（代码清单4.24）的优先级提升到高于自身的优先级。

2. 任务2一旦具有最高的相对优先级，便开始运行（进入*运行*状态）。任何时候只能有一个任务处于运行状态，因此当任务2处于*运行*状态时，任务1处于*就绪*状态。

3. 任务2打印出一条消息后，将自己的优先级重新降低至低于任务1的优先级。

4. 当任务2降低其优先级后，任务1再次成为最高优先级的任务，因此任务1重新进入*运行*状态，迫使任务2回到*就绪*状态。

<a name="list4.23" title="清单 4.23 示例 4.8 中任务 1 的实现"></a>

```c
void vTask1( void * pvParameters )
{
    UBaseType_t uxPriority;

    /*
     * 该任务将始终在任务 2 之前运行，因为它的优先级更高。
     * 任务 1 和任务 2 都不会阻塞，因此它们始终处于运行或就绪状态。
     */

    /*
     * 查询该任务的优先级——传入 NULL 表示“返回调用任务的优先级”。
     */
    uxPriority = uxTaskPriorityGet( NULL );

    for( ;; )
    {
        /* 打印该任务的名称。 */
        vPrintLine( "任务 1 正在运行" );

        /*
         * 将任务 2 的优先级设置为高于任务 1 的优先级，将导致
         * 任务 2 立即开始运行（因为任务 2 的优先级将高于
         * 已创建的两个任务）。注意在调用 vTaskPrioritySet()
         * 时使用了任务 2 的句柄（xTask2Handle）。清单 4.25
         * 展示了如何获取该句柄。
         */
        vPrintLine( "即将提高任务 2 的优先级" );
        vTaskPrioritySet( xTask2Handle, ( uxPriority + 1 ) );

        /*
         * 只有当任务 1 的优先级高于任务 2 时，任务 1 才会运行。
         * 因此，任务 1 能够运行到这一点，意味着任务 2 已经执行过，
         * 并将其优先级设置为低于任务 1 的优先级。
         */
    }
}
```

***清单 4.23*** *示例 4.8 中任务 1 的实现*

<a name="list4.24" title="清单 4.24 示例 4.8 中任务 2 的实现"></a>

```c
void vTask2( void * pvParameters )
{
    UBaseType_t uxPriority;

    /*
     * 任务 1 将始终在该任务之前运行，因为任务 1 的优先级更高。
     * 任务 1 和任务 2 都不会阻塞，因此它们始终处于运行或就绪状态。
     *
     * 查询该任务的优先级——传入 NULL 表示“返回调用任务的优先级”。
     */
    uxPriority = uxTaskPriorityGet( NULL );

    for( ;; )
    {
        /*
         * 该任务能够运行到这一点，意味着任务 1 已经运行过，
         * 并将该任务的优先级设置为高于任务 1 的优先级。
         */

         /* 打印该任务的名称。 */
        vPrintLine( "任务 2 正在运行" );

        /*
         * 将该任务的优先级设置回其原始值。
         * 传入 NULL 作为任务句柄表示“更改调用任务的优先级”。
         * 将优先级设置为低于任务 1 的优先级将导致任务 1 立即
         * 再次开始运行——抢占该任务。
         */
        vPrintLine( "即将降低任务 2 的优先级" );
        vTaskPrioritySet( NULL, ( uxPriority - 2 ) );
    }
}
```

***清单 4.24*** *示例 4.8 中任务 2 的实现*

每个任务都可以通过使用 NULL 代替有效的任务句柄来查询和设置自己的优先级。只有当任务希望引用自身以外的任务时（例如任务 1 更改任务 2 的优先级时），才需要任务句柄。为了使任务 1 能够执行此操作，在创建任务 2 时获取并保存了任务 2 的句柄，如清单 4.25 中的注释所强调的。

<a name="list4.25" title="Listing 4.25 The implementation of main() for Example 4.8"></a>

```c
/* 声明一个用于保存任务2句柄的变量。 */
TaskHandle_t xTask2Handle = NULL;

int main( void )
{
    /*
     * 创建优先级为2的第一个任务。任务参数未使用，
     * 因此设置为NULL。任务句柄也未使用，因此同样设置为NULL。
     */
    xTaskCreate( vTask1, "任务1", 1000, NULL, 2, NULL );
    /* 任务的创建优先级为2 ______^. */

    /*
     * 创建优先级为1的第二个任务——该优先级低于任务1。
     * 同样，任务参数未使用，因此设置为NULL。
     * 但这次需要任务句柄，因此将xTask2Handle的地址
     * 作为最后一个参数传入。
     */
    xTaskCreate( vTask2, "任务2", 1000, NULL, 1, &xTask2Handle );
    /* 任务句柄是最后一个参数 _____^^^^^^^^^^^^^ */

    /* 启动调度器，使任务开始执行。 */
    vTaskStartScheduler();

    /*
     * 如果一切正常，main()不会执行到这里，因为调度器
     * 现在正在运行创建的任务。如果main()执行到这里，
     * 则说明没有足够的堆内存来创建空闲任务或定时器任务
     * （本书后续章节会介绍）。第2章提供了有关堆内存管理的更多信息。
     */
    for( ;; )
    {
    }
}
```

***清单 4.25*** *示例 4.8 中 main() 的实现*

图 4.14 展示了示例 4.8 中任务的执行顺序，图 4.15 则显示了运行结果。

<a name="fig4.14" title="图 4.14 运行示例 4.8 时的任务执行顺序"></a>

***
![](media/figure_4.14_example_4.8_execution_sequence.png)
***图 4.14*** *运行示例 4.8 时的任务执行顺序*
***


<a name="fig4.15" title="图 4.15 执行示例 4.8 时产生的输出"></a>

***

```console
Task1 is running
About to raise the Task2 priority
Task2 is running
About to lower the Task2 priority
Task1 is running
About to raise the Task2 priority
Task2 is running
About to lower the Task2 priority
Task1 is running
About to raise the Task2 priority
Task2 is running
About to lower the Task2 priority
Task1 is running
```

***图 4.15*** *执行示例 4.8 时产生的输出*
***


## 4.10 删除任务

### 4.10.1 vTaskDelete() API 函数

`vTaskDelete()` API 函数用于删除任务。只有在 FreeRTOSConfig.h 中将 `INCLUDE_vTaskDelete` 设置为 1 时，`vTaskDelete()` API 函数才可用。

在运行时不断创建和删除任务并不是一个好的做法，因此如果你发现自己需要此功能，请考虑其他设计选项，例如重用任务。

已删除的任务将不复存在，并且无法再次进入*运行*状态。

如果使用动态内存分配创建的任务随后自行删除，则空闲任务负责释放为其分配的内存，例如已删除任务的数据结构和堆栈。因此，在这种情况下，应用程序不能完全剥夺空闲任务的所有处理时间，这一点非常重要。

> *注意：只有内核本身为任务分配的内存会在任务删除时自动释放。在任务实现期间分配的任何内存或其他资源，如果不再需要，必须显式释放。*

<a name="list4.26" title="Listing 4.26 The vTaskDelete() API function prototype"></a>

```c
void vTaskDelete( TaskHandle_t xTaskToDelete );
```

***清单 4.26*** *vTaskDelete() API 函数原型*

**vTaskDelete() 参数**

- `pxTaskToDelete`

  要删除的任务（目标任务）的句柄。有关如何获取任务句柄的信息，请参见`xTaskCreate()` API函数的`pxCreatedTask`参数，以及`xTaskCreateStatic()` API函数的返回值。

任务可以通过传递`NULL`来代替有效的任务句柄来删除自身。

<a name="example4.9" title="示例 4.9 删除任务"></a>
---
***示例 4.9*** *删除任务*

---

这是一个非常简单的示例，其行为如下：

1. 任务1由`main()`创建，优先级为1。当它运行时，它会创建优先级为2的任务2。任务2现在是最高优先级的任务，因此它立即开始执行。清单4.27展示了`main()`的源代码，清单4.28展示了任务1的源代码。

2. 任务2除了删除自身外不做任何其他事情。它可以通过传递`NULL`给`vTaskDelete()`来删除自身，但为了演示目的，它使用了自己的任务句柄。清单4.29展示了任务2的源代码。

3. 当任务2被删除后，任务1再次成为最高优先级的任务，因此它继续执行——此时它调用`vTaskDelay()`来阻塞一小段时间。

4. 当任务1处于阻塞状态时，空闲任务执行并释放已分配给已删除任务2的内存。

1. 当任务1从阻塞状态退出时，它再次成为最高优先级的**就绪**状态任务，因此会抢占空闲任务。当它进入**运行**状态时，它会再次创建任务2，如此循环往复。

<a name="list4.27" title="Listing 4.27 The implementation of main() for Example 4.9"></a>

```c
int main( void )
{
    /* 创建优先级为1的第一个任务。 */
    xTaskCreate( vTask1, "Task 1", 1000, NULL, 1, NULL );

    /* 启动调度器，任务开始执行。 */
    vTaskStartScheduler();

    /* main() 不应该到达这里，因为调度器已经启动。 */
    for( ;; )
    {
    }
}
```

***Listing 4.27*** *示例4.9中main()的实现*

<a name="list4.28" title="Listing 4.28 The implementation of Task 1 for Example 4.9"></a>

```c
TaskHandle_t xTask2Handle = NULL;

void vTask1( void * pvParameters )
{
    const TickType_t xDelay100ms = pdMS_TO_TICKS( 100UL );

    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( "Task 1 is running" );

        /*
         * 创建一个优先级更高的任务2。
         * 将xTask2Handle的地址作为pxCreatedTask参数传递，
         * 以便xTaskCreate将生成的任务句柄写入该变量。
         */
        xTaskCreate( vTask2, "Task 2", 1000, NULL, 2, &xTask2Handle );

        /*
         * 任务2拥有更高的优先级。任务1能执行到这里，说明任务2
         * 已经执行并删除了自己。
         */
        vTaskDelay( xDelay100ms );
    }
}
```

***Listing 4.28*** *示例4.9中任务1的实现*

<a name="list4.29" title="Listing 4.29 The implementation of Task 2 for Example 4.9"></a>

```c
void vTask2( void * pvParameters )
{
    /*
     * 任务2在启动后立即删除自己。
     * 可以通过调用vTaskDelete()并传递NULL参数来实现。
     * 为了演示目的，这里传递它自己的任务句柄。
     */
    vPrintLine( "Task 2 is running and about to delete itself" );
    vTaskDelete( xTask2Handle );
}
```

***Listing 4.29*** *示例4.9中任务2的实现*

<a name="fig4.16" title="Figure 4.16 The output produced when Example 4.9 is executed"></a>

***

```console
C:\Temp>rtosdemo
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
```

***Figure 4.16*** *示例4.9执行时产生的输出*

<a name="fig4.17" title="Figure 4.17 The execution sequence for Example 4.9"></a>

***
![](media/figure_4.17_example_4.9_execution_sequence.png)
***Figure 4.17*** *示例4.9的执行顺序*



## 4.11 线程局部存储与可重入性

线程局部存储（Thread Local Storage）允许应用程序开发者在每个任务的任务控制块中存储任意数据。这一特性最常用于存储通常由不可重入函数存储在全局变量中的数据。

可重入函数是指能够安全地在多个线程中运行而不会产生任何副作用的函数。当在多线程环境中使用不可重入函数而没有使用线程局部存储时，必须特别小心地在临界区内检查这些函数调用的额外结果。过度使用临界区会降低实时操作系统（RTOS）的性能，因此线程局部存储通常比使用临界区更受青睐。

目前，线程局部存储最常见的用途是用于C标准库和POSIX系统中的ISO C标准中的全局变量```errno```。```errno```全局变量用于为常见的标准库函数（如```strtof```和```strtol```）提供扩展结果或错误代码。

### 4.11.1 C 运行时线程本地存储实现

大多数嵌入式 libc 实现提供了 API，以确保非可重入函数在多线程环境中能够正常工作。FreeRTOS 包含了对两个常用开源库的可重入 API 的支持：[newlib](https://sourceware.org/newlib/) 和 [picolibc](https://github.com/picolibc/picolibc)。可以通过在项目的 FreeRTOSConfig.h 文件中定义以下宏来启用这些预构建的 C 运行时线程本地存储实现：

- ```configUSE_NEWLIB_REENTRANT``` 用于 [newlib](https://sourceware.org/newlib/)
- ```configUSE_PICOLIBC_TLS``` 用于 [picolibc](https://github.com/picolibc/picolibc)

### 4.11.2 自定义 C 运行时线程本地存储

应用程序开发者可以通过在 FreeRTOSConfig.h 文件中定义以下宏来实现线程本地存储：

- 将 ```configUSE_C_RUNTIME_TLS_SUPPORT``` 定义为 1 以启用 C 运行时线程本地存储支持。

- 将 ```configTLS_BLOCK_TYPE``` 定义为用于存储 C 运行时线程本地存储数据的 C 类型。

- 将 ```configINIT_TLS_BLOCK``` 定义为初始化 C 运行时线程本地存储块时应运行的 C 代码。

- 将 ```configSET_TLS_BLOCK``` 定义为切换新任务时应运行的 C 代码。

- 将 ```configDEINIT_TLS_BLOCK``` 定义为取消初始化 C 运行时线程本地存储块时应运行的 C 代码。

### 4.11.3 应用程序线程本地存储

除了C运行时的线程本地存储外，应用程序开发者还可以定义一组特定于应用程序的指针，这些指针将被包含在任务控制块中。通过在项目的FreeRTOSConfig.h文件中将```configNUM_THREAD_LOCAL_STORAGE_POINTERS```设置为非零值来启用此功能。

运行时，可以使用清单4.30中定义的```vTaskSetThreadLocalStoragePointer```和```pvTaskGetThreadLocalStoragePointer```函数分别设置和获取每个线程本地存储指针的值。

<a name="list4.30" title="清单4.30 线程本地存储指针API函数的函数原型"></a>

```c
void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
                                           BaseType_t xIndex )

void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
                                        BaseType_t xIndex,
                                        void * pvValue );
```

***清单4.30*** *线程本地存储指针API函数的函数原型*


## 4.12 调度算法

### 4.12.1 任务状态与事件回顾

实际正在运行（占用处理时间）的任务处于*运行*（Running）状态。在单核处理器上，任何时刻只能有一个任务处于*运行*状态。FreeRTOS 也可以在多核处理器上运行（非对称多处理，AMP），或者让 FreeRTOS 在多个核心上调度任务（对称多处理，SMP）。这些场景此处不作讨论。

未实际运行但既不处于阻塞（Blocked）状态也不处于挂起（Suspended）状态的任务处于*就绪*（Ready）状态。处于*就绪*状态的任务可以被调度器选中进入*运行*状态。调度器总是选择优先级最高的*就绪*状态任务进入*运行*状态。

任务可以在*阻塞*（Blocked）状态中等待事件，当事件发生时，它们会自动回到*就绪*状态。时间事件在特定时间发生，例如当阻塞时间到期时，通常用于实现周期性或超时行为。同步事件发生在任务或中断服务例程使用任务通知、队列、事件组、消息缓冲区、流缓冲区或某种信号量发送信息时，通常用于通知异步活动，例如数据到达外设。


### 4.12.2 选择调度算法

调度算法是决定将哪个处于*就绪*状态的任务切换到*运行*状态的软件例程。

到目前为止的所有示例都使用了相同的调度算法，但可以通过`configUSE_PREEMPTION`和`configUSE_TIME_SLICING`配置常量来更改算法。这两个常量均在FreeRTOSConfig.h中定义。

第三个配置常量`configUSE_TICKLESS_IDLE`也会影响调度算法，因为它的使用可能导致滴答中断在较长时间内完全关闭。`configUSE_TICKLESS_IDLE`是一个高级选项，专门用于需要最小化功耗的应用程序。本节中的描述假设`configUSE_TICKLESS_IDLE`设置为0，这是常量为定义时的默认设置。

在所有可能的单核配置中，FreeRTOS调度器轮流选择共享优先级的任务。这种“轮流”策略通常被称为“轮询调度”。轮询调度算法不保证相同优先级任务之间的时间均等分配，仅保证相同优先级的*就绪*状态任务轮流进入*运行*状态。

<a name="tbl5" title="表5 用于配置内核调度算法的FreeRTOSConfig.h设置"></a>

***
| 调度算法            | 优先级化 | `configUSE_PREEMPTION` | `configUSE_TIME_SLICING` |
|---------------------|----------|------------------------|--------------------------|
| 带时间片抢占式      | 是       | 1 | 1   |
| 不带时间片抢占式    | 是       | 1 | 0   |
| 协作式              | 否       | 0 | 任意 |

***表5*** *用于配置内核调度算法的FreeRTOSConfig.h设置*
* * *

### 4.12.3 带时间片抢占的优先级调度

表5中所示的配置将FreeRTOS调度器设置为使用一种称为“带时间片的固定优先级抢占式调度”的调度算法。这是大多数小型RTOS应用程序使用的调度算法，也是到目前为止本书中所有示例所使用的算法。下表提供了该算法名称中所用术语的描述。

**调度策略术语解释：**

- 固定优先级 (Fixed Priority)

  被描述为“固定优先级”的调度算法不会改变分配给被调度任务的优先级，但也不阻止任务自身改变其优先级或其他任务的优先级。

- 抢占式 (Preemptive)

  抢占式调度算法会在优先级高于当前*运行*状态任务的任务进入*就绪*状态时，立即“抢占”当前*运行*状态任务。被抢占意味着任务被强制从*运行*状态移动到*就绪*状态（无需显式地让出或阻塞），以允许其他任务进入*运行*状态。任务抢占可以随时发生，而不仅仅是在RTOS时钟中断时。

- 时间片轮转

  时间片轮转用于在优先级相同的任务之间共享处理时间，
  即使任务没有显式地让出CPU或进入*阻塞*状态。
  被描述为使用*时间片轮转*的调度算法会在每个时间片结束时选择一个新任务进入*运行*状态，
  如果存在与当前运行任务优先级相同的*就绪*状态任务。一个时间片等于两次RTOS时钟中断之间的时间。

图4.18和图4.19展示了在使用带时间片轮转的固定优先级抢占式调度算法时任务是如何被调度的。
图4.18显示了当应用程序中的所有任务都具有唯一优先级时，任务被选择进入*运行*状态的顺序。
图4.19显示了当应用程序中的两个任务共享优先级时，任务被选择进入*运行*状态的顺序。


<a name="fig4.18" title="图4.18 任务优先级和抢占的执行模式..."></a>

***
![](media/figure_4.18_preemption_execution_pattern.png)
***图4.18*** *在一个假设的应用程序中，每个任务都被分配了唯一优先级，展示任务优先级和抢占的执行模式*
***

参考图4.18：

- 空闲任务

  空闲任务以最低优先级运行，因此每次有更高优先级的任务进入*就绪*状态时，它都会被抢占，
  例如在时间t3、t5和t9。

- 任务3

  任务3是一个事件驱动任务，它以相对较低的优先级执行，但优先级高于空闲任务。它大部分时间都处于*阻塞*状态，等待其感兴趣的事件。每次事件发生时，它会从*阻塞*状态转换到*就绪*状态。所有FreeRTOS任务间通信机制（任务通知、队列、信号量、事件组等）都可以用来通知事件并以这种方式解除任务的阻塞。

  事件在t3和t5时刻发生，并且在t9到t12之间的某个时刻也会发生。在t3和t5时刻发生的事件会立即被处理，因为在这些时刻，任务3是能够运行的优先级最高的任务。而在t9到t12之间发生的事件直到t12时刻才会被处理，因为在此之前，更高优先级的任务1和任务2仍在执行。只有在t12时刻，任务1和任务2都处于*阻塞*状态，任务3才成为优先级最高的*就绪*状态任务。

- 任务2

  任务2是一个周期性任务，其执行优先级高于任务3，但低于任务1。该任务的周期间隔意味着任务2希望在时间t1、t6和t9时执行。

  在时间t6，任务3处于*运行*状态，但任务2具有更高的相对优先级，因此抢占任务3并立即开始执行。任务2在时间t7完成处理并重新进入*阻塞*状态，此时任务3可以重新进入*运行*状态以完成其处理。任务3本身在时间t8进入阻塞状态。

- 任务1

  任务1也是一个事件驱动任务。它以系统中的最高优先级执行，因此可以抢占任何其他任务。唯一显示的任务1事件发生在时间t10，此时任务1抢占任务2。任务2只有在任务1在时间t11重新进入*阻塞*状态后才能完成其处理。


<a name="fig4.19" title="图4.19 任务优先级和时间片的执行模式..."></a>

***
![](media/figure_4.19_time_slicing_execution_pattern.png)
***图4.19*** *执行模式展示了任务优先级和时间片在一个假设应用中的应用，其中两个任务以相同的优先级运行*
***

参考图4.19：

- 空闲任务和任务2

  空闲任务和任务2都是连续处理任务，并且它们的优先级均为0（最低可能的优先级）。调度器仅在没有任何更高优先级的任务能够运行时，才会将处理时间分配给优先级为0的任务，并通过时间片分配这些时间。每个时钟中断时开始一个新的时间片，在图4.19中，时钟中断发生在时间t1、t2、t3、t4、t5、t8、t9、t10和t11。

空闲任务和任务2依次进入*运行*状态，这可能导致两个任务在同一时间片内的部分时间内都处于*运行*状态，如时间t5到时间t8之间所示。

- 任务1

  任务1的优先级高于空闲任务的优先级。任务1是一个事件驱动的任务，大部分时间处于*阻塞*状态，等待其感兴趣的事件。每次事件发生时，任务1从*阻塞*状态转换到*就绪*状态。

  感兴趣的事件在时间t6发生。在t6时刻，任务1成为能够运行的优先级最高的任务，因此任务1在时间片中途抢占空闲任务。事件的处理在时间t7完成，此时任务1重新进入*阻塞*状态。

图4.19展示了空闲任务与应用程序开发者创建的任务共享处理时间。如果应用程序开发者创建的空闲优先级任务有工作要做，而空闲任务没有工作，那么将如此多的处理时间分配给空闲任务可能并不理想。编译时配置常量`configIDLE_SHOULD_YIELD`可用于更改空闲任务的调度方式：

- 如果`configIDLE_SHOULD_YIELD`设置为0，则空闲任务在其整个时间片内保持*运行*状态，除非被更高优先级的任务抢占。

- 如果 `configIDLE_SHOULD_YIELD` 设置为 1，则空闲任务在其循环的每次迭代中都会让出（自愿放弃其分配的时间片剩余部分），前提是存在其他处于 *就绪* 状态的空闲优先级任务。

图 4.19 中所示的执行模式是在 `configIDLE_SHOULD_YIELD` 设置为 0 时观察到的。图 4.20 中所示的执行模式是在相同场景下，当 `configIDLE_SHOULD_YIELD` 设置为 1 时观察到的。


<a name="fig4.20" title="图 4.20 相同场景下的执行模式，如图 4.19 所示..."></a>

***
![](media/figure_4.20_time_slicing_with_yield_execution_pattern.png)
***图 4.20*** *与图 4.19 所示相同场景下的执行模式，但这次 `configIDLE_SHOULD_YIELD` 设置为 1*
***

图 4.20 还显示，当 `configIDLE_SHOULD_YIELD` 设置为 1 时，在空闲任务之后被选中进入 *运行* 状态的任务不会执行整个时间片，而是执行空闲任务让出时剩余的时间片部分。

### 4.12.4 不带时间片的优先级抢占式调度

不带时间片的优先级抢占式调度保留了上一节中描述的任务选择和抢占算法，但不使用时间片来在相同优先级的任务之间共享处理时间。

表5展示了配置FreeRTOS调度器使用不带时间片的优先级抢占式调度的`FreeRTOSConfig.h`设置。

正如图4.19所示，如果使用时间片，并且有多个最高优先级的任务处于就绪状态且能够运行，那么调度器会在每个RTOS滴答中断（标记时间片结束的中断）时选择一个新的任务进入*运行*状态。如果不使用时间片，则调度器仅在以下情况下选择一个新的任务进入*运行*状态：

- 一个更高优先级的任务进入*就绪*状态。

- 当前处于*运行*状态的任务进入*阻塞*或*挂起*状态。

不使用时间片时，任务上下文切换的次数比使用时间片时要少。因此，关闭时间片可以减少调度器的处理开销。然而，关闭时间片也可能导致相同优先级的任务获得差异极大的处理时间，图4.21展示了这种情况。因此，不使用时间片的调度被认为是一种高级技术，仅应由有经验的用户使用。

<a name="fig4.21" title="图4.21 展示了在不使用时间片时，相同优先级的任务可能获得极大差异的处理时间的执行模式"></a>

***
![](media/figure_4.21_equal_priority_without_time_slicing_execution_pattern.png)
***图4.21*** *展示了在不使用时间片时，相同优先级的任务可能获得极大差异的处理时间的执行模式*
***

参考图4.21，假设`configIDLE_SHOULD_YIELD`设置为0：

- 滴答中断

  滴答中断发生在t1、t2、t3、t4、t5、t8、t11、t12和t13时刻。

- 任务1

  任务1是一个高优先级的事件驱动任务，大部分时间处于*阻塞*状态，等待其感兴趣的事件。每次事件发生时，任务1从*阻塞*状态转换到*就绪*状态（随后，由于它是最高优先级的*就绪*状态任务，进入*运行*状态）。图4.21展示了任务1在t6到t7之间以及t9到t10之间处理事件。

- 空闲任务和任务2

  空闲任务和任务2都是持续处理任务，且优先级均为0（空闲优先级）。持续处理任务不会进入*阻塞*状态。

  由于未使用时间片，处于*运行*状态的空闲优先级任务将保持*运行*状态，直到被更高优先级的任务1抢占。

  在图4.21中，空闲任务在t1时刻开始运行，并保持在*运行*状态，直到在t6时刻被任务1抢占，此时距离它进入*运行*状态已经超过了四个完整的滴答周期。

  任务2在t7时刻开始运行，此时任务1重新进入*阻塞*状态等待下一个事件。任务2保持在*运行*状态，直到在t9时刻被任务1抢占，此时距离它进入*运行*状态不到一个滴答周期。

  在t10时刻，空闲任务重新进入*运行*状态，尽管它已经获得了比任务2多四倍以上的处理时间。

### 4.12.5 协作式调度

本书主要关注抢占式调度，但 FreeRTOS 也可以使用协作式调度。表 5 展示了通过 `FreeRTOSConfig.h` 设置将 FreeRTOS 调度器配置为使用协作式调度的相关配置。

在使用协作式调度器时（并假设应用程序提供的中断服务例程不显式请求上下文切换），上下文切换仅在以下情况下发生：运行状态的任务进入 *阻塞* 状态，或者运行状态的任务通过调用 `taskYIELD()` 显式让出 CPU（手动请求重新调度）。任务不会被抢占，因此无法使用时间片轮转。

图 4.22 展示了协作式调度器的行为模式。图 4.22 中的水平虚线表示任务处于就绪状态的时间点。

<a name="fig4.22" title="图 4.22 演示协作式调度器行为的执行模式"></a>

***
![](media/figure_4.22_cooperative_scheduler_execution_pattern.png)
***图 4.22*** *演示协作式调度器行为的执行模式*
***

参考图 4.22：

- 任务 1

  任务 1 具有最高优先级。它从 *阻塞* 状态开始，等待一个信号量。

在时间t3，一个中断释放了信号量，导致任务1离开*阻塞*状态并进入*就绪*状态（从中断中释放信号量的内容将在第6章中介绍）。

在时间t3，任务1是优先级最高的*就绪*状态任务，如果使用了抢占式调度器，任务1将成为*运行*状态任务。然而，由于当前使用的是协作式调度器，任务1将保持在*就绪*状态，直到时间t4，即*运行*状态任务调用`taskYIELD()`时。

- 任务2

任务2的优先级介于任务1和任务3之间。它最初处于*阻塞*状态，等待任务3在时间t2发送给它的消息。

在时间t2，任务2是优先级最高的*就绪*状态任务，如果使用了抢占式调度器，任务2将成为*运行*状态任务。然而，由于当前使用的是协作式调度器，任务2将保持在*就绪*状态，直到*运行*状态任务进入*阻塞*状态或调用`taskYIELD()`。

*运行*状态的任务在时间t4调用了`taskYIELD()`，但此时任务1是优先级最高的*就绪*状态任务，因此任务2实际上要等到任务1在时间t5重新进入*阻塞*状态后，才能成为*运行*状态的任务。

在时间t6，任务2重新进入*阻塞*状态以等待下一条消息，此时任务3再次成为优先级最高的*就绪*状态任务。

在多任务应用程序中，开发者必须确保资源不会被多个任务同时访问，因为同时访问可能会导致资源损坏。以下是一个示例场景：被访问的资源是一个UART（串口）。两个任务向UART写入字符串；任务1写入"abcdefghijklmnop"，任务2写入"123456789"：

1. 任务1处于*运行*状态并开始写入其字符串。它向UART写入了"abcdefg"，但在写入更多字符之前离开了*运行*状态。

2. 任务2进入*运行*状态并向UART写入"123456789"，然后离开*运行*状态。

1. 任务1重新进入*运行*状态，并将其字符串的剩余字符写入UART。

在这种情况下，实际写入UART的内容是"abcdefg123456789hijklmnop"。任务1写入的字符串并未像预期那样以连续的顺序写入UART，而是被破坏了，因为任务2写入UART的字符串出现在其中。

使用协作式调度器通常比使用抢占式调度器更容易避免由同时访问引起的问题[^7]：

[^7]: 本书后面会介绍在任务之间安全共享资源的方法。FreeRTOS本身提供的资源（如队列和信号量）始终可以在任务之间安全共享。

- 使用抢占式调度器时，处于*运行*状态的任务可能在任何时候被抢占，包括当它与其他任务共享的资源处于不一致状态时。正如UART示例所展示的那样，使资源处于不一致状态可能导致数据损坏。

- 当你使用协作式调度器时，你可以控制何时切换到另一个任务。因此，你可以确保当一个资源处于不一致状态时，不会发生切换到另一个任务的情况。

- 在上述UART示例中，你可以确保任务1在将其整个字符串写入UART之前不会离开*运行*状态，从而消除该字符串被另一个任务的活动破坏的可能性。

如图4.22所示，使用协作式调度器会使系统的响应速度低于使用抢占式调度器时的响应速度：

- 当使用抢占式调度器时，调度器会在任务成为最高优先级的*就绪*状态任务时立即开始运行该任务。这在实时系统中通常是必不可少的，因为实时系统必须在规定的时间内响应高优先级事件。

- 当使用协作式调度器时，只有当*运行*状态的任务进入*阻塞*状态或调用`taskYIELD()`时，才会切换到已成为最高优先级*就绪*状态的任务。



