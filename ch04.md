# 4 任务管理

## 4.1 引言

### 4.1.1 范围

本章涵盖以下内容：

- FreeRTOS如何为应用程序中的每个任务分配处理时间。
- FreeRTOS如何选择在任何给定时间应执行哪个任务。
- 每个任务的相对优先级如何影响系统行为。
- 任务可以存在的状态。

本章还讨论以下内容：

- 如何实现任务。
- 如何创建一个或多个任务实例。
- 如何使用任务参数。
- 如何更改已创建任务的优先级。
- 如何删除任务。
- 如何使用任务实现周期性处理。（后续章节描述了如何使用软件定时器实现相同功能。）
- 空闲任务何时执行以及如何使用它。

本章介绍的概念是理解如何使用FreeRTOS以及FreeRTOS应用程序行为的基础。因此，这是本书中最详细的章节。

## 4.2 任务函数

任务作为C函数实现。任务必须实现如清单4.1所示的预期函数原型，该原型接受一个void指针参数并返回void。

<a name="list4.1" title="清单4.1 任务函数原型"></a>

```c
void vATaskFunction( void * pvParameters );
```

***清单4.1*** *任务函数原型*

每个任务本身都是一个小程序。它有一个入口点，通常会在一个无限循环中永远运行，并且不会退出。清单4.2显示了一个典型任务的结构。

FreeRTOS任务不得以任何方式从实现它的函数返回。它不得包含“return”语句，也不得允许执行超出其实现函数的末尾。如果不再需要任务，应像清单4.2中所示明确删除它。

一个任务函数定义可以用来创建任意数量的任务，其中每个创建的任务都是一个单独的执行实例。每个实例都有自己的堆栈，因此它有自己的任何在任务本身中定义的自动（堆栈）变量的副本。

<a name="list4.2" title="清单4.2 典型任务函数的结构"></a>

```c
void vATaskFunction( void * pvParameters )
{
    /*
     * 当在函数内部时，可以正常声明堆栈分配的变量。
     * 使用此示例函数创建的每个任务实例都将在任务的堆栈上分配自己的lStackVariable的单独实例。
     */
    long lStackVariable = 0;

    /*
     * 与堆栈分配的变量相反，使用`static`关键字声明的变量由链接器分配到内存中的特定位置。
     * 这意味着调用vATaskFunction的所有任务都将共享lStaticVariable的相同实例。
     */
    static long lStaticVariable = 0;

    for( ;; )
    {
        /* 实现任务功能的代码将放在这里。 */
    }

    /*
     * 如果任务实现永远退出上述循环，则必须在到达其实现函数的末尾之前删除任务。
     * 当将NULL作为参数传递给vTaskDelete() API函数时，这表明要删除的任务是调用（此）任务。
     */
    vTaskDelete( NULL );
}
```

***清单4.2*** *典型任务函数的结构*

## 4.3 顶层任务状态

一个应用程序可能包含许多任务。如果运行应用程序的处理器包含单个核心，那么在任何给定时间只能执行一个任务。这意味着一个任务可能处于两种状态之一：*运行中*和*未运行*。首先考虑这个简化的模型。本章后面将描述*未运行*状态的几个子状态。

当处理器正在执行该任务的代码时，任务处于*运行中*状态。当任务处于*未运行*状态时，任务被暂停，并且其状态已保存，以便在调度程序决定它应该进入*运行中*状态的下一次时恢复执行。当任务恢复执行时，它将从离开*运行中*状态之前即将执行的指令继续执行。

<a name="fig4.1" title="图4.1 顶层任务状态和转换"></a>

***
![](media/figure_4.1_top_level_task_states.png)
***图4.1*** *顶层任务状态和转换*
***

从*未运行*状态转换到*运行中*状态的任务被称为“切换进”或“交换进”。相反，从*运行中*状态转换到*未运行*状态的任务被称为“切换出”或“交换出”。FreeRTOS调度程序是唯一可以将任务切换进和切换出*运行中*状态的实体。

## 4.4 任务创建

可以使用六个API函数来创建任务：
`xTaskCreate()`，
`xTaskCreateStatic()`，
`xTaskCreateRestricted()`，
`xTaskCreateRestrictedStatic()`，
`xTaskCreateAffinitySet()`，和
`xTaskCreateStaticAffinitySet()`

每个任务需要两块RAM：一块用于存储其任务控制块（TCB），另一块用于存储其堆栈。带有“Static”名称的FreeRTOS API函数使用作为参数传递给函数的预分配的RAM块。相反，没有“Static”名称的API函数在运行时从系统堆中动态分配所需的RAM。

某些FreeRTOS端口支持在“受限”或“非特权”模式下运行任务。带有“Restricted”名称的FreeRTOS API函数创建具有对系统内存受限访问权限的任务。没有“Restricted”名称的API函数创建在“特权模式”下执行的任务，并且可以访问系统的整个内存映射。

支持对称多处理（SMP）的FreeRTOS端口允许不同的任务同时在同一CPU的多个核心上运行。对于这些端口，可以使用带有“Affinity”名称的函数指定任务将在哪个核心上运行。

FreeRTOS任务创建API函数非常复杂。本文档中的大多数示例使用`xTaskCreate()`，因为它是这些函数中最简单的。

### 4.4.1 xTaskCreate() API 函数

清单 4.3 显示了 `xTaskCreate()` API 函数原型。
`xTaskCreateStatic()` 有两个额外的参数，分别指向预分配的内存，用于保存任务的数据结构和栈。
[第 2.5 节：数据类型和编码风格指南](ch02.md#25-data-types-and-coding-style-guide) 描述了使用的数据类型和命名约定。

<a name="list4.3" title="清单 4.3 xTaskCreate() API 函数原型"></a>

```c
BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,
                        const char * const pcName,
                        configSTACK_DEPTH_TYPE usStackDepth,
                        void * pvParameters,
                        UBaseType_t uxPriority,
                        TaskHandle_t * pxCreatedTask );
```

***清单 4.3*** *xTaskCreate() API 函数原型*

**xTaskCreate() 参数和返回值：**

- `pvTaskCode`

  任务只是永不退出的 C 函数，因此通常实现为无限循环。`pvTaskCode` 参数只是指向实现任务的函数的指针（实际上只是函数的名称）。

- `pcName`

  任务的描述性名称。FreeRTOS不会以任何方式使用它，它纯粹是作为调试辅助工具包含的。通过人类可读的名称标识任务比通过其句柄标识它要简单得多。

  应用程序定义的常量 `configMAX_TASK_NAME_LEN` 定义了任务名称的最大长度，包括NULL终止符。提供更长的字符串将导致字符串被截断。

- `usStackDepth`

  指定为任务使用的堆栈的大小。使用 `xTaskCreateStatic()` 而不是 `xTaskCreate()` 以使用预分配的内存而不是动态分配的内存。

  注意，值指定堆栈可以容纳的单词数，而不是字节数。例如，如果堆栈是32位宽，并且 `usStackDepth` 是128，那么 `xTaskCreate()` 分配512字节的堆栈空间（128 * 4字节）。

  `configSTACK_DEPTH_TYPE` 是一个宏，允许应用程序编写器指定用于保存堆栈大小的数据类型。如果未定义，`configSTACK_DEPTH_TYPE` 默认为 `uint16_t`，因此在 `FreeRTOSConfig.h` 中将 `configSTACK_DEPTH_TYPE` 定义为 `unsigned long` 或 `size_t`，如果堆栈深度乘以堆栈宽度大于65535（最大可能的16位数）。

- [第13.3节 栈溢出](ch13.md#133-stack-overflow)，描述了一种选择最佳栈大小的实用方法。

- `pvParameters`

  实现任务的函数接受一个单一的空指针（`void *`）参数。`pvParameters` 是通过该参数传递给任务的值。

- `uxPriority`

  定义任务的优先级。0 是最低优先级，`(configMAX_PRIORITIES – 1)` 是最高优先级。[第4.5节](#45-task-priorities) 描述了用户定义的 `configMAX_PRIORITIES` 常量。

  如果定义了一个大于 `(configMAX_PRIORITIES – 1)` 的 `uxPriority`，它将被限制为 `(configMAX_PRIORITIES – 1)`。

- `pxCreatedTask`

  指向存储创建任务的句柄的位置的指针。此句柄可以在未来的API调用中使用，例如更改任务的优先级或删除任务。

  `pxCreatedTask` 是一个可选参数，如果不需要任务的句柄，可以将其设置为 NULL。

- 返回值

  有两种可能的返回值：

  - `pdPASS`

    这表示任务已成功创建。

- `pdFAIL`

    这表示没有足够的堆内存来创建任务。[第3章](ch03.md#3-heap-memory-management) 提供了更多关于堆内存管理的信息。

<a name="example4.1" title="示例 4.1 创建任务"></a>
---
***示例 4.1*** *创建任务*

---

以下示例演示了创建两个简单任务并启动新创建的任务所需的步骤。这些任务通过使用粗略的忙等待循环来创建周期延迟，定期打印出一个字符串。这两个任务具有相同的优先级，除了它们打印的字符串不同——请参阅它们各自的实现，见清单 4.4 和清单 4.5。请参阅第8章，了解在任务中使用 `printf()` 的警告。

<a name="list4.4" title="清单 4.4 示例 4.1 中使用的第一个任务的实现"></a>

```c
void vTask1( void * pvParameters )
{
    /* ulCount 声明为 volatile 以确保它不会被优化掉。 */
    volatile unsigned long ulCount;

    for( ;; )
    {
        /* 打印当前任务的名称。 */
        vPrintLine( "Task 1 is running" );

        /* 延迟一段时间。 */
        for( ulCount = 0; ulCount < mainDELAY_LOOP_COUNT; ulCount++ )
        {
            /*
             * 这个循环只是一个非常粗略的延迟实现。这里没有什么要做的。后面的示例将用一个合适的延迟/睡眠函数替换这个粗略的循环。
             */
        }
    }
}
```

***清单 4.4*** *示例 4.1 中使用的第一个任务的实现*

<a name="list4.5" title="清单 4.5 示例 4.1 中使用的第二个任务的实现"></a>

```c
void vTask2( void * pvParameters )
{
    /* ulCount 声明为 volatile 以确保它不会被优化掉。 */
    volatile unsigned long ulCount;

    /* 与大多数任务一样，这个任务在一个无限循环中实现。 */
    for( ;; )
    {
        /* 打印这个任务的名称。 */
        vPrintLine( "Task 2 is running" );

        /* 延迟一段时间。 */
        for( ulCount = 0; ulCount < mainDELAY_LOOP_COUNT; ulCount++ )
        {
            /*
             * 这个循环只是一个非常粗略的延迟实现。这里没有什么要做的。后面的示例将用一个合适的延迟/睡眠函数替换这个粗略的循环。
             */
        }
    }
}
```

***清单 4.5*** *示例 4.1 中使用的第二个任务的实现*

`main()` 函数在启动调度程序之前创建任务——请参阅其实现，见清单 4.6。

<a name="list4.6" title="清单 4.6 启动示例 4.1 任务"></a>

```c
int main( void )
{
    /*
     * 在启动 FreeRTOS 调度器后，这里声明的变量可能不再存在。不要尝试从任务中访问 main() 使用的堆栈上声明的变量。
     */

    /*
     * 创建两个任务之一。请注意，实际应用程序应检查 xTaskCreate() 调用的返回值，以确保任务创建成功。
     */
    xTaskCreate( vTask1,  /* 指向实现任务的函数的指针。*/
                 "任务 1",/* 任务的文本名称。 */
                 1000,    /* 堆栈深度（以字为单位）。 */
                 NULL,    /* 此示例不使用任务参数。 */
                 1,       /* 此任务将以优先级 1 运行。 */
                 NULL );  /* 此示例不使用任务句柄。 */

    /* 以完全相同的方式和相同的优先级创建另一个任务。*/
    xTaskCreate( vTask2, "任务 2", 1000, NULL, 1, NULL );

    /* 启动调度器以开始执行任务。 */
    vTaskStartScheduler();

    /*
     * 如果一切正常，main() 将不会到达这里，因为调度器现在将运行创建的任务。如果 main() 到达这里，则没有足够的堆内存来创建空闲或计时器任务
     * （本书后面描述）。第 3 章提供了有关堆内存管理的更多信息。
     */
    for( ;; );
}
```

***清单 4.6*** *启动示例 4.1 任务*

执行示例将产生图 4.2 中显示的输出。

<a name="fig4.2" title="图 4.2 执行示例 4.1 时生成的输出"></a>

***

```console
C:\Temp>rtosdemo
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
```

***图 4.2*** *执行示例 4.1 时生成的输出[^4]*

***

[^4]: 屏幕截图显示每个任务在下一个任务执行之前都会打印出其消息。这是一个人为的场景，是使用 FreeRTOS Windows 模拟器的结果。Windows 模拟器并不是真正的实时系统。此外，向 Windows 控制台写入数据需要相对较长的时间，并导致一系列 Windows 系统调用。在一个真正的嵌入式目标上执行相同的代码，并且具有快速且非阻塞的打印函数，可能会导致每个任务在被切换出以允许其他任务运行之前多次打印其字符串。

图 4.2 显示了两个任务看似同时执行；然而，两个任务都在同一个处理器核心上执行，所以这不可能是事实。实际上，两个任务都在快速进入和退出*运行*状态。两个任务都在同一优先级下运行，因此共享同一个处理器核心的时间。图 4.3 显示了它们的实际执行模式。

图 4.3 底部的箭头显示了从时间 t1 开始的时间流逝。彩色线条显示了每个时间点正在执行的任务——例如，任务 1 在 t1 和 t2 之间执行。

任何时候只能有一个任务处于*运行*状态。因此，当一个任务进入*运行*状态（任务被切换进来）时，另一个任务进入*未运行*状态（任务被切换出去）。

<a name="fig4.3" title="图 4.3 示例 4.1 的两个任务的实际执行模式"></a>

***
![](media/figure_4.3_example_4.1_execution_pattern.png)
***图 4.3*** *示例 4.1 的两个任务的实际执行模式*
***

示例 4.1 在 `main()` 内部创建了两个任务，然后启动调度程序。也可以在另一个任务内部创建任务。例如，任务 2 可以在任务 1 内部创建，如清单 4.7 所示。

<a name="list4.7" title="在调度器启动后从另一个任务中创建任务"></a>

```c
void vTask1( void * pvParameters )
{
    const char *pcTaskName = "Task 1 is running\r\n";
    volatile unsigned long ul; /* volatile to ensure ul is not optimized away. */

    /*
     * If this task code is executing then the scheduler must already have
     * been started. Create the other task before entering the infinite loop.
     */
    xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL );

    for( ;; )
    {
        /* Print out the name of this task. */
        vPrintLine( pcTaskName );

        /* Delay for a period. */
        for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
        {
            /*
             * This loop is just a very crude delay implementation. There is
             * nothing to do in here. Later examples will replace this crude
             * loop with a proper delay/sleep function.
             */
        }
    }
}
```

***Listing 4.7*** *在调度器启动后从另一个任务中创建任务*

<a name="example4.2" title="示例 4.2 使用任务参数"></a>
---
***Example 4.2*** *使用任务参数*

---

在示例 4.1 中创建的两个任务几乎相同，它们之间唯一的区别是它们打印的文本字符串。如果创建一个单一任务实现的两个实例，并使用任务参数将字符串传递给每个实例，这将消除重复。

示例 4.2 将示例 4.1 中使用的两个任务函数替换为一个名为 `vTaskFunction()` 的单个任务函数，如清单 4.8 所示。请注意任务参数被强制转换为 `char *` 以获取任务应打印的字符串。

<a name="list4.8" title="清单 4.8 示例 4.2 中用于创建两个任务的单个任务函数"></a>

```c
void vTaskFunction( void * pvParameters )
{

    char *pcTaskName;
    volatile unsigned long ul; /* volatile 以确保 ul 不被优化掉。 */

    /*
     * 通过参数传递要打印的字符串。将此强制转换为字符指针。
     */
    pcTaskName = ( char * ) pvParameters;

    /* 与大多数任务一样，此任务在无限循环中实现。 */
    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( pcTaskName );

        /* 延迟一段时间。 */
        for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
        {
            /*
             * 此循环只是一个非常粗糙的延迟实现。这里没有要做的事情。稍后的练习将用一个适当的延迟/睡眠函数替换这个粗糙的循环。
             */
        }
    }
}
```

***清单 4.8*** *示例 4.2 中用于创建两个任务的单个任务函数*

清单 4.9 创建了两个由 `vTaskFunction()` 实现的任务实例，使用任务的参数将不同的字符串传递给每个任务。两个任务在 FreeRTOS 调度器的控制下独立执行，并且各自拥有自己的堆栈，因此拥有 `pcTaskName` 和 `ul` 变量的各自副本。

<a name="list4.9" title="Listing 4.9 The main() function for Example 2"></a>

```c
/*
 * 定义将作为任务参数传递的字符串。这些字符串被定义为const，而不是在main()使用的堆栈上，以确保在任务执行时它们保持有效。
 */
static const char * pcTextForTask1 = "Task 1 is running";
static const char * pcTextForTask2 = "Task 2 is running";

int main( void )
{
    /*
     * 在此声明的变量在启动FreeRTOS调度程序后可能不再存在。不要尝试从任务中访问在main()使用的堆栈上声明的变量。
     */

    /* 创建两个任务之一。 */
    xTaskCreate( vTaskFunction,             /* 指向实现任务的函数的指针。 */
                 "Task 1",                  /* 任务的文本名称。这仅用于调试。 */
                 1000,                      /* 堆栈深度 - 小型微控制器将使用比这少得多的堆栈。*/
                 ( void * ) pcTextForTask1, /* 通过任务参数将要打印的文本传递给任务。 */
                 1,                         /* 此任务将以优先级1运行。 */
                 NULL );                    /* 此示例中未使用任务句柄。 */

    /*
     * 以完全相同的方式创建另一个任务。请注意，这次是从相同的任务实现（vTaskFunction）创建多个任务。
     * 只传递的值不同。正在创建相同任务定义的两个实例。
     */
    xTaskCreate( vTaskFunction,
                 "Task 2",
                 1000,
                 ( void * ) pcTextForTask2,
                 1,
                 NULL );

    /* 启动调度程序以开始执行任务。 */
    vTaskStartScheduler();

    /*
     * 如果一切顺利，main()将不会到达这里，因为调度程序现在将运行创建的任务。如果main()到达这里，则没有足够的堆内存来创建空闲或计时器任务
     * （本书后面描述）。第3章提供了有关堆内存管理的更多信息。
     */
    for( ;; )
    {
    }
}
```

***Listing 4.9*** *Example 2的main()函数*

Example 4.2的输出与图4.2中示例1所示的输出完全相同。

## 4.5 任务优先级

FreeRTOS调度器总是确保优先级最高的任务进入*运行*状态。优先级相同的任务将轮流进入和退出*运行*状态。

API函数用于创建任务的`uxPriority`参数为任务设置初始优先级。`vTaskPrioritySet()` API函数在任务创建后更改任务的优先级。

应用程序定义的`configMAX_PRIORITIES`编译时配置常量设置可用优先级的数量。较低的数值优先级表示优先级较低的任务，优先级0是可能的最低优先级，因此有效的优先级范围从0到`(configMAX_PRIORITIES – 1)`。任意数量的任务可以共享相同的优先级。

FreeRTOS调度器有两种选择*运行*状态任务的算法实现，`configMAX_PRIORITIES`的最大允许值取决于使用的实现：

### 4.5.1 通用调度器

通用调度器用C语言编写，可以与所有FreeRTOS架构端口一起使用。它对`configMAX_PRIORITEIS`没有上限。一般来说，最好将`configMAX_PRIORITIES`最小化，因为更多的值需要更多的RAM，并且会导致更长的最坏执行时间。

### 4.5.2 架构优化调度器

架构优化的实现是用特定架构的汇编代码编写的，性能比通用的C实现更好，并且对于所有 `configMAX_PRIORITIES` 值，最坏执行时间是相同的。

架构优化的实现对 32 位架构的 `configMAX_PRIORITIES` 最大值设置为 32，对 64 位架构设置为 64。与通用方法一样，建议将 `configMAX_PRIORITIES` 保持在最低的实际值，因为较高的值需要更多的RAM。

在 FreeRTOSConfig.h 中将 `configUSE_PORT_optimized_TASK_SELECTION` 设置为 1 以使用架构优化的实现，或者设置为 0 以使用通用实现。并非所有 FreeRTOS 端口都有架构优化的实现。那些有的，如果未定义则将 `configUSE_PORT_optimized_TASK_SELECTION` 默认设置为 1。那些没有的，如果未定义则将 `configUSE_PORT_optimized_TASK_SELECTION` 默认设置为 0。

## 4.6 时间测量与Tick中断

[第4.12节，调度算法](#412-scheduling-algorithms)，描述了一种称为“时间片”的可选功能。时间片在迄今为止的示例中使用，并且是观察到的输出行为。在示例中，两个任务都以相同的优先级创建，并且两个任务总是能够运行。因此，每个任务在时间片的开始时进入*运行*状态，并在时间片结束时退出*运行*状态。在图4.3中，t1和t2之间的时间等于一个时间片。

调度程序在每个时间片结束时执行，以选择下一个要运行的任务[^5]。一个周期性中断，称为“tick中断”，用于此目的。编译时配置常量`configTICK_RATE_HZ`设置tick中断的频率，从而也设置每个时间片的长度。例如，将`configTICK_RATE_HZ`设置为100（Hz）会导致每个时间片持续10毫秒。两个tick中断之间的时间称为“tick周期”——因此一个时间片等于一个tick周期。

[^5]: 需要注意的是，时间片的结束并不是调度程序选择新任务运行的唯一位置。正如本书中将要展示的那样，调度程序还会在当前正在执行的任务进入*阻塞*状态后立即选择一个新任务运行，或者当中断将一个更高优先级的任务移动到*就绪*状态时选择一个新任务运行。

图4.4扩展了图4.3，还显示了调度程序的执行。在图4.4中，顶部行显示了调度程序的执行时间，细箭头显示了从一个任务到时钟中断，然后从时钟中断回到不同任务的执行序列。

`configTICK_RATE_HZ`的最佳值取决于应用程序，尽管100是典型值。

<a name="fig4.4" title="图4.4 扩展执行序列以显示时钟中断执行"></a>

***
![](media/figure_4.4_expanded_execution_sequence_with_tick_interrupt.png)
***图4.4*** *扩展执行序列以显示时钟中断执行*
***

FreeRTOS API调用以时钟周期的倍数指定时间，通常简称为“时钟周期”。`pdMS_TO_TICKS()`宏将以毫秒为单位指定的时间转换为以时钟周期为单位指定的时间。可用的分辨率取决于定义的时钟频率，如果时钟频率超过1KHz（如果`configTICK_RATE_HZ`大于1000），则不能使用`pdMS_TO_TICKS()`。清单4.10展示了如何使用`pdMS_TO_TICKS()`将以200毫秒为单位指定的时间转换为以时钟周期为单位指定的等效时间。

<a name="list4.10" title="Listing 4.10 使用 pdMS\_TO\_TICKS() 宏将 200 毫秒转换为..."></a>

```c
/*
 * pdMS_TO_TICKS() 以毫秒为单位的时间作为唯一参数，
 * 并计算为等效的时钟周期。此示例显示 xTimeInTicks 被设置为等效于 200 毫秒的时钟周期数。
 */
TickType_t xTimeInTicks = pdMS_TO_TICKS( 200 );
```

***Listing 4.10*** *使用 pdMS\_TO\_TICKS() 宏将 200 毫秒转换为等效的时钟周期*

使用 `pdMS_TO_TICKS()` 指定毫秒数，而不是直接指定时钟周期，可以确保应用程序中指定的时间在时钟频率更改时不会发生变化。

'时钟计数' 是调度程序启动以来发生的时钟中断总数，假设时钟计数没有溢出。用户应用程序在指定延迟周期时不必考虑溢出，因为 FreeRTOS 在内部管理时间一致性。

[第4.12节：调度算法](#412-scheduling-algorithms)
描述了影响调度器何时选择新任务运行以及何时执行时钟中断的配置常量。

<a name="example4.3" title="示例4.3 实验优先级"></a>
---
***示例4.3*** *实验优先级*

---

调度器总是确保优先级最高的可运行任务是进入*运行*状态的任务。到目前为止的示例创建了两个优先级相同的任务，因此它们轮流进入和退出*运行*状态。本示例探讨了任务具有不同优先级时的情况。清单4.11显示了用于创建任务的代码，第一个任务的优先级为1，第二个任务的优先级为2。实现两个任务的单个函数没有改变；它仍然定期打印一个字符串，使用空循环创建延迟。

<a name="list4.11" title="清单4.11 创建不同优先级的两个任务"></a>

```c
/*
 * 定义将作为任务参数传递的字符串。
 * 这些字符串定义为const，而不是在堆栈上，以确保在任务执行时它们保持有效。
 */
static const char * pcTextForTask1 = "任务1正在运行";
static const char * pcTextForTask2 = "任务2正在运行";

int main( void )
{
    /* 创建优先级为1的第一个任务。 */
    xTaskCreate( vTaskFunction,             /* 任务函数    */
                 "任务1",                  /* 任务名称        */
                 1000,                      /* 任务堆栈深度 */
                 ( void * ) pcTextForTask1, /* 任务参数   */
                 1,                         /* 任务优先级    */
                 NULL );

    /* 创建优先级更高的第二个任务，优先级为2。 */
    xTaskCreate( vTaskFunction,             /* 任务函数    */
                 "任务2",                  /* 任务名称        */
                 1000,                      /* 任务堆栈深度 */
                 ( void * ) pcTextForTask2, /* 任务参数   */
                 2,                         /* 任务优先级    */
                 NULL );

    /* 启动调度器以开始任务执行。 */
    vTaskStartScheduler();

    /* 将不会到达这里。 */
    return 0;
}
```

***清单4.11*** *创建不同优先级的两个任务*

图4.5显示了示例4.3生成的输出。

调度程序总是选择可以运行的最高优先级任务。
任务2的优先级高于任务1，并且总是可以运行；因此，调度程序总是选择任务2，任务1从未执行。任务1被任务2“饿死”处理时间——它无法打印其字符串，因为它从未处于*运行*状态。

<a name="fig4.5" title="图4.5 在不同优先级下运行两个任务"></a>

***
```console
C:\Temp>rtosdemo
任务2正在运行
任务2正在运行
任务2正在运行
任务2正在运行
任务2正在运行
任务2正在运行
任务2正在运行
任务2正在运行
任务2正在运行
任务2正在运行
任务2正在运行
任务2正在运行
任务2正在运行
任务2正在运行
任务2正在运行
```

***图4.5*** *在不同优先级下运行两个任务*
***

任务2总是可以运行，因为它从不需要等待任何东西——它要么在空循环中循环，要么打印到终端。

<a name="fig4.6" title="图4.6 当一个任务的优先级高于另一个任务时的执行模式"></a>

***
![](media/figure_4.6_execution_pattern_higher_priority_task.png)
***图4.6*** *当一个任务的优先级高于另一个任务时的执行模式，如示例4.3所示*


## 4.7 扩展 *Not Running* 状态

到目前为止，创建的任务总是有处理工作要进行，从未需要等待任何事情——由于它们从未需要等待任何事情，它们总是能够进入 *Running* 状态。这种“连续处理”任务的用途有限，因为它们只能在最低优先级创建。如果它们在其他优先级运行，它们将阻止优先级较低的任务运行。

为了使这些任务有用，必须重写它们以使其事件驱动。事件驱动任务只有在事件触发后才有工作（处理）要进行，并且在此之前不能进入 *Running* 状态。调度程序总是选择可以运行的最高优先级任务。如果由于等待事件而无法选择高优先级任务，调度程序必须选择一个可以运行的较低优先级任务。因此，编写事件驱动任务意味着可以在不同优先级创建任务，而不会使最高优先级任务剥夺所有较低优先级任务的处理时间。

### 4.7.1 *阻塞* 状态

等待事件的任务被认为处于“阻塞”状态，这是*未运行*状态的一个子状态。

任务可以进入*阻塞*状态以等待两种不同类型的事件：

1. 临时（时间相关）事件——这些事件在延迟期过期或达到绝对时间时发生。例如，任务可能会进入*阻塞*状态以等待10毫秒过去。

1. 同步事件——这些事件源自另一个任务或中断。例如，任务可能会进入*阻塞*状态以等待队列上的数据到达。同步事件涵盖了广泛的事件类型。

FreeRTOS队列、二进制信号量、计数信号量、互斥锁、递归互斥锁、事件组、流缓冲区、消息缓冲区和直接到任务通知都可以创建同步事件。后续章节将介绍大多数这些功能。

任务可以在同步事件上阻塞，并设置超时，从而同时阻塞两种类型的事件。例如，任务可能选择最多等待10毫秒以等待队列上的数据到达。如果数据在10毫秒内到达或10毫秒内没有数据到达，任务将离开*阻塞*状态。

### 4.7.2 *挂起* 状态

*挂起* 也是 *未运行* 的子状态。处于挂起状态的任务对调度程序不可用。进入挂起状态的唯一方法是通过调用 `vTaskSuspend()` API 函数，而退出挂起状态的唯一方法是通过调用 `vTaskResume()` 或 `xTaskResumeFromISR()` API 函数。大多数应用程序不使用挂起状态。

### 4.7.3 就绪状态

处于 *未运行* 状态且未 *阻塞* 或 *挂起* 的任务被称为处于 *就绪* 状态。它们可以运行，因此是“就绪”状态，但当前不处于 *运行* 状态。

### 4.7.4 完成状态转换图

图 4.7 扩展了简化的状态图，以包括本节中描述的所有 *未运行* 子状态。到目前为止在示例中创建的任务没有使用 *阻塞* 或 *挂起* 状态。它们只在图 4.7 中所示的粗线之间在 *就绪* 状态和 *运行* 状态之间进行转换。

<a name="fig4.7" title="图4.7 完整任务状态机"></a>

***
![](media/figure_4.7_full_task_state_machine.png)
***图4.7*** *完整任务状态机*
***

<a name="example4.4" title="示例4.4 使用阻塞状态创建延迟"></a>
---
***示例4.4*** *使用 *阻塞* 状态创建延迟</i></h3>

---

到目前为止，所有在示例中创建的任务都是“周期性”的——它们会延迟一段时间，然后打印出它们的字符串，再次延迟，如此循环。延迟是通过一个空循环生成的，任务轮询一个递增的循环计数器，直到它达到一个固定值。示例4.3清楚地展示了这种方法的缺点。优先级较高的任务在执行空循环时保持在 *运行* 状态，剥夺了优先级较低的任务的任何处理时间。

轮询的其他几种缺点，最明显的是其低效性。在轮询期间，任务实际上没有任何工作要做，但它仍然使用最大的处理时间，从而浪费处理器周期。示例4.4通过用对 `vTaskDelay()` API 函数的调用替换轮询空循环来纠正这种行为，其原型如清单4.12所示。新的任务定义如清单4.13所示。请注意，`vTaskDelay()` API 函数仅在 `INCLUDE_vTaskDelay` 在 FreeRTOSConfig.h 中设置为 1 时可用。

`vTaskDelay()` 将调用任务置于 *Blocked* 状态，持续固定数量的时钟中断。任务在 *Blocked* 状态下不使用任何处理时间，因此只有在实际有工作要做时才使用处理时间。

<a name="list4.12" title="Listing 4.12 The vTaskDelay() API function prototype"></a>

```c
void vTaskDelay( TickType_t xTicksToDelay );
```

***Listing 4.12*** *The vTaskDelay() API function prototype*

**vTaskDelay 参数:**

- `xTicksToDelay`

  调用任务在 *Blocked* 状态下保持的时钟中断数量，直到被转换回就绪状态。

  例如，如果任务在时钟计数为 10,000 时调用 `vTaskDelay( 100 )`，那么它将立即进入 *Blocked* 状态，并在时钟计数达到 10,100 之前保持在 *Blocked* 状态。

  可以使用宏 `pdMS_TO_TICKS()` 将以毫秒为单位指定的时间转换为以时钟为单位的时间。例如，调用 `vTaskDelay( pdMS_TO_TICKS( 100 ) )` 将导致调用任务在 *Blocked* 状态下保持 100 毫秒。

<a name="list4.13" title="Listing 4.13 The source code for the example task after replacing the null loop delay with a call..."></a>

```c
void vTaskFunction( void * pvParameters )
{
    char * pcTaskName;
    const TickType_t xDelay250ms = pdMS_TO_TICKS( 250 );

    /*
     * The string to print out is passed in via the parameter. Cast this to a
     * character pointer.
     */
    pcTaskName = ( char * ) pvParameters;

    /* As per most tasks, this task is implemented in an infinite loop. */
    for( ;; )
    {
        /* Print out the name of this task. */
        vPrintLine( pcTaskName );

        /*
         * Delay for a period. This time a call to vTaskDelay() is used which
         * places the task into the Blocked state until the delay period has
         * expired. The parameter takes a time specified in 'ticks', and the
         * pdMS_TO_TICKS() macro is used (where the xDelay250ms constant is
         * declared) to convert 250 milliseconds into an equivalent time in
         * ticks.
         */
        vTaskDelay( xDelay250ms );
    }
}
```

***Listing 4.13*** *The source code for the example task after replacing the null loop
delay with a call to vTaskDelay()*

即使两个任务仍然以不同的优先级创建，但现在两者都会运行。示例4.4的输出，如图4.8所示，确认了预期的行为。

<a name="fig4.8" title="图 4.8 执行示例 4.4 时生成的输出"></a>

***

```console
C:\Temp>rtosdemo
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
任务 2 正在运行
任务 1 正在运行
```

***图 4.8*** *执行示例 4.4 时生成的输出*
***

图 4.9 中显示的执行序列解释了为什么两个任务都在运行，尽管它们是以不同的优先级创建的。为了简化，省略了调度程序本身的执行。

当调度程序启动时，会自动创建空闲任务，以确保至少有一个任务可以运行（至少有一个任务处于*就绪*状态）。[第 4.8 节：空闲任务和空闲任务钩子](#48-the-idle-task-and-the-idle-task-hook) 将详细描述空闲任务。

<a name="fig4.9" title="图 4.9 任务使用 vTaskDelay() 替代空循环时的执行序列"></a>

***
![](media/figure_4.9_vTaskDelay_execution_sequence.png)
***图 4.9*** *任务使用 vTaskDelay() 替代空循环时的执行序列*
***

仅改变了两个任务的实现，而不是它们的功能。通过将图 4.9 与图 4.4 进行比较，可以清楚地看到这种功能是以更高效的方式实现的。

图 4.4 显示了任务使用空循环创建延迟时的执行模式，因此它们总是能够运行。结果，它们在可用处理器时间之间使用了百分之百。图 4.9 显示了任务在其延迟期间进入 *Blocked* 状态的执行模式。它们只在实际有工作需要完成时（在这种情况下只是打印一条消息）使用处理器时间，因此只使用了可用处理时间的一小部分。

在图 4.9 中所示的场景中，每当任务离开 *Blocked* 状态时，它们在重新进入 *Blocked* 状态之前执行一个时钟周期的小部分。大多数时间都没有可以运行的应用程序任务（没有处于 *Ready* 状态的应用程序任务），因此没有可以选择进入 *Running* 状态的应用程序任务。在这种情况下，空闲任务运行。分配给空闲任务的处理时间量是系统中剩余处理容量的衡量标准。使用RTOS可以通过简单地允许应用程序完全事件驱动来显著增加剩余处理容量。

粗体线条在图4.10中显示了示例4.4中的任务执行的转换，每个任务现在都会在返回到*就绪*状态之前通过*阻塞*状态。

<a name="fig4.10" title="图4.10粗体线条表示任务执行的状态转换..."></a>

***
![](media/figure_4.10_example_4.4_state_machine.png)
***图4.10*** *粗体线条表示示例4.4中的任务执行的状态转换*
***

### 4.7.5 vTaskDelayUntil() API 函数

`vTaskDelayUntil()` 类似于 `vTaskDelay()`。正如刚才演示的那样，`vTaskDelay()` 参数指定了在任务调用 `vTaskDelay()` 之后，同一任务再次从 *阻塞* 状态转换出来之前应发生的时钟中断数。任务在阻塞状态下保持的时间由 `vTaskDelay()` 参数指定，但任务离开阻塞状态的时间是相对于调用 `vTaskDelay()` 的时间。

`vTaskDelayUntil()` 的参数指定的是调用任务应该从阻塞状态转换到*就绪*状态的精确刻度计数值。当需要固定的执行周期（即希望任务以固定频率周期性执行）时，`vTaskDelayUntil()` 是要使用的API函数，因为调用任务解除阻塞的时间是绝对的，而不是相对于函数调用时的时间（如 `vTaskDelay()` 的情况）。

<a name="list4.14" title="Listing 4.14 vTaskDelayUntil() API function prototype"></a>

```c
void vTaskDelayUntil( TickType_t * pxPreviousWakeTime,
                      TickType_t xTimeIncrement );
```

***Listing 4.14*** *vTaskDelayUntil() API function prototype*

**vTaskDelayUntil() 参数**

- `pxPreviousWakeTime`

  这个参数的命名基于假设 `vTaskDelayUntil()` 被用来实现一个周期性执行且频率固定的任务。在这种情况下，`pxPreviousWakeTime` 保存任务最后一次离开*阻塞*状态（被“唤醒”）的时间。这个时间用作参考点，计算任务下一次应该离开*阻塞*状态的时间。

变量 `pxPreviousWakeTime` 指向的变量在 `vTaskDelayUntil()` 函数中会自动更新；通常不应由应用程序代码修改，但在首次使用之前必须初始化为当前的tick计数。 列表 4.15 演示了如何初始化该变量。

- `xTimeIncrement`

  这个参数的命名假设 `vTaskDelayUntil()` 被用来实现一个周期性执行且频率固定的任务，该频率由 `xTimeIncrement` 值设置。

  `xTimeIncrement` 指定为 'ticks'。可以使用宏 `pdMS_TO_TICKS()` 将以毫秒为单位指定的时间转换为以ticks为单位的时间。

<a name="example4.5" title="Example 4.5 Converting the example tasks to use vTaskDelayUntil()"></a>
---
***示例 4.5*** *将示例任务转换为使用 vTaskDelayUntil()*

---

示例 4.4 中创建的两个任务是周期性任务，但使用 `vTaskDelay()` 不能保证它们运行的频率是固定的，因为任务离开 *Blocked* 状态的时间相对于它们调用 `vTaskDelay()` 的时间。将任务转换为使用 `vTaskDelayUntil()` 而不是 `vTaskDelay()` 可以解决这个潜在问题。

<a name="list4.15" title="清单 4.15 使用 vTaskDelayUntil() 实现示例任务"></a>

```c
void vTaskFunction( void * pvParameters )
{
    char * pcTaskName;
    TickType_t xLastWakeTime;

    /*
     * 通过参数传递要打印的字符串。将其强制转换为字符指针。
     */
    pcTaskName = ( char * ) pvParameters;

    /*
     * xLastWakeTime 变量需要用当前的滴答计数初始化。请注意，这是变量唯一一次显式写入的地方。
     * 在 vTaskDelayUntil() 中，xLastWakeTime 会自动更新。
     */
    xLastWakeTime = xTaskGetTickCount();

    /* 与大多数任务一样，这个任务在一个无限循环中实现。 */
    for( ;; )
    {
        /* 打印出这个任务的名称。 */
        vPrintLine( pcTaskName );

        /*
         * 这个任务应该每 250 毫秒执行一次。与 vTaskDelay() 函数一样，时间以滴答为单位测量，
         * 并使用 pdMS_TO_TICKS() 宏将毫秒转换为滴答。xLastWakeTime 在 vTaskDelayUntil() 中自动更新，
         * 因此不需要任务显式更新。
         */
        vTaskDelayUntil( &xLastWakeTime, pdMS_TO_TICKS( 250 ) );
    }
}
```

***清单 4.15*** *使用 vTaskDelayUntil() 实现示例任务*

示例 4.5 生成的输出与图 4.8 中示例 4.4 所示的输出完全相同。

<a name="example4.6" title="示例 4.6 结合阻塞和非阻塞任务"></a>
---
***示例 4.6*** *结合阻塞和非阻塞任务*

---

前面的示例分别研究了轮询和阻塞任务的行为。本示例强调了我们之前关于预期系统行为的说法，并演示了在结合两种方案时的执行顺序，如下所示：

1. 创建两个优先级为1的任务。这些任务除了不断打印字符串外，什么也不做。

   这些任务从不调用可能导致它们进入*阻塞*状态的API函数，因此始终处于*就绪*或*运行*状态。这种任务称为“连续处理任务”，因为它们总是有工作要做（尽管在这个例子中工作非常简单）。列表4.16显示了连续处理任务的源代码。

1. 然后创建一个优先级为2的第三个任务，其优先级高于其他两个任务。第三个任务也只是定期打印字符串，但这次使用`vTaskDelayUntil()` API函数在每次打印迭代之间将自己置于*阻塞*状态。

Listing 4.17 显示了周期任务的源代码。

<a name="list4.16" title="Listing 4.16 The continuous processing task used in Example 4.6"></a>

```c
void vContinuousProcessingTask( void * pvParameters )
{
    char * pcTaskName;

    /*
     * The string to print out is passed in via the parameter. Cast this to a
     * character pointer.
     */
    pcTaskName = ( char * ) pvParameters;

    /* As per most tasks, this task is implemented in an infinite loop. */
    for( ;; )
    {
        /*
         * Print out the name of this task. This task just does this repeatedly
         * without ever blocking or delaying.
         */
        vPrintLine( pcTaskName );
    }
}
```

***Listing 4.16*** *The continuous processing task used in Example 4.6*

<a name="list4.17" title="Listing 4.17 The periodic task used in Example 4.6"></a>

```c
void vPeriodicTask( void * pvParameters )
{
    TickType_t xLastWakeTime;

    const TickType_t xDelay3ms = pdMS_TO_TICKS( 3 );

    /*
     * The xLastWakeTime variable needs to be initialized with the current tick
     * count. Note that this is the only time the variable is explicitly
     * written to. After this xLastWakeTime is managed automatically by the
     * vTaskDelayUntil() API function.
     */
    xLastWakeTime = xTaskGetTickCount();

    /* As per most tasks, this task is implemented in an infinite loop. */
    for( ;; )
    {
        /* Print out the name of this task. */
        vPrintLine( "Periodic task is running" );

        /*
         * The task should execute every 3 milliseconds exactly – see the
         * declaration of xDelay3ms in this function.
         */
        vTaskDelayUntil( &xLastWakeTime, xDelay3ms );
    }
}
```

***Listing 4.17*** *The periodic task used in Example 4.6*

Figure 4.11 显示了 Example 4.6 生成的输出，执行序列如 Figure 4.12 所示，对观察到的行为进行了解释。

<a name="fig4.11" title="图4.11 执行示例4.6时生成的输出"></a>

***

```console
连续任务2正在运行
连续任务2正在运行
周期任务正在运行
连续任务1正在运行
连续任务1正在运行
连续任务1正在运行
连续任务1正在运行
连续任务1正在运行
连续任务2正在运行
连续任务2正在运行
连续任务2正在运行
连续任务2正在运行
连续任务2正在运行
连续任务1正在运行
连续任务1正在运行
连续任务1正在运行
连续任务1正在运行
连续任务1正在运行
连续任务1正在运行
连续任务1正在运行
连续任务1正在运行
连续任务1正在运行
连续任务1正在运行
周期任务正在运行
连续任务2正在运行
连续任务2正在运行
```

***图4.11*** *执行示例4.6时生成的输出*
***

<a name="fig4.12" title="图4.12 示例4.6的执行模式"></a>

***
![](media/figure_4.11_example_4.6_execution_pattern.png)
***图4.12*** *示例4.6的执行模式*
***


## 4.8 空闲任务和空闲任务钩子

示例 4.4 中创建的任务大部分时间处于阻塞状态。处于这种状态时，它们无法运行，因此无法被调度器选择。

必须始终至少有一个任务可以进入运行状态[^6]。为了确保这一点，调度器在调用 `vTaskStartScheduler()` 时会自动创建一个空闲任务。空闲任务几乎什么也不做，只是在一个循环中运行，因此像第一个示例中的任务一样，它总是能够运行。

[^6]: 即使使用 FreeRTOS 的特殊低功耗功能，情况也是如此，在这种情况下，如果应用程序创建的任务都无法执行，则执行 FreeRTOS 的微控制器将被放置到低功耗模式。

空闲任务具有最低的优先级（优先级零），以确保它永远不会阻止优先级更高的应用程序任务进入 *运行* 状态。然而，没有什么可以阻止应用程序设计者创建优先级为零的任务，从而共享空闲任务的优先级，如果需要的话。`FreeRTOSConfig.h` 中的 `configIDLE_SHOULD_YIELD` 编译时配置常量可以用来防止空闲任务消耗本可以更有效地分配给优先级为 0 的应用程序任务的处理时间。第 4.12 节，调度算法，描述了 `configIDLE_SHOULD_YIELD`。

在最低优先级下运行可以确保空闲任务在更高优先级的任务进入就绪状态时立即从 *运行* 状态转换出来。这可以在图 4.9 的时间 **tn** 看到，此时空闲任务被立即交换出去，以允许任务 2 在任务 2 离开 *阻塞* 状态的瞬间执行。任务 2 被认为抢占了空闲任务。抢占是自动发生的，并且不需要被抢占的任务知道。

> *注意：如果一个任务使用 `vTaskDelete()` API 函数删除自己，那么必须确保空闲任务不会被剥夺处理时间。这是因为空闲任务负责清理被删除的任务使用的内核资源。*

### 4.8.1 空闲任务钩子函数

可以通过使用空闲钩子（或空闲回调）函数，将特定于应用程序的功能直接添加到空闲任务中。空闲钩子函数是一个函数，它会在空闲任务循环的每次迭代中自动被空闲任务调用。

空闲任务钩子的常见用途包括：

- 执行低优先级、后台或连续处理功能，而无需创建应用程序任务的RAM开销。
- 测量空闲处理能力的数量。（空闲任务只会在所有高优先级应用程序任务没有工作要执行时运行；因此，测量分配给空闲任务的处理时间，可以清楚地指示出空闲处理时间。）
- 将处理器置于低功耗模式，提供一种简单且自动的方法，以便在没有应用程序处理要执行时节省电源（尽管可实现的功耗节省低于无时钟空闲模式）。

### 4.8.2 空闲任务钩子函数的实现限制

空闲任务钩子函数必须遵循以下规则。

- 空闲任务钩子函数绝不能尝试阻塞或挂起自身。

  *注意：以任何方式阻塞空闲任务都可能导致没有任务可以进入*运行*状态的情况。*

- 如果应用程序任务使用 `vTaskDelete()` API 函数删除自身，那么空闲任务钩子必须在合理的时间内返回给调用者。这是因为空闲任务负责清理分配给删除自身的任务的内核资源。如果空闲任务永远停留在空闲钩子函数中，那么这种清理就无法发生。

空闲任务钩子函数必须具有列表 4.18 中显示的名称和原型。

<a name="list4.18" title="列表 4.18 空闲任务钩子函数名称和原型"></a>

```c
void vApplicationIdleHook( void );
```

***列表 4.18*** *空闲任务钩子函数名称和原型*

<a name="example4.7" title="示例 4.7 定义空闲任务钩子函数"></a>
---
***示例 4.7*** *定义空闲任务钩子函数</i></h3>

---

示例 4.4 中使用的阻塞 `vTaskDelay()` API 调用创建了大量的空闲时间，即当两个应用程序任务都处于*阻塞*状态时，空闲任务执行的时间。示例 4.7 通过添加一个空闲钩子函数利用了这种空闲时间，其源代码如列表 4.19 所示。

<a name="list4.19" title="Listing 4.19 A very simple Idle hook function"></a>

```c
/* Declare a variable that will be incremented by the hook function.  */
volatile unsigned long ulIdleCycleCount = 0UL;

/*
 * Idle hook functions MUST be called vApplicationIdleHook(), take no
 * parameters, and return void.
 */
void vApplicationIdleHook( void )
{
    /* This hook function does nothing but increment a counter. */
    ulIdleCycleCount++;
}
```

***Listing 4.19*** *A very simple Idle hook function*

`configUSE_IDLE_HOOK` 必须在 FreeRTOSConfig.h 中设置为 1，以便调用空闲钩子函数。

实现创建任务的函数稍微修改了一下，以打印出 `ulIdleCycleCount` 的值，如清单 4.20 所示。

<a name="list4.20" title="Listing 4.20 The source code for the example task now prints out the ulIdleCycleCount value"></a>

```c
void vTaskFunction( void * pvParameters )
{
    char * pcTaskName;
    const TickType_t xDelay250ms = pdMS_TO_TICKS( 250 );

    /*
     * The string to print out is passed in via the parameter. Cast this to
     * a character pointer.
     */
    pcTaskName = ( char * ) pvParameters;

    /* As per most tasks, this task is implemented in an infinite loop. */
    for( ;; )
    {
        /*
         * Print out the name of this task AND the number of times
         * ulIdleCycleCount has been incremented.
         */
        vPrintLineAndNumber( pcTaskName, ulIdleCycleCount );

        /* Delay for a period of 250 milliseconds. */
        vTaskDelay( xDelay250ms );
    }
}
```

***Listing 4.20*** *The source code for the example task now prints out the
ulIdleCycleCount value*

图 4.13 显示了示例 4.7 生成的输出。可以看到，空闲任务钩子函数在每次应用程序任务迭代之间执行大约 400 万次（迭代次数取决于硬件速度）。

<a name="fig4.13" title="图 4.13 执行示例 4.7 时生成的输出"></a>

***

```console
C:\Temp>rtosdemo
任务 2 正在运行
ulIdleCycleCount = 0
任务 1 正在运行
ulIdleCycleCount = 0
任务 2 正在运行
ulIdleCycleCount = 3869504
任务 1 正在运行
ulIdleCycleCount = 3869504
任务 2 正在运行
ulIdleCycleCount = 8564623
任务 1 正在运行
ulIdleCycleCount = 8564623
任务 2 正在运行
ulIdleCycleCount = 13181489
任务 1 正在运行
ulIdleCycleCount = 13181489
任务 2 正在运行
ulIdleCycleCount = 17838406
任务 1 正在运行
ulIdleCycleCount = 17838406
任务 2 正在运行
```

***图 4.13*** *执行示例 4.7 时生成的输出*
***

## 4.9 更改任务的优先级

### 4.9.1 vTaskPrioritySet() API 函数

`vTaskPrioritySet()` API 函数在调度器启动后更改任务的优先级。`vTaskPrioritySet()` API 函数仅在 `INCLUDE_vTaskPrioritySet` 在 FreeRTOSConfig.h 中设置为 1 时可用。

<a name="list4.21" title="清单 4.21 vTaskPrioritySet() API 函数原型"></a>

```c
void vTaskPrioritySet( TaskHandle_t xTask,
                       UBaseType_t uxNewPriority );
```

***清单 4.21*** *vTaskPrioritySet() API 函数原型*

**vTaskPrioritySet() 参数**

- `pxTask`

  正在修改优先级的任务的句柄（主题任务）。有关获取任务句柄的信息，请参阅 `xTaskCreate()` API 函数的 `pxCreatedTask` 参数，或 `xTaskCreateStatic()` API 函数的返回值。

  任务可以通过传递 NULL 而不是有效的任务句柄来更改自己的优先级。

- `uxNewPriority`

  主题任务要设置的优先级。这会自动限制为最大可用优先级 `(configMAX_PRIORITIES – 1)`，其中 `configMAX_PRIORITIES` 是在 FreeRTOSConfig.h 头文件中设置的编译时常量。


### 4.9.2 uxTaskPriorityGet() API 函数

`uxTaskPriorityGet()` API 函数返回一个任务的优先级。`uxTaskPriorityGet()` API 函数仅在 `INCLUDE_uxTaskPriorityGet` 在 FreeRTOSConfig.h 中设置为 1 时可用。

<a name="list4.22" title="清单 4.22 uxTaskPriorityGet() API 函数原型"></a>

```c
UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );
```

***清单 4.22*** *uxTaskPriorityGet() API 函数原型*

**uxTaskPriorityGet() 参数和返回值**

- `pxTask`

  正在查询优先级的任务的句柄（主题任务）。有关如何获取任务句柄的信息，请参阅 `xTaskCreate()` API 函数的 `pxCreatedTask` 参数，或 `xTaskCreateStatic()` API 函数的返回值。

  任务可以通过传递 NULL 而不是有效的任务句柄来查询自己的优先级。

- 返回值

  当前分配给被查询任务的优先级。

<a name="example4.8" title="示例 4.8 更改任务优先级"></a>
---
***示例 4.8*** *更改任务优先级*

---

调度程序始终选择优先级最高的 *Ready* 状态任务作为进入 *Running* 状态的任务。示例 4.8 通过使用 `vTaskPrioritySet()` API 函数相互更改两个任务的优先级来演示这一点。

示例 4.8 创建了两个不同优先级的任务。这两个任务都没有调用任何可能导致其进入阻塞状态的API函数，因此它们总是处于*就绪*状态或*运行*状态。因此，优先级最高的任务将始终是调度程序选择的*运行*状态的任务。

示例 4.8 的行为如下：

1. 任务 1（清单 4.23）以最高优先级创建，因此它保证首先运行。任务 1 打印出几个字符串，然后将任务 2（清单 4.24）的优先级提高到其自身优先级之上。

1. 任务 2 一旦具有最高相对优先级，就开始运行（进入*运行*状态）。任何时候只能有一个任务处于运行状态，因此当任务 2 处于*运行*状态时，任务 1 处于*就绪*状态。

1. 任务 2 在将其自身优先级降低到低于任务 1 之前，打印出一条消息。

1. 当任务 2 将其优先级降低时，任务 1 再次成为优先级最高的任务，因此任务 1 重新进入*运行*状态，将任务 2 迫回到*就绪*状态。

<a name="list4.23" title="Listing 4.23 The implementation of Task 1 in Example 4.8"></a>

```c
void vTask1( void * pvParameters )
{
    UBaseType_t uxPriority;

    /*
     * This task will always run before Task 2 as it is created with the higher
     * priority. Neither Task 1 nor Task 2 ever block so both will always be in
     * either the Running or the Ready state.
     */

    /*
     * Query the priority at which this task is running - passing in NULL means
     * "return the calling task's priority".
     */
    uxPriority = uxTaskPriorityGet( NULL );

    for( ;; )
    {
        /* Print out the name of this task. */
        vPrintLine( "Task 1 is running" );

        /*
         * Setting the Task 2 priority above the Task 1 priority will cause
         * Task 2 to immediately start running (as then Task 2 will have the
         * higher priority of the two created tasks). Note the use of the
         * handle to task 2 (xTask2Handle) in the call to vTaskPrioritySet().
         * Listing 4.25 shows how the handle was obtained.
         */
        vPrintLine( "About to raise the Task 2 priority" );
        vTaskPrioritySet( xTask2Handle, ( uxPriority + 1 ) );

        /*
         * Task 1 will only run when it has a priority higher than Task 2.
         * Therefore, for this task to reach this point, Task 2 must already
         * have executed and set its priority back down to below the priority
         * of this task.
         */
    }
}
```

***清单 4.23*** *示例 4.8 中任务 1 的实现*

<a name="list4.24" title="清单 4.24 示例 4.8 中任务 2 的实现"></a>

```c
void vTask2( void * pvParameters )
{
    UBaseType_t uxPriority;

    /*
     * 任务 1 将始终在本任务之前运行，因为任务 1 创建时优先级较高。任务 1 和任务 2 从不阻塞，因此始终处于运行或就绪状态。
     *
     * 查询此任务的运行优先级 - 传入 NULL 表示“返回调用任务的优先级”。
     */
    uxPriority = uxTaskPriorityGet( NULL );

    for( ;; )
    {
        /*
         * 为了使本任务达到此点，任务 1 必须已经运行并将本任务的优先级设置为高于其自身。
         */

         /* 打印出本任务的名称。 */
        vPrintLine( "Task 2 is running" );

        /*
         * 将本任务的优先级重新设置为其原始值。
         * 传入 NULL 作为任务句柄表示“更改调用任务的优先级”。将优先级设置为低于任务 1 的优先级，将导致任务 1 立即开始运行 - 抢占本任务。
         */
        vPrintLine( "About to lower the Task 2 priority" );
        vTaskPrioritySet( NULL, ( uxPriority - 2 ) );
    }
}
```

***清单 4.24*** *示例 4.8 中任务 2 的实现*

每个任务都可以通过使用 NULL 替换有效的任务句柄来查询和设置自己的优先级。只有当一个任务希望引用除自身之外的其他任务时，才需要任务句柄，例如当任务 1 更改任务 2 的优先级时。为了允许任务 1 这样做，在创建任务 2 时获取并保存任务 2 的句柄，如清单 4.25 中的注释所示。

<a name="list4.25" title="清单 4.25 示例 4.8 中 main() 的实现"></a>

```c
/* 声明一个变量，用于保存任务 2 的句柄。 */
TaskHandle_t xTask2Handle = NULL;

int main( void )
{
    /*
     * 以优先级 2 创建第一个任务。任务参数未使用，设置为 NULL。任务句柄也未使用，因此也设置为 NULL。
     */
    xTaskCreate( vTask1, "任务 1", 1000, NULL, 2, NULL );
    /* 任务以优先级 2 创建 ______^. */

    /*
     * 以优先级 1 创建第二个任务，该优先级低于任务 1 的优先级。任务参数未使用，因此设置为 NULL，但这次需要任务句柄，因此在最后一个参数中传递 xTask2Handle 的地址。
     */
    xTaskCreate( vTask2, "任务 2", 1000, NULL, 1, &xTask2Handle );
    /* 任务句柄是最后一个参数 _____^^^^^^^^^^^^^ */

    /* 启动调度程序，以便任务开始执行。 */
    vTaskStartScheduler();

    /*
     * 如果一切正常，main() 将不会到达这里，因为调度程序现在正在运行创建的任务。如果 main() 到达这里，则没有足够的堆内存来创建空闲任务或计时器任务（本书后面描述）。第 2 章提供了有关堆内存管理的更多信息。
     */
    for( ;; )
    {
    }
}
```

***清单 4.25*** *示例 4.8 中 main() 的实现*

图 4.14 示出了示例 4.8 中任务的执行顺序，结果输出如图 4.15 所示。

<a name="fig4.14" title="图 4.14 运行示例 4.8 时任务执行的序列"></a>

***
![](media/figure_4.14_example_4.8_execution_sequence.png)
***图 4.14*** *运行示例 4.8 时任务执行的序列*
***

<a name="fig4.15" title="图 4.15 执行示例 4.8 时生成的输出"></a>

***

```console
Task1 is running
About to raise the Task2 priority
Task2 is running
About to lower the Task2 priority
Task1 is running
About to raise the Task2 priority
Task2 is running
About to lower the Task2 priority
Task1 is running
About to raise the Task2 priority
Task2 is running
About to lower the Task2 priority
Task1 is running
```

***图 4.15*** *执行示例 4.8 时生成的输出*
***

## 4.10 删除任务

### 4.10.1 vTaskDelete() API 函数

`vTaskDelete()` API 函数删除一个任务。`vTaskDelete()` API 函数仅在 `INCLUDE_vTaskDelete` 在 FreeRTOSConfig.h 中设置为 1 时可用。

在运行时不断创建和删除任务不是一个好的做法，因此如果你发现自己需要这个函数，请考虑其他设计选项，例如重用任务。

已删除的任务不再存在，也无法再次进入*运行*状态。

如果使用动态内存分配创建的任务后来删除自己，则空闲任务负责释放分配给已删除任务的内存，例如已删除任务的数据结构和堆栈。因此，在这种情况下，应用程序不应完全剥夺空闲任务的所有处理时间。

> *注意：只有由内核本身分配给任务的内存在任务被删除时会自动释放。任务实现过程中分配的任何内存或其他资源必须在不再需要时显式释放。*


<a name="list4.26" title="Listing 4.26 The vTaskDelete() API function prototype"></a>

```c
void vTaskDelete( TaskHandle_t xTaskToDelete );
```

***Listing 4.26*** *The vTaskDelete() API function prototype*

**vTaskDelete() 参数**

- `pxTaskToDelete`

  要删除的任务的句柄（主题任务）。有关获取任务句柄的信息，请参阅 `xTaskCreate()` API 函数的 `pxCreatedTask` 参数，以及 `xTaskCreateStatic()` API 函数的返回值。

任务可以通过在有效任务句柄的位置传递NULL来删除自己。

<a name="example4.9" title="示例 4.9 删除任务"></a>
---
***示例 4.9*** *删除任务*

---

这是一个非常简单的示例，行为如下。

1. `main()` 以优先级 1 创建任务 1。当它运行时，它以优先级 2 创建任务 2。任务 2 现在是最高优先级任务，因此它立即开始执行。清单 4.27 显示了 `main()` 的源代码。清单 4.28 显示了任务 1 的源代码。

1. 任务 2 除了删除自己之外什么也不做。它可以通过将 NULL 传递给 `vTaskDelete()` 来删除自己，但为了演示目的，它使用自己的任务句柄。清单 4.29 显示了任务 2 的源代码。

1. 当任务 2 被删除时，任务 1 再次成为最高优先级任务，因此它继续执行——此时它调用 `vTaskDelay()` 以阻塞一段时间。

1. 当任务 1 处于阻塞状态时，空闲任务执行并释放分配给已删除的任务 2 的内存。

1. 当任务1离开阻塞状态时，它再次成为优先级最高的*就绪*状态任务，从而抢占空闲任务。当它进入*运行*状态时，它再次创建任务2，依此类推。

<a name="list4.27" title="Listing 4.27 The implementation of main() for Example 4.9"></a>

```c
int main( void )
{
    /* 创建优先级为1的第一个任务。 */
    xTaskCreate( vTask1, "Task 1", 1000, NULL, 1, NULL );

    /* 启动调度器以开始任务执行。 */
    vTaskStartScheduler();

    /* main() 不应达到这里，因为调度器已经启动。 */
    for( ;; )
    {
    }
}
```

***Listing 4.27*** *Example 4.9 中 main() 的实现*
***

<a name="list4.28" title="Listing 4.28 The implementation of Task 1 for Example 4.9"></a>

```c
TaskHandle_t xTask2Handle = NULL;

void vTask1( void * pvParameters )
{
    const TickType_t xDelay100ms = pdMS_TO_TICKS( 100UL );

    for( ;; )
    {
        /* 打印出此任务的名称。 */
        vPrintLine( "Task 1 is running" );

        /*
         * 以更高的优先级创建任务2。
         * 将 xTask2Handle 的地址作为 pxCreatedTask 参数传递，以便
         * xTaskCreate 将生成的任务句柄写入该变量。
         */
        xTaskCreate( vTask2, "Task 2", 1000, NULL, 2, &xTask2Handle );

        /*
         * 任务2具有/曾经具有更高的优先级。对于任务1达到这里，任务2
         * 必须已经执行并删除自己。
         */
        vTaskDelay( xDelay100ms );
    }
}
```

***Listing 4.28*** *Example 4.9 中 Task 1 的实现*
***

<a name="list4.29" title="Listing 4.29 The implementation of Task 2 for Example 4.9"></a>

```c
void vTask2( void * pvParameters )
{
    /*
     * 任务2在启动时立即删除自己。
     * 为了做到这一点，它可以调用 vTaskDelete()，并使用 NULL 作为参数。
     * 为了演示目的，它改为调用 vTaskDelete() 并传递自己的任务句柄。
     */
    vPrintLine( "Task 2 is running and about to delete itself" );
    vTaskDelete( xTask2Handle );
}
```

***Listing 4.29*** *Example 4.9 中 Task 2 的实现*
***

<a name="fig4.16" title="Figure 4.16 The output produced when Example 4.9 is executed"></a>

***

```console
C:\Temp>rtosdemo
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
```

***Figure 4.16*** *执行 Example 4.9 时生成的输出*
***

<a name="fig4.17" title="Figure 4.17 The execution sequence for Example 4.9"></a>

***
![](media/figure_4.17_example_4.9_execution_sequence.png)
***Figure 4.17*** *Example 4.9 的执行序列*
***



## 4.11 线程本地存储和可重入性

线程本地存储允许应用程序开发者在每个任务的任务控制块中存储任意数据。这种功能最常用于存储那些通常由非可重入函数存储在全局变量中的数据。

可重入函数是指可以在多个线程中安全运行而不会产生任何副作用的函数。当在没有线程本地存储的多线程环境中使用非可重入函数时，必须特别小心检查这些函数调用的带外结果，以确保在关键部分内进行。过多使用关键部分会降低RTOS性能，因此线程本地存储通常优于使用关键部分。

线程本地存储最常见的用途是ISO C标准中使用的```errno```全局变量，该变量由C标准库和POSIX系统使用。```errno```全局变量用于为常见的标准库函数（如strtof和strtol）提供扩展结果或错误代码。

### 4.11.1 C 运行时线程本地存储实现

大多数嵌入式 libc 实现提供了API，以确保非重入函数在多线程环境中能够正确工作。FreeRTOS 包含对两个常用开源库的重入API的支持：
[newlib](https://sourceware.org/newlib/) 和
[picolibc](https://github.com/picolibc/picolibc)。
这些预构建的C运行时线程本地存储实现可以通过在项目的FreeRTOSConfig.h文件中定义下面列出的相应宏来启用。

- ```configUSE_NEWLIB_REENTRANT``` 用于 [newlib](https://sourceware.org/newlib/)
- ```configUSE_PICOLIBC_TLS``` 用于 [picolibc](https://github.com/picolibc/picolibc)

### 4.11.2 自定义C运行时线程本地存储

应用程序开发人员可以通过在FreeRTOSConfig.h文件中定义以下宏来实现线程本地存储：

- 将 ```configUSE_C_RUNTIME_TLS_SUPPORT``` 定义为1，以启用C运行时线程本地存储支持。

- 将 ```configTLS_BLOCK_TYPE``` 定义为用于存储C运行时线程本地存储数据的C类型。

- 将 ```configINIT_TLS_BLOCK``` 定义为在初始化C运行时线程本地存储块时应运行的C代码。

- 将 ```configSET_TLS_BLOCK``` 定义为在切换到新任务时应运行的C代码。

- 将 ```configDEINIT_TLS_BLOCK``` 定义为在取消初始化C运行时线程本地存储块时应运行的C代码。

### 4.11.3 应用程序线程本地存储

除了C运行时线程本地存储，应用程序开发人员还可以定义一组应用程序特定的指针，以包含在任务控制块中。此功能通过在项目的FreeRTOSConfig.h文件中将```configNUM_THREAD_LOCAL_STORAGE_POINTERS```设置为非零数来启用。列表4.30中定义的```vTaskSetThreadLocalStoragePointer```和```pvTaskGetThreadLocalStoragePointer```函数可以分别用于在运行时设置和获取每个线程本地存储指针的值。

<a name="list4.30" title="列表4.30 线程本地存储指针API函数的原型"></a>

```c
void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
                                           BaseType_t xIndex )

void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
                                        BaseType_t xIndex,
                                        void * pvValue );
```

***列表4.30*** *线程本地存储指针API函数的原型*


## 4.12 调度算法

### 4.12.1 任务状态和事件回顾

正在实际运行（使用处理时间）的任务处于*Running*状态。在单核处理器上，任何给定时间只能有一个任务处于*Running*状态。也可以在多个核心上运行FreeRTOS（非对称多处理，或AMP），或者让FreeRTOS在多个核心之间调度任务（对称多处理，或SMP）。这里不描述这些情况。

没有实际运行但既不处于阻塞状态也不是*Suspended*状态的任务处于*Ready*状态。处于Ready状态的任务可供调度器选择进入*Running*状态。调度器总是选择优先级最高的Ready状态任务进入*Running*状态。

任务可以在*Blocked*状态等待事件，并在事件发生时自动返回到*Ready*状态。时间事件在特定时间发生，例如当一个阻塞时间到期时，通常用于实现周期性或超时行为。同步事件发生在任务或中断服务例程使用任务通知、队列、事件组、消息缓冲区、流缓冲区或多种类型的信号量发送信息时。它们通常用于信号异步活动，例如数据到达外围设备。


### 4.12.2 选择调度算法

调度算法是决定将哪个处于*Ready*状态的任务转换为*Running*状态的软件例程。

到目前为止的所有示例都使用了相同的调度算法，但可以通过`configUSE_PREEMPTION`和`configUSE_TIME_SLICING`配置常量来更改算法。这两个常量都在FreeRTOSConfig.h中定义。

第三个配置常量`configUSE_TICKLESS_IDLE`也会影响调度算法，因为其使用可能会导致时钟中断在较长时间内完全关闭。`configUSE_TICKLESS_IDLE`是一个高级选项，专门为需要最小化电源消耗的应用程序提供。

本节提供的描述假设`configUSE_TICKLESS_IDLE`设置为0，这是默认设置，如果常量未定义则使用。

在所有可能的单核配置中，FreeRTOS调度器按顺序选择共享优先级的任务。这种“轮流”策略通常称为“轮询调度”。轮询调度算法不保证时间在相同优先级的任务之间平等分配，只保证相同优先级的*Ready*状态任务按顺序进入*Running*状态。

<a name="tbl5" title="表 5 FreeRTOSConfig.h 设置以配置内核调度算法"></a>

***
| 调度算法            | 优先级 | `configUSE_PREEMPTION` | `configUSE_TIME_SLICING` |
|---------------------|--------|------------------------|--------------------------|
| 带时间片的抢占式    | 是     | 1 | 1   |
| 不带时间片的抢占式 | 是     | 1 | 0   |
| 合作式            | 否     | 0 | 任意 |

***表 5*** *FreeRTOSConfig.h 设置以配置内核调度算法*
* * *

### 4.12.3 带时间片的优先级抢占式调度

表 5 中显示的配置将 FreeRTOS 调度器设置为使用一种称为“带时间片的固定优先级抢占式调度”的调度算法，这是大多数小型 RTOS 应用程序使用的调度算法，也是本书迄今为止介绍的所有示例中使用的算法。下表提供了算法名称中使用的术语的描述。

**对描述调度策略的术语的解释：**

- 固定优先级

  称为“固定优先级”的调度算法不会更改分配给被调度任务的优先级，但也不会阻止任务自己更改自己的优先级或其他任务的优先级。

- 抢占式

  抢占式调度算法会立即“抢占”处于*运行*状态的任务，如果一个优先级高于*运行*状态任务的任务进入*就绪*状态。被抢占意味着被强制从*运行*状态移动到*就绪*状态（而不显式地让出或阻塞），以允许不同的任务进入*运行*状态。任务抢占可以在任何时候发生，而不仅仅是在 RTOS 计时器中断时。

- 时间片轮转

  时间片轮转用于在具有相同优先级的任务之间共享处理时间，即使这些任务没有明确地让出CPU或进入*阻塞*状态。描述为使用*时间片轮转*的调度算法在每个时间片结束时选择一个新任务进入*运行*状态，如果有其他具有相同优先级的*就绪*状态任务。一个时间片等于两个RTOS时钟中断之间的时间。

  图4.18和图4.19演示了在使用固定优先级抢占式调度算法和时间片轮转时任务的调度方式。图4.18显示了在所有任务都具有唯一优先级的应用程序中，任务被选择进入*运行*状态的顺序。图4.19显示了在两个任务共享优先级的应用程序中，任务被选择进入*运行*状态的顺序。

  <a name="fig4.18" title="图4.18 突出任务优先级和抢占的执行模式..."></a>

  ****
  ![](media/figure_4.18_preemption_execution_pattern.png)
  ***图4.18*** *突出任务优先级和抢占的执行模式，在一个假设的应用程序中，每个任务都被分配了唯一的优先级*
  ****

  参考图4.18：

  - 空闲任务

    空闲任务在最低优先级下运行，因此每当一个更高优先级的任务进入*就绪*状态时，它都会被抢占，例如在时间t3、t5和t9。

- 任务 3

  任务 3 是一个事件驱动的任务，执行优先级相对较低，但高于空闲优先级。它大部分时间处于 *Blocked* 状态，等待其感兴趣的事件，每次事件发生时从 *Blocked* 状态转换到 *Ready* 状态。所有 FreeRTOS 任务间通信机制（任务通知、队列、信号量、事件组等）都可以用来信号事件并解除任务的阻塞。

  事件发生在 t3 和 t5 时刻，以及 t9 和 t12 之间的某个时刻。发生在 t3 和 t5 时刻的事件会立即处理，因为在这些时刻，任务 3 是能够运行的最高优先级任务。发生在 t9 和 t12 之间的事件直到 t12 才处理，因为在此之前，优先级更高的任务 1 和任务 2 仍在执行。只有在 t12 时刻，任务 1 和任务 2 都处于 *Blocked* 状态，任务 3 才成为最高优先级的 *Ready* 状态任务。

- 任务 2

  任务 2 是一个周期性任务，其执行优先级高于任务 3，但低于任务 1。任务的周期间隔意味着任务 2 希望在 t1、t6 和 t9 时执行。

  在 t6 时，任务 3 处于 *Running* 状态，但任务 2 的相对优先级更高，因此会抢占任务 3 并立即开始执行。任务 2 完成处理并在 t7 时重新进入 *Blocked* 状态，此时任务 3 可以重新进入 *Running* 状态以完成其处理。任务 3 本身在 t8 时阻塞。

- 任务 1

  任务 1 也是一个事件驱动任务。它以最高优先级执行，因此可以抢占系统中的任何其他任务。唯一显示的任务 1 事件发生在 t10 时，此时任务 1 抢占任务 2。任务 2 只能在任务 1 在 t11 时重新进入 *Blocked* 状态后完成其处理。

<a name="fig4.19" title="图 4.19 突出显示任务优先级和时间片的执行模式..."></a>

***
![](media/figure_4.19_time_slicing_execution_pattern.png)
***图 4.19*** *突出显示任务优先级和时间片的执行模式
在一个假设应用程序中，两个任务以相同的优先级运行*
***

参考图 4.19：

- 空闲任务和任务 2

  空闲任务和任务 2 都是连续处理任务，并且都具有优先级 0（最低可能的优先级）。调度程序只在没有更高优先级的任务可以运行时才为优先级 0 的任务分配处理时间，并通过时间片共享分配给优先级 0 的任务的时间。每个时钟中断都会开始一个新的时间片，如图 4.19 所示，发生在 t1、t2、t3、t4、t5、t8、t9、t10 和 t11 时。

空闲任务和任务2轮流进入*运行*状态，这可能导致两个任务在同一时间片的一部分时间内都处于*运行*状态，就像在时间t5和时间t8之间发生的那样。

- 任务1

  任务1的优先级高于空闲优先级。任务1是一个事件驱动的任务，大部分时间处于*阻塞*状态，等待其感兴趣的事件，每次事件发生时从*阻塞*状态转换到*就绪*状态。

  感兴趣的事件发生在时间t6。在t6时，任务1成为能够运行的最高优先级任务，因此任务1在时间片的中途中断了空闲任务。事件的处理在时间t7完成，此时任务1重新进入阻塞状态。

图4.19显示了空闲任务与应用程序编写者创建的任务共享处理时间。如果应用程序编写者创建的空闲优先级任务有工作要做，而空闲任务没有，那么分配那么多处理时间给空闲任务可能不理想。可以使用编译时配置常量`configIDLE_SHOULD_YIELD`来更改空闲任务的调度方式：

- 如果将`configIDLE_SHOULD_YIELD`设置为0，则空闲任务将在其时间片的整个过程中保持在*运行*状态，除非被更高优先级的任务中断。

- 如果将 `configIDLE_SHOULD_YIELD` 设置为 1，则空闲任务在每次循环迭代时都会让出（主动放弃其分配的时间片剩余部分），如果有其他空闲优先级任务处于 *Ready* 状态。

图 4.19 所示的执行模式是当 `configIDLE_SHOULD_YIELD` 设置为 0 时观察到的。图 4.20 所示的执行模式是在相同场景下，当 `configIDLE_SHOULD_YIELD` 设置为 1 时观察到的。

<a name="fig4.20" title="图 4.20 与图 4.19 所示相同场景的执行模式..."></a>

***
![](media/figure_4.20_time_slicing_with_yield_execution_pattern.png)
***图 4.20*** *与图 4.19 所示相同场景的执行模式，但这次 `configIDLE_SHOULD_YIELD` 设置为 1*
***

图 4.20 还显示，当 `configIDLE_SHOULD_YIELD` 设置为 1 时，空闲任务之后选择进入 *Running* 状态的任务不执行整个时间片，而是执行空闲任务让出的时间片剩余部分。

### 4.12.4 无时间片的优先级抢占式调度

无时间片的优先级抢占式调度保留了前一节中描述的相同任务选择和抢占算法，但不使用时间片来在同一优先级的任务之间共享处理时间。

表 5 显示了配置 FreeRTOS 调度器使用无时间片的优先级抢占式调度的 FreeRTOSConfig.h 设置。

如图 4.19 所示，如果使用时间片，并且在最高优先级上有多个准备好运行的任务，那么调度器在每个 RTOS 计时器中断（标记时间片结束的计时器中断）期间选择一个新任务进入 *Running* 状态。如果不使用时间片，那么调度器仅在以下情况下选择一个新任务进入 *Running* 状态：

- 一个更高优先级的任务进入 *Ready* 状态。
- 当前 *Running* 状态的任务进入 *Blocked* 或 *Suspended* 状态。

不使用时间片轮转时，任务上下文切换的次数比使用时间片轮转时少。因此，关闭时间片轮转会减少调度程序的处理开销。然而，关闭时间片轮转也可能导致相同优先级的任务获得大不相同的处理时间，这种情况在图4.21中有所展示。因此，在没有时间片轮转的情况下运行调度程序被认为是一种高级技术，只应由有经验的用户使用。

<a name="fig4.21" title="图4.21 显示了在没有时间片轮转的情况下，相同优先级的任务如何获得大不相同的处理时间的执行模式"></a>

***
![](media/figure_4.21_equal_priority_without_time_slicing_execution_pattern.png)
***图4.21*** *在没有时间片轮转的情况下，相同优先级的任务如何获得大不相同的处理时间的执行模式*
***

参考图4.21，假设 `configIDLE_SHOULD_YIELD` 设置为 0：

- 计时器中断

  计时器中断发生在 t1、t2、t3、t4、t5、t8、t11、t12 和 t13 时。

- 任务 1

  任务 1 是一个高优先级的事件驱动任务，大部分时间处于 *Blocked* 状态，等待其感兴趣的事件。任务 1 在事件发生时从 *Blocked* 状态转换到 *Ready* 状态（并且，由于它是最高优先级的 *Ready* 状态任务，随后进入 *Running* 状态）。图 4.21 显示了任务 1 在 t6 和 t7 之间处理事件，然后在 t9 和 t10 之间再次处理事件。

- 空闲任务和任务 2

  空闲任务和任务 2 都是连续处理任务，优先级都为 0（空闲优先级）。连续处理任务不会进入 *Blocked* 状态。

  由于没有使用时间片轮转，因此处于 *Running* 状态的空闲优先级任务将一直保持在 *Running* 状态，直到被更高优先级的任务 1 抢占。

  在图 4.21 中，空闲任务从 t1 开始运行，并在被任务 1 在 t6 处抢占之前一直保持在 *Running* 状态，这比它进入 *Running* 状态后的四个完整的时钟周期还要长。

Task 2 在时间 t7 开始运行，此时 Task 1 重新进入 *Blocked* 状态以等待另一个事件。Task 2 保持在 *Running* 状态，直到在时间 t9 被 Task 1 预占，而时间 t9 早于它进入 *Running* 状态后的一个时钟周期。

  在时间 t10，空闲任务重新进入 *Running* 状态，尽管它已经获得了比 Task 2 多四倍以上的处理时间。

### 4.12.5 协作调度

  本书主要关注预占式调度，但 FreeRTOS 也可以使用协作调度。表 5 显示了 FreeRTOSConfig.h 中的设置，这些设置将 FreeRTOS 调度器配置为使用协作调度。

  使用协作调度器（因此假设应用程序提供的中断服务例程不会显式请求上下文切换）时，上下文切换只会在 *Running* 状态的任务进入 *Blocked* 状态，或者 *Running* 状态的任务显式让出（手动请求重新调度）时调用 `taskYIELD()`。任务永远不会被预占，因此时间片不能使用。

图 4.22 展示了合作式调度器的行为。图 4.22 中的水平虚线显示了任务处于就绪状态的时刻。

<a name="fig4.22" title="图 4.22 执行模式展示了合作式调度器的行为"></a>

***
![](media/figure_4.22_cooperative_scheduler_execution_pattern.png)
***图 4.22*** *执行模式展示了合作式调度器的行为*
***

参考图 4.22：

- 任务 1

  任务 1 的优先级最高。它从 *阻塞* 状态开始，等待一个信号量。

  在时间 t3，一个中断释放了信号量，导致任务 1 离开 *阻塞* 状态并进入 *就绪* 状态（从中断释放信号量的内容在第 6 章中介绍）。

  在时间 t3，任务 1 是优先级最高的 *就绪* 状态任务，如果使用的是抢占式调度器，任务 1 将成为运行状态任务。然而，由于使用的是合作式调度器，任务 1 将保持在 *就绪* 状态，直到时间 t4，此时运行状态任务调用 `taskYIELD()`。

- 任务 2

  任务 2 的优先级在任务 1 和任务 3 之间。它从 *Blocked* 状态开始，等待任务 3 在时间 t2 发送给它的消息。

  在时间 t2，任务 2 是优先级最高的 *Ready* 状态任务，如果使用的是抢占式调度器，任务 2 将成为 *Running* 状态任务。然而，由于使用的是合作式调度器，任务 2 将保持在 *Ready* 状态，直到 *Running* 状态任务进入 *Blocked* 状态或调用 `taskYIELD()`。

  *Running* 状态任务在时间 t4 调用 `taskYIELD()`，但那时任务 1 是优先级最高的 *Ready* 状态任务，因此任务 2 直到任务 1 在时间 t5 重新进入 *Blocked* 状态时才成为 *Running* 状态任务。

  在时间 t6，任务 2 重新进入 *Blocked* 状态以等待下一条消息，此时任务 3 再次成为优先级最高的 *Ready* 状态任务。

在多任务应用程序中，应用程序编写者必须确保资源不会被多个任务同时访问，因为同时访问可能会损坏资源。例如，考虑以下情景，其中访问的资源是 UART（串口）。两个任务向 UART 写入字符串；任务 1 写入 "abcdefghijklmnop"，任务 2 写入 "123456789"：

1. 任务 1 处于 *Running* 状态并开始写入其字符串。它将 "abcdefg" 写入 UART，但在写入更多字符之前离开 *Running* 状态。

1. 任务2进入*Running*状态并将"123456789"写入UART，然后离开*Running*状态。

1. 任务1重新进入*Running*状态并将其字符串的剩余字符写入UART。

在这种情况下，实际写入UART的内容是"abcdefg123456789hijklmnop"。任务1写入的字符串没有按预期的连续序列写入UART，而是被破坏了，因为任务2写入UART的字符串出现在其中。

使用合作调度器通常比使用抢占式调度器更容易避免由同时访问引起的问题[^7]：

[^7]: 本书后面将介绍任务之间安全共享资源的方法。FreeRTOS本身提供的资源，如队列和信号量，始终可以安全地在任务之间共享。

- 使用抢占式调度器时，*Running*状态的任务可以在任何时候被抢占，包括当它与另一个任务共享的资源处于不一致状态时。正如UART示例所演示的那样，将资源留在不一致状态可能会导致数据损坏。

- 当你使用合作式调度器时，你可以控制何时切换到另一个任务。因此，你可以确保在资源处于不一致状态时不会发生切换到另一个任务的情况。

- 在上述UART示例中，你可以确保任务1在将其整个字符串写入UART之前不会离开*Running*状态，从而消除字符串被另一个任务的活动破坏的可能性。

如图4.22所示，使用合作式调度器使系统比使用抢占式调度器时响应速度更慢：

- 使用抢占式调度器时，调度器在任务成为最高优先级*Ready*状态任务时立即开始运行该任务。这在必须在定义的时间期限内响应高优先级事件的实时系统中通常是必不可少的。

- 使用合作式调度器时，直到*Running*状态任务进入*Blocked*状态或调用`taskYIELD()`时，才会切换到成为最高优先级*Ready*状态任务的任务。



