# 4 任务管理

## 4.1 简介

### 4.1.1 范围

本章涵盖：

- FreeRTOS如何为应用程序中的每个任务分配处理时间。
- FreeRTOS如何选择在任何给定时间应该执行哪个任务。
- 每个任务的相对优先级如何影响系统行为。
- 任务可以存在的状态。

本章还讨论：

- 如何实现任务。
- 如何创建一个或多个任务实例。
- 如何使用任务参数。
- 如何更改已创建任务的优先级。
- 如何删除任务。
- 如何使用任务实现周期性处理。（后续章节描述了如何使用软件定时器完成相同的操作。）
- 空闲任务何时执行以及如何使用它。

本章中介绍的概念是理解如何使用FreeRTOS以及FreeRTOS应用程序如何运行的基础。因此，这是本书中最详细的一章。

## 4.2 任务函数

任务以 C 函数的形式实现。任务必须实现 Listing 4.1 中显示的预期函数原型，该原型接受一个 void 指针参数并返回 void。

<a name="list4.1" title="Listing 4.1 任务函数原型"></a>

```c
void vATaskFunction( void * pvParameters );
```

***Listing 4.1*** *任务函数原型*


每个任务本身就是一个小型程序。它具有入口点，通常在无限循环中永久运行，并且不会退出。Listing 4.2 显示了典型任务函数的结构。

FreeRTOS 任务不能以任何方式从实现它的函数中返回。它不能包含 'return' 语句，并且不能允许执行到其实现函数的末尾。如果任务不再需要，则应显式删除它，如 Listing 4.2 所示。

单个任务函数定义可用于创建任意数量的任务，每个创建的任务都是一个单独的执行实例。每个实例都有自己的堆栈，因此拥有任务本身中定义的任何自动（堆栈）变量的副本。



<a name="list4.2" title="Listing 4.2 典型任务函数的结构"></a>


```c
void vATaskFunction( void * pvParameters )
{
    /*
     * 堆栈分配的变量可以在函数内部正常声明。
     * 使用此示例函数创建的每个任务实例将在任务的堆栈上为其
     * 自己的 lStackVariable 实例分配。
     */
    long lStackVariable = 0;

    /*
     * 与堆栈分配的变量相反，使用 `static`
     * 关键字声明的变量由链接器分配到内存中的特定位置。
     * 这意味着调用 vATaskFunction 的所有任务将共享
     * lStaticVariable 的相同实例。
     */
    static long lStaticVariable = 0;

    for( ;; )
    {
        /* 任务功能实现的代码将在此处。 */
    }

    /*
     * 如果任务实现从上述循环退出，则在到达其实现函数的末尾之前，
     * 必须删除该任务。
     * 当将 NULL 作为参数传递给 vTaskDelete() API 函数时，
     * 这表示要删除的任务是调用（此）任务。
     */
    vTaskDelete( NULL );
}
```

***Listing 4.2*** *典型任务函数的结构*

## 4.3 顶层任务状态

一个应用程序可能由许多任务组成。如果运行应用程序的处理器包含单个核心，那么在任何给定时间只能有一个任务在执行。这意味着任务可能存在于两种状态中的一种：*运行中* 和 *未运行中*。首先考虑这种简单的模型。在本文章的后面，我们将描述 *未运行中* 状态的几个子状态。

当处理器正在执行任务的代码时，任务处于 *运行中* 状态。当任务处于 *未运行中* 状态时，任务被暂停，并且其状态已被保存，以便在调度器决定它应该进入 *运行中* 状态时可以恢复执行。当任务恢复执行时，它从在离开 *运行中* 状态之前即将要执行的指令处继续执行。

<a name="fig4.1" title="Figure 4.1 顶层任务状态和转换"></a>

***
![](media/figure_4.1_top_level_task_states.png)
***Figure 4.1*** *顶层任务状态和转换*
***

从 *未运行中* 状态转换到 *运行中* 状态的任务被称为“切换入”或“交换入”。相反，从 *运行中* 状态转换到 *未运行中* 状态的任务被称为“切换出”或“交换出”。FreeRTOS 调度器是唯一可以切换任务进出 *运行中* 状态的实体。

## 4.4 任务创建

可以使用六个 API 函数来创建任务：
`xTaskCreate()`,
`xTaskCreateStatic()`,
`xTaskCreateRestricted()`,
`xTaskCreateRestrictedStatic()`,
`xTaskCreateAffinitySet()`, 和
`xTaskCreateStaticAffinitySet()`

每个任务需要两个 RAM 块：一个用于存储其任务控制块 (TCB)，另一个用于存储其堆栈。带有 "Static" 在名称中的 FreeRTOS API 函数使用预分配的 RAM 块，这些 RAM 块作为参数传递给函数。相反，名称中不带有 "Static" 的 API 函数在运行时从系统堆中动态分配所需的 RAM。

某些 FreeRTOS 端口支持在“受限”或“非特权”模式下运行的任务。名称中带有 "Restricted" 的 FreeRTOS API 函数创建以有限访问权限执行系统的内存的任务。名称中不带有 "Restricted" 的 API 函数创建在“特权模式”下执行的任务，并且可以访问系统的整个内存映射。

支持对称多处理 (SMP) 的 FreeRTOS 端口允许不同的任务在同一 CPU 的多个核心上同时运行。对于这些端口，可以使用名称中带有 "Affinity" 的函数来指定任务将在哪个核心上运行。

FreeRTOS 任务创建 API 函数相当复杂。本文档中的大多数示例使用 `xTaskCreate()`，因为它这些函数中最简单的一个。

### 4.4.1 `xTaskCreate()` API 函数

清单 4.3 显示了 `xTaskCreate()` API 函数原型。
`xTaskCreateStatic()` 有两个额外的参数，分别指向预分配的用于存储任务的数据结构和堆栈的内存。[第 2.5 节：数据类型和编码风格指南](ch02.md#25-data-types-and-coding-style-guide) 描述了所使用的数据类型和命名约定。


<a name="list4.3" title="清单 4.3 `xTaskCreate()` API 函数原型"></a>


```c
BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,
                        const char * const pcName,
                        configSTACK_DEPTH_TYPE usStackDepth,
                        void * pvParameters,
                        UBaseType_t uxPriority,
                        TaskHandle_t * pxCreatedTask );
```

***清单 4.3*** *`xTaskCreate()` API 函数原型*

**`xTaskCreate()` 参数和返回值：**

- `pvTaskCode`

  任务本质上是永远不会退出的 C 函数，因此通常
  实现为无限循环。`pvTaskCode` 参数只是一个
  指向实现任务的函数的指针（实际上，只是函数名）。

- `pcName`

  任务的描述性名称。FreeRTOS 不会以任何方式使用此名称，它仅用于调试。通过人类可读的名称识别任务比通过其句柄识别任务要简单得多。

  应用程序定义的常量 `configMAX_TASK_NAME_LEN` 定义了任务名称的最大长度，包括 NULL 终止符。提供更长的字符串会导致字符串被截断。

- `usStackDepth`

  指定为任务使用的堆栈分配的大小。
  使用 `xTaskCreateStatic()` 代替 `xTaskCreate()` 来使用预分配的内存，而不是动态分配的内存。

  请注意，该值指定堆栈可以容纳的单词数，而不是字节数。例如，如果堆栈宽度为 32 位，并且 `usStackDepth` 为 128，则 `xTaskCreate()` 将分配 512 字节的堆栈空间（128 * 4 字节）。

  `configSTACK_DEPTH_TYPE` 是一个宏，允许应用程序编写者指定用于存储堆栈大小的数据类型。如果未定义，`configSTACK_DEPTH_TYPE` 默认为 `uint16_t`，因此，如果在 `FreeRTOSConfig.h` 中将 `#define` `configSTACK_DEPTH_TYPE` 定义为 `unsigned long` 或 `size_t`，如果堆栈深度乘以堆栈宽度大于 65535（16 位数的最大值），则需要这样做。

[第13.3节 堆栈溢出](ch13.md#133-stack-overflow) 描述了一种选择最佳堆栈大小的实用方法。

- `pvParameters`

  实现任务的函数接受一个单独的 void 指针 (`void *`) 参数。`pvParameters` 是通过该参数传递到任务中的值。

- `uxPriority`

  定义任务的优先级。0 是最低优先级，`(configMAX_PRIORITIES – 1)` 是最高优先级。[第4.5节](#45-task-priorities) 描述了用户定义的 `configMAX_PRIORITIES` 常量。

  如果定义了大于 `(configMAX_PRIORITIES – 1)` 的 `uxPriority`，它将被限制为 `(configMAX_PRIORITIES – 1)`。

- `pxCreatedTask`

  指向存储创建任务句柄的位置的指针。此句柄可以在未来的 API 调用中使用，例如，更改任务的优先级或删除任务。

  `pxCreatedTask` 是一个可选参数，如果不需要任务句柄，可以将其设置为 NULL。

- 返回值

  有两种可能的返回值：

  - `pdPASS`

    这表示任务创建成功。

- `pdFAIL`

    这表示没有足够的堆内存来创建任务。[第3章](ch03.md#3-heap-memory-management) 提供了有关堆内存管理的更多信息。


<a name="example4.1" title="示例 4.1 创建任务"></a>
---
***示例 4.1*** *创建任务*

---

以下示例演示了创建两个简单任务并启动这些新创建的任务所需的步骤。这些任务通过使用粗略的忙循环来创建周期性延迟，定期打印出一个字符串。这两个任务都以相同的优先级创建，并且除了它们打印出的字符串外，它们是相同的——请参阅清单 4.4 和清单 4.5 以获取它们的各自实现。请参阅第 8 章以获取有关在任务中使用 `printf()` 的警告。

<a name="list4.4" title="清单 4.4 示例 4.1 中使用的第一个任务的实现"></a>


```c
void vTask1( void * pvParameters )
{
    /* ulCount 被声明为 volatile 以确保它不会被优化掉。 */
    volatile unsigned long ulCount;

    for( ;; )
    {
        /* 打印当前任务的任务名称。 */
        vPrintLine( "Task 1 is running" );

        /* 延迟一段时间。 */
        for( ulCount = 0; ulCount < mainDELAY_LOOP_COUNT; ulCount++ )
        {
            /*
             * 此循环只是一个非常粗略的延迟实现。 在这里没有什么可做的。 后面的示例将使用适当的延迟/休眠函数替换此粗略的
             * 循环。
             */
        }
    }
}
```

***清单 4.4*** *示例 4.1 中使用的第一个任务的实现*


<a name="list4.5" title="清单 4.5 示例 4.1 中使用的第二个任务的实现"></a>


```c
void vTask2( void * pvParameters )
{
    /* ulCount 被声明为 volatile 以确保它不会被优化掉。 */
    volatile unsigned long ulCount;

    /* 像大多数任务一样，此任务是在一个无限循环中实现的。 */
    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( "Task 2 is running" );

        /* 延迟一段时间。 */
        for( ulCount = 0; ulCount < mainDELAY_LOOP_COUNT; ulCount++ )
        {
            /*
             * 此循环只是一个非常粗略的延迟实现。 在这里没有什么可做的。 后面的示例将使用适当的延迟/休眠函数替换此粗略的
             * 循环。
             */
        }
    }
}
```

***清单 4.5*** *示例 4.1 中使用的第二个任务的实现*

main() 函数在启动调度程序之前创建任务——请参阅清单 4.6 以获取其实现。

<a name="list4.6" title="清单 4.6 启动示例 4.1 中的任务"></a>


```c
int main( void )
{
    /*
     * 在此处声明的变量可能在启动 FreeRTOS
     * 调度程序后不再存在。 不要尝试从任务访问在 main() 的堆栈上声明的变量。
     */

    /*
     * 创建两个任务之一。 请注意，实际应用程序应检查
     * xTaskCreate() 调用的返回值，以确保任务已成功创建。
     */
    xTaskCreate( vTask1,  /* 指向实现任务的函数的指针。*/
                 "Task 1",/* 任务的文本名称。 */
                 1000,    /* 堆栈深度（以字为单位）。 */
                 NULL,    /* 此示例未使用任务参数。 */
                 1,       /* 此任务将以优先级 1 运行。 */
                 NULL );  /* 此示例未使用任务句柄。 */

    /* 以相同的方式和相同优先级创建另一个任务。*/
    xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL );

    /* 启动调度程序，以便任务开始执行。 */
    vTaskStartScheduler();

    /*
     * 如果一切顺利，main() 将无法到达此处，因为调度程序现在将运行已创建的任务。 如果 main() 达到此处，则表示没有足够的堆内存来创建空闲任务或计时器任务
     * （本书稍后会描述）。 第 3 章提供了有关堆内存管理的更多信息。
     */
    for( ;; );
}
```

***清单 4.6*** *启动示例 4.1 中的任务*

执行示例会产生图 4.2 中所示的输出。

<a name="fig4.2" title="图 4.2 执行示例 4.1 产生的输出"></a>

***

```console
C:\Temp>rtosdemo
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
```

***图 4.2*** *执行示例 4.1 产生的输出[^4]*

***

[^4]: 屏幕截图显示每个任务在下一个任务执行之前打印其消息一次。 这是一个由使用 FreeRTOS Windows 模拟器产生的虚构场景。 Windows 模拟器并非真正的实时系统。 此外，写入 Windows 控制台需要相对较长的时间，并导致一系列 Windows 系统调用。 在具有快速且非阻塞打印函数的真实嵌入式目标上执行相同的代码，可能会导致每个任务在其被切换以允许其他任务运行之前打印其字符串多次。

图 4.2 显示了两个任务似乎同时执行；然而，这两个任务都在同一个处理器核心上执行，因此事实并非如此。实际上，这两个任务正在快速地进入和退出 *运行* 状态。这两个任务具有相同的优先级，因此它们在同一个处理器核心上共享时间。图 4.3 显示了它们的实际执行模式。

图 4.3 底部箭头显示了时间从 t1 时刻开始流逝。彩色线条显示了在每个时间点哪个任务正在执行——例如，Task 1 在 t1 和 t2 时刻之间执行。

任何时候只能有一个任务处于 *运行* 状态。因此，当一个任务进入 *运行* 状态（任务被切换进）时，另一个任务就会进入 *未运行* 状态（任务被切换出）。

<a name="fig4.3" title="图 4.3 示例 4.1 的两个任务的实际执行模式"></a>

***
![](media/figure_4.3_example_4.1_execution_pattern.png)
***图 4.3*** *示例 4.1 的两个任务的实际执行模式*
***

示例 4.1 在启动调度器之前，在 `main()` 函数内部创建了这两个任务。 也可以在另一个任务内部创建任务。例如，Task 2 可以由 Task 1 创建，如 Listing 4.7 所示。

<a name="list4.7" title="列表 4.7 在调度器启动后，在另一个任务内部创建任务"></a>

```c
void vTask1( void * pvParameters )
{
    const char *pcTaskName = "Task 1 正在运行\r\n";
    volatile unsigned long ul; /* volatile 以确保 ul 不被优化掉。 */

    /*
     * 如果此任务代码正在执行，则调度器必须已经启动。
     * 在进入无限循环之前创建另一个任务。
     */
    xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL );

    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( pcTaskName );

        /* 延迟一段时间。 */
        for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
        {
            /*
             * 此循环只是一个非常粗糙的延迟实现。 在这里没有什么可做的。
             * 后面的示例将用适当的延迟/休眠函数替换此粗糙的循环。
             */
        }
    }
}
```

***列表 4.7*** *在调度器启动后，在另一个任务内部创建任务*

<a name="example4.2" title="示例 4.2 使用任务参数"></a>
---
***示例 4.2*** *使用任务参数*

---

示例 4.1 中创建的两个任务几乎相同，它们之间的唯一区别是它们打印出的文本字符串。 如果你创建单个任务实现的两实例，并使用任务参数将字符串传递到每个实例，这将消除重复。

示例 4.2 使用单个任务函数 `vTaskFunction()` 替换了示例 4.1 中使用的两个任务函数，如列表 4.8 所示。
注意如何将任务参数强制转换为 `char *` 以获取任务应打印的字符串。

<a name="list4.8" title="列表 4.8 示例 4.2 中用于创建两个任务的单个任务函数"></a>

```c
void vTaskFunction( void * pvParameters )
{

    char *pcTaskName;
    volatile unsigned long ul; /* volatile 以确保 ul 不被优化掉。 */

    /*
     * 要打印的字符串通过参数传递。 将其强制转换为字符指针。
     */
    pcTaskName = ( char * ) pvParameters;

    /* 像大多数任务一样，此任务以无限循环实现。 */
    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( pcTaskName );

        /* 延迟一段时间。 */
        for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
        {
            /*
             * 此循环只是一个非常粗糙的延迟实现。 在这里没有什么可做的。 后面的练习将用适当的延迟/休眠函数替换此粗糙的循环。
             */
        }
    }
}
```

***列表 4.8*** *示例 4.2 中用于创建两个任务的单个任务函数*

列表 4.9 创建了 `vTaskFunction()` 实现的任务的两个实例，使用任务的参数将不同的字符串传递到每个实例中。 这两个任务在 FreeRTOS 调度器的控制下独立执行，并且拥有自己的堆栈，因此拥有自己的 `pcTaskName` 和 `ul` 变量副本。

<a name="list4.9" title="列表 4.9 示例 2 的 main() 函数"></a>

```c
/*
 * 定义将作为任务参数传递的字符串。 这些字符串被定义为const，而不是由main()使用的堆栈定义，以确保它们在任务执行时保持有效。
 */
static const char * pcTextForTask1 = "Task 1 is running";
static const char * pcTextForTask2 = "Task 2 is running";

int main( void )
{
    /*
     * 在这里声明的变量在启动 FreeRTOS
     * 调度器后可能不再存在。 不要尝试从任务访问由 main() 使用的堆栈上声明的变量。
     */

    /* 创建两个任务中的一个。 */
    xTaskCreate( vTaskFunction,             /* 指向实现任务的函数的指针。 */
                 "Task 1",                  /* 任务的文本名称。 这仅用于
                                               调试。 */
                 1000,                      /* 堆栈深度 - 小型微控制器
                                               将使用比这少的堆栈。*/
                 ( void * ) pcTextForTask1, /* 使用任务参数将要打印的文本传递到
                                               任务中。 */
                 1,                         /* 此任务将以优先级 1 运行。 */
                 NULL );                    /* 不在此示例中使用任务句柄。 */

    /*
     * 以完全相同的方式创建另一个任务。 注意这次，
     * 多个任务是从相同的任务实现 (vTaskFunction) 创建的。 不同的只是传递的参数值。
     * 正在创建相同任务定义的两实例。
     */
    xTaskCreate( vTaskFunction,
                 "Task 2",
                 1000,
                 ( void * ) pcTextForTask2,
                 1,
                 NULL );

    /* 启动调度器，以便任务开始执行。 */
    vTaskStartScheduler();

    /*
     * 如果一切顺利，main() 将无法到达这里，因为调度器现在将运行创建的任务。 如果 main() 确实到达这里，则表示没有足够的堆内存来创建空闲任务或定时器任务
     * (本书后面会描述)。 第 3 章提供了有关堆内存管理的更多信息。
     */
    for( ;; )
    {
    }
}
```

***列表 4.9*** *示例 2 的 main() 函数*

示例 4.2 的输出与图 4.2 中示例 1 的输出完全相同。

## 4.5 任务优先级

FreeRTOS 调度器始终确保能够运行的最高优先级任务被选定进入 *运行* 状态。 具有相同优先级的任务会轮流进入和退出 *运行* 状态。

用于创建任务的 API 函数的 `uxPriority` 参数为任务设置其初始优先级。 `vTaskPrioritySet()` API 函数可以在任务创建后更改任务的优先级。

应用程序定义的编译时配置常量 `configMAX_PRIORITIES` 设置可用优先级的数量。 低数值优先级值表示低优先级任务，优先级 0 是可能的最低优先级——因此有效优先级范围从 0 到 `(configMAX_PRIORITIES – 1)`。 任意数量的任务可以共享相同的优先级。

FreeRTOS 调度器有两种实现用于选择 *运行* 状态任务的算法，并且 `configMAX_PRIORITIES` 的最大允许值取决于所使用的实现：

### 4.5.1 通用调度器

通用调度器用 C 编写，可以与所有 FreeRTOS 架构端口一起使用。 它对 `configMAX_PRIORITEIS` 不施加上限。 通常，建议最小化 `configMAX_PRIORITIES`，因为更多的值需要更多的 RAM，并且会导致更长的最坏情况执行时间。

### 4.5.2 架构优化调度器

架构优化实现是用架构特定的汇编代码编写的，比通用的 C 实现更高效，并且对于所有 `configMAX_PRIORITIES` 值，最坏情况执行时间相同。

架构优化实现对 `configMAX_PRIORITIES` 施加了 32 位架构上的最大值 32 和 64 位架构上的 64。 像通用方法一样，建议将 `configMAX_PRIORITIES` 保持在实际情况下最低的值，因为更高的值需要更多的 RAM。

在 FreeRTOSConfig.h 中将 `configUSE_PORT_optimized_TASK_SELECTION` 设置为 1 以使用架构优化实现，或设置为 0 以使用通用实现。 并非所有 FreeRTOS 端口都有架构优化实现。 那些有的话，默认将 `configUSE_PORT_optimized_TASK_SELECTION` 设置为 1，如果它未定义。 那些没有的话，默认将 `configUSE_PORT_optimized_TASK_SELECTION` 设置为 0，如果它未定义。

## 4.6 时间测量和滴答中断

[第 4.12 节，调度算法](#412-scheduling-algorithms)，描述了一个可选功能，称为“时间分片”。时间分片已在迄今为止呈现的示例中使用，并且是它们产生的输出所观察到的行为。在这些示例中，两个任务都以相同的优先级创建，并且两个任务始终能够运行。因此，每个任务在时间分片的开始时进入 *运行* 状态，并在时间分片的结束时退出 *运行* 状态，执行了“时间分片”的时间。在图 4.3 中，t1 和 t2 之间的时间等于一个时间分片。

调度器在每个时间分片的结束时执行，以选择要运行的下一个任务[^5]。为此目的，使用一个周期性中断，称为“滴答中断”。编译时配置常量 `configTICK_RATE_HZ` 设置了滴答中断的频率，也设置了每个时间分片的长度。例如，将 `configTICK_RATE_HZ` 设置为 100 (Hz) 将导致每个时间分片持续 10 毫秒。两个滴答中断之间的时间称为“滴答周期”——一个时间分片等于一个滴答周期。

[^5]: 重要的是要注意，时间分片的结束并不是调度器可以选择新任务运行的唯一位置。正如我们将在本书的后续章节中演示的那样，当当前正在执行的任务进入 *阻塞* 状态，或者当中断将更高优先级的任务移动到 *就绪* 状态时，调度器也会立即选择一个新任务运行。

图 4.4 扩展了图 4.3，还显示了调度器的执行情况。在图 4.4 中，顶行显示了调度器何时执行，细箭头显示了从任务到滴答中断的执行顺序，然后从滴答中断返回到不同的任务的执行顺序。

`configTICK_RATE_HZ` 的最佳值取决于应用程序，尽管通常使用 100 的值。

<a name="fig4.4" title="Figure 4.4 The execution sequence expanded to show the tick interrupt executing"></a>

***
![](media/figure_4.4_expanded_execution_sequence_with_tick_interrupt.png)
***图 4.4*** *执行序列扩展，显示滴答中断正在执行*
***

FreeRTOS API 调用使用滴答周期的倍数来指定时间，通常简称为“滴答”。`pdMS_TO_TICKS()` 宏将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。可用的分辨率取决于定义的滴答频率，如果滴答频率高于 1KHz（如果 `configTICK_RATE_HZ` 大于 1000），则不能使用 `pdMS_TO_TICKS()`。清单 4.10 演示了如何使用 `pdMS_TO_TICKS()` 将以 200 毫秒指定的时间转换为等效的以滴答为单位指定的时间。

<a name="list4.10" title="Listing 4.10 Using the pdMS\_TO\_TICKS() macro to convert 200 milliseconds..."></a>

```c
/*
 * pdMS_TO_TICKS() 接受以毫秒为单位的时间作为其唯一的参数，
 * 并计算得出等效的滴答周期数。 此示例显示
 * xTimeInTicks 被设置为等效于 200 毫秒的滴答周期数。
 */
TickType_t xTimeInTicks = pdMS_TO_TICKS( 200 );
```

***清单 4.10*** *使用 pdMS\_TO\_TICKS() 宏将 200 毫秒转换为等效的滴答周期数*

使用 `pdMS_TO_TICKS()` 以毫秒为单位指定时间，而不是直接以滴答为单位指定时间，可确保在更改滴答频率时，应用程序中指定的时间不会发生变化。

“滴答计数”是指自调度器启动以来发生的滴答中断的总数，假设滴答计数尚未溢出。 用户应用程序在指定延迟周期时无需考虑溢出，因为 FreeRTOS 内部管理时间一致性。

[第 4.12 节：调度算法](#412-scheduling-algorithms)
描述了影响调度器何时选择新的任务运行以及何时执行滴答中断的配置常量。

<a name="example4.3" title="Example 4.3 Experimenting with priorities"></a>
---
***示例 4.3*** *实验优先级*

---

调度器将始终确保可以运行的最高优先级任务被选定以进入 *运行* 状态。到目前为止创建的示例创建了两个具有相同优先级的任务，因此这两个任务轮流进入和退出 *运行* 状态。此示例研究了任务具有不同优先级时会发生什么。清单 4.11 显示了用于创建任务的代码，第一个任务的优先级为 1，第二个任务的优先级为 2。实现这两个任务的单个函数没有改变；它仍然周期性地打印字符串，使用空循环来创建延迟。


<a name="list4.11" title="Listing 4.11. Creating two tasks at different priorities"></a>


```c
/*
 * 定义将作为任务参数传递的字符串。
 * 这些字符串定义为 const，而不是在堆栈上，以确保在任务执行时它们保持有效。
 */
static const char * pcTextForTask1 = "Task 1 is running";
static const char * pcTextForTask2 = "Task 2 is running";

int main( void )
{
    /* 创建具有优先级 1 的第一个任务。 */
    xTaskCreate( vTaskFunction,             /* 任务函数 */
                 "Task 1",                  /* 任务名称 */
                 1000,                      /* 任务堆栈深度 */
                 ( void * ) pcTextForTask1, /* 任务参数 */
                 1,                         /* 任务优先级 */
                 NULL );

    /* 以更高的优先级 2 创建第二个任务。 */
    xTaskCreate( vTaskFunction,             /* 任务函数 */
                 "Task 2",                  /* 任务名称 */
                 1000,                      /* 任务堆栈深度 */
                 ( void * ) pcTextForTask2, /* 任务参数 */
                 2,                         /* 任务优先级 */
                 NULL );

    /* 启动调度器，以便任务开始执行。 */
    vTaskStartScheduler();

    /* 不会到达这里。 */
    return 0;
}
```

***清单 4.11*** *创建两个具有不同优先级的任务*

图 4.5 显示了示例 4.3 产生的输出。

调度器将始终选择可以运行的最高优先级任务。
任务 2 的优先级高于任务 1，并且可以始终运行；因此，调度器始终选择任务 2，任务 1 从未执行。任务 1 被说成是被任务 2 “剥夺”了处理时间——因为它从未处于 *运行* 状态，所以无法打印其字符串。


<a name="fig4.5" title="Figure 4.5 Running both tasks at different priorities"></a>

***
```console
C:\Temp>rtosdemo
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
Task 2 is running
```

***图 4.5*** *在不同优先级下运行两个任务*
***

任务 2 总是可以运行，因为它不必等待任何事情——它要么循环一个空循环，要么打印到终端。


<a name="fig4.6" title="Figure 4.6 The execution pattern when one task has a higher priority than the..."></a>

***
![](media/figure_4.6_execution_pattern_higher_priority_task.png)
***图 4.6*** *示例 4.3 中，一个任务优先级高于另一个任务时的执行模式*


## 4.7 扩展 *未运行* 状态

到目前为止，创建的任务总是需要执行处理，并且从未需要等待任何事情——由于它们从未需要等待任何事情，因此它们总是能够进入 *运行* 状态。这种“连续处理”任务的用处有限，因为它们只能以最低优先级创建。如果它们以任何其他优先级运行，它们将阻止任何较低优先级的任务运行。

为了使这些任务有用，必须将其重写为事件驱动型任务。事件驱动型任务只有在事件触发后才需要执行（处理），并且在发生该事件之前无法进入 *运行* 状态。调度器将始终选择可以运行的最高优先级任务。如果由于正在等待事件而无法选择高优先级任务，调度器必须改为选择可以运行的较低优先级任务。因此，编写事件驱动型任务意味着可以在不同的优先级下创建任务，而不会导致最高优先级任务剥夺所有较低优先级任务的处理时间。

### 4.7.1 *阻塞* 状态

等待事件的任务被称为处于“阻塞”状态，这是 *未运行* 状态的一个子状态。

任务可以进入 *阻塞* 状态以等待两种不同类型的事件：

1. 时序（时间相关）事件——这些事件发生在延迟期到期或达到绝对时间时。例如，任务可能进入 *阻塞* 状态以等待 10 毫秒的延迟。

2. 同步事件——这些事件源自另一个任务或中断。例如，任务可能进入 *阻塞* 状态以等待队列中的数据到达。同步事件涵盖了广泛的事件类型。

FreeRTOS 队列、二进制信号量、计数信号量、互斥锁、递归互斥锁、事件组、流缓冲区、消息缓冲区以及直接任务通知都可以创建同步事件。 后面的章节将涵盖这些功能中的大部分。

任务可以对同步事件进行超时阻塞，有效地同时阻塞两种类型的事件。例如，任务可以选择等待最多 10 毫秒的数据到达队列。如果数据在 10 毫秒内到达，或者 10 毫秒内没有数据到达，任务将离开 *阻塞* 状态。

### 4.7.2 *挂起* 状态

*挂起* 也是 *未运行* 状态的一个子状态。处于挂起状态的任务不可用给调度器。进入挂起状态的唯一方法是通过调用 `vTaskSuspend()` API 函数，而退出挂起状态的唯一方法是通过调用 `vTaskResume()` 或 `xTaskResumeFromISR()` API 函数。大多数应用程序不使用挂起状态。

### 4.7.3 就绪状态

处于 *未运行* 状态，且未 *阻塞* 或 *挂起* 的任务被称为处于 *就绪* 状态。 它们可以运行，因此是“准备好”运行，但当前不在 *运行* 状态。

### 4.7.4 完成状态转换图

图 4.7 扩展了简化的状态图，以包含本节中描述的所有 *未运行* 子状态。到目前为止示例中创建的任务尚未使用 *阻塞* 或 *挂起* 状态。 它们仅在 *就绪* 状态和 *运行* 状态之间转换，如图 4.7 中的粗线所示。

<a name="fig4.7" title="图 4.7 完整的任务状态机"></a>

***
![](media/figure_4.7_full_task_state_machine.png)
***图 4.7*** *完整的任务状态机*
***

<a name="example4.4" title="示例 4.4 使用阻塞状态创建延迟"></a>
---
***示例 4.4*** *使用 *阻塞* 状态创建延迟*</h3>

---

到目前为止，所呈现的示例中创建的所有任务都是“周期性”任务——它们延迟了一段时间，然后打印出它们的字符串，然后再延迟一次，依此类推。 延迟是通过一个空循环生成的——任务轮询一个递增的循环计数器，直到它达到一个固定值。 示例 4.3 清楚地演示了这种方法的缺点。 高优先级任务在执行空循环时保持在 *运行* 状态，从而“剥夺”了低优先级任务的任何处理时间。

任何形式的轮询都有几个其他的缺点，其中最主要的是它的低效率。 在轮询期间，任务实际上没有任何工作要做，但它仍然使用最大的处理时间，从而浪费了处理器周期。 示例 4.4 通过将轮询空循环替换为对 `vTaskDelay()` API 函数的调用来纠正此行为，该函数的原型在清单 4.12 中所示。 新的任务定义在清单 4.13 中所示。 请注意，`vTaskDelay()` API 函数仅在 FreeRTOSConfig.h 中将 `INCLUDE_vTaskDelay` 设置为 1 时可用。

`vTaskDelay()` 将调用任务置于 *阻塞* 状态，持续固定数量的滴答中断。 任务在 *阻塞* 状态下不会消耗任何处理时间，因此只有在有实际工作要做时才会消耗处理时间。


<a name="list4.12" title="清单 4.12 vTaskDelay() API 函数原型"></a>


```c
void vTaskDelay( TickType_t xTicksToDelay );
```

***清单 4.12*** *vTaskDelay() API 函数原型*

**vTaskDelay 参数：**

- `xTicksToDelay`

  调用任务将在 *阻塞* 状态下保持的时间（以滴答中断为单位），然后再过渡回就绪状态。

  例如，如果一个任务在滴答计数为 10,000 时调用 `vTaskDelay( 100 )`，那么它将立即进入 *阻塞* 状态，并保持在 *阻塞* 状态，直到滴答计数达到 10,100。

  宏 `pdMS_TO_TICKS()` 可用于将以毫秒指定的时间转换为以滴答指定的时间。 例如，调用 `vTaskDelay( pdMS_TO_TICKS( 100 ) )` 将导致调用任务在 *阻塞* 状态下保持 100 毫秒。

<a name="list4.13" title="清单 4.13 示例任务的源代码，用对 vTaskDelay() 的调用替换了空循环延迟..."></a>

```c
void vTaskFunction( void * pvParameters )
{
    char * pcTaskName;
    const TickType_t xDelay250ms = pdMS_TO_TICKS( 250 );

    /*
     * 要打印的字符串通过参数传递。将其转换为字符指针。
     */
    pcTaskName = ( char * ) pvParameters;

    /* 像大多数任务一样，此任务以无限循环实现。 */
    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( pcTaskName );

        /*
         * 延迟一段时间。这次使用对 vTaskDelay() 的调用，该调用
         * 将任务置于阻塞状态，直到延迟期过到期。参数采用以“滴答”为单位的时间，并且
         * pdMS_TO_TICKS() 宏用于（在声明 xDelay250ms 常数的地方）将 250 毫秒转换为
         * 等效的滴答时间。
         */
        vTaskDelay( xDelay250ms );
    }
}
```

***清单 4.13*** *示例任务的源代码，用对 vTaskDelay() 的调用替换了空循环延迟*

尽管这两个任务仍然以不同的优先级创建，但它们现在都会运行。示例 4.4 的输出，如图 4.8 所示，证实了预期的行为。

<a name="fig4.8" title="图 4.8 执行示例 4.4 时产生的输出"></a>

***

```console
C:\Temp>rtosdemo
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
Task 2 is running
Task 1 is running
```

***图 4.8*** *执行示例 4.4 时产生的输出*
***

图 4.9 所示的执行序列解释了为什么即使任务以不同的优先级创建，它们也会运行。为了简化起见，省略了调度器本身的执行。

当调度器启动时，会创建空闲任务，以确保始终至少有一个任务可以运行（至少有一个任务处于 *就绪* 状态）。[第 4.8 节：空闲任务和空闲任务挂钩](#48-the-idle-task-and-the-idle-task-hook) 详细描述了空闲任务。

<a name="fig4.9" title="图 4.9 任务使用 vTaskDelay() 替换空循环时的执行序列"></a>

***
![](media/figure_4.9_vTaskDelay_execution_sequence.png)
***图 4.9*** *任务使用 vTaskDelay() 替换空循环时的执行序列*
***

仅更改了两个任务的实现，而没有更改其功能。将图 4.9 与图 4.4 进行比较清楚地表明，以一种更有效的方式实现了这种功能。

图 4.4 显示了任务使用空循环来创建延迟时的执行模式，因此它们始终能够运行。结果，它们在可用处理器时间内共享百分之百的使用率。图 4.9 显示了任务在整个延迟期间进入 *Blocked* 状态时的执行模式。 只有在它们实际需要执行工作时（在本例中只是打印一条消息），才会使用处理器时间，因此它们仅使用可用处理时间的很小一部分。

在图 4.9 所示的场景中，每次任务离开 *Blocked* 状态时，它们会在重新进入 Blocked 状态之前执行一小段时间。 大部分时间，没有可以运行的应用程序任务（没有处于 *Ready* 状态的应用程序任务），因此没有可以被选入 *Running* 状态的应用程序任务。 在这种情况下，空闲任务会运行。 分配给空闲任务的处理时间是系统备用处理能力的度量。 通过允许应用程序完全基于事件驱动，RTOS 可以显著增加备用处理能力。

图 4.10 中的粗线显示了示例 4.4 中任务执行的转换，每个任务现在在返回到 *Ready* 状态之前会转换通过 *Blocked* 状态。

<a name="fig4.10" title="Figure 4.10 Bold lines indicate the state transitions performed by the tasks..."></a>

***
![](media/figure_4.10_example_4.4_state_machine.png)
***图 4.10*** *粗线指示示例 4.4 中任务执行的状态转换*
***

### 4.7.5 vTaskDelayUntil() API 函数

`vTaskDelayUntil()` 与 `vTaskDelay()` 类似。 正如前面演示的，`vTaskDelay()` 参数指定了任务调用 `vTaskDelay()` 和同一任务再次从 *Blocked* 状态转换出来之间应该发生的滴答中断的数量。 任务在阻塞状态中停留的时间由 `vTaskDelay()` 参数指定，但任务离开阻塞状态的时间是相对于调用 `vTaskDelay()` 的时间而言的。

`vTaskDelayUntil()` 的参数指定了调用任务应该从 Blocked 状态移动到 *Ready* 状态的确切滴答计数值。 当需要固定的执行周期时（您希望您的任务以固定的频率定期执行），应使用 `vTaskDelayUntil()` API 函数，因为调用任务解除阻塞的时间是绝对的，而不是相对于调用函数的时间（如 `vTaskDelay()` 的情况）。

<a name="list4.14" title="Listing 4.14 vTaskDelayUntil() API function prototype"></a>

```c
void vTaskDelayUntil( TickType_t * pxPreviousWakeTime,
                      TickType_t xTimeIncrement );
```

***列表 4.14*** *vTaskDelayUntil() API 函数原型*

**vTaskDelayUntil() 参数**

- `pxPreviousWakeTime`

  此参数的命名是基于假设 `vTaskDelayUntil()` 用于实现一个周期性执行且具有固定频率的任务。 在这种情况下，`pxPreviousWakeTime` 存储任务离开 *Blocked* 状态的时间（“唤醒”）。 此时间用作参考点，以计算任务应该下次离开 *Blocked* 状态的时间。

`pxPreviousWakeTime` 指向的变量会在 `vTaskDelayUntil()` 函数中自动更新；通常情况下，应用程序代码不会修改它，但在首次使用之前必须将其初始化为当前滴答计数。 列表 4.15 演示了如何初始化该变量。

- `xTimeIncrement`

  此参数的命名也是基于假设 `vTaskDelayUntil()` 用于实现一个周期性执行且具有固定频率的任务，该频率由 `xTimeIncrement` 值设置。

  `xTimeIncrement` 以“滴答”为单位指定。 可以使用宏 `pdMS_TO_TICKS()` 将毫秒指定的时间转换为滴答指定的时间。

<a name="example4.5" title="Example 4.5 Converting the example tasks to use vTaskDelayUntil()"></a>
---
***示例 4.5*** *将示例任务转换为使用 vTaskDelayUntil()*

---

示例 4.4 中创建的两个任务是周期性任务，但使用 `vTaskDelay()` 不能保证它们运行的频率是固定的，因为它们离开 *Blocked* 状态的时间是相对于它们调用 `vTaskDelay()` 的时间而言的。 将任务转换为使用 `vTaskDelayUntil()` 代替 `vTaskDelay()` 解决了此潜在问题。

<a name="list4.15" title="Listing 4.15 The implementation of the example task using vTaskDelayUntil()"></a>


```c
void vTaskFunction( void * pvParameters )
{
    char * pcTaskName;
    TickType_t xLastWakeTime;

    /*
     * The string to print out is passed in via the parameter. Cast this to a
     * character pointer.
     */
    pcTaskName = ( char * ) pvParameters;

    /*
     * The xLastWakeTime variable needs to be initialized with the current tick
     * count. Note that this is the only time the variable is written to
     * explicitly. After this xLastWakeTime is automatically updated within
     * vTaskDelayUntil().
     */
    xLastWakeTime = xTaskGetTickCount();

    /* As per most tasks, this task is implemented in an infinite loop. */
    for( ;; )
    {
        /* Print out the name of this task. */
        vPrintLine( pcTaskName );

        /*
         * This task should execute every 250 milliseconds exactly. As per
         * the vTaskDelay() function, time is measured in ticks, and the
         * pdMS_TO_TICKS() macro is used to convert milliseconds into ticks.
         * xLastWakeTime is automatically updated within vTaskDelayUntil(), so
         * is not explicitly updated by the task.
         */
        vTaskDelayUntil( &xLastWakeTime, pdMS_TO_TICKS( 250 ) );
    }
}
```

***列表 4.15*** *使用 vTaskDelayUntil() 实现的示例任务*

示例 4.5 的输出与图 4.8 中所示的示例 4.4 的输出完全相同。

<a name="example4.6" title="Example 4.6 Combining blocking and non-blocking tasks"></a>
---
***示例 4.6*** *结合阻塞任务和非阻塞任务*

---

之前的示例分别考察了轮询任务和阻塞任务的行为。此示例强化了我们之前所说的关于预期系统行为的内容，并演示了当这两种方案结合使用时的执行顺序，如下所示：

1. 创建了两个优先级为 1 的任务。这些任务除了持续打印字符串之外不做任何事情。

   这些任务从不调用可能导致它们进入 *Blocked* 状态的 API 函数，因此始终处于 Ready 或 *Running* 状态。
   这种性质的任务被称为“连续处理”任务，因为它们始终有工作要做（尽管在本例中，工作相当简单）。
   列表 4.16 显示了连续处理任务的源代码。

1. 然后创建一个优先级为 2 的第三个任务，其优先级高于其他两个任务。第三个任务也只是打印字符串，但这次是周期性地打印，因此它使用 `vTaskDelayUntil()` API 函数在每次打印迭代之间将自身置于 *Blocked* 状态。

列表 4.17 显示了周期性任务的源代码。

<a name="list4.16" title="Listing 4.16 The continuous processing task used in Example 4.6"></a>

```c
void vContinuousProcessingTask( void * pvParameters )
{
    char * pcTaskName;

    /*
     * The string to print out is passed in via the parameter. Cast this to a
     * character pointer.
     */
    pcTaskName = ( char * ) pvParameters;

    /* As per most tasks, this task is implemented in an infinite loop. */
    for( ;; )
    {
        /*
         * Print out the name of this task. This task just does this repeatedly
         * without ever blocking or delaying.
         */
        vPrintLine( pcTaskName );
    }
}
```

***列表 4.16*** *示例 4.6 中使用的连续处理任务*

<a name="list4.17" title="Listing 4.17 The periodic task used in Example 4.6"></a>

```c
void vPeriodicTask( void * pvParameters )
{
    TickType_t xLastWakeTime;

    const TickType_t xDelay3ms = pdMS_TO_TICKS( 3 );

    /*
     * The xLastWakeTime variable needs to be initialized with the current tick
     * count. Note that this is the only time the variable is explicitly
     * written to. After this xLastWakeTime is managed automatically by the
     * vTaskDelayUntil() API function.
     */
    xLastWakeTime = xTaskGetTickCount();

    /* As per most tasks, this task is implemented in an infinite loop. */
    for( ;; )
    {
        /* Print out the name of this task. */
        vPrintLine( "Periodic task is running" );

        /*
         * The task should execute every 3 milliseconds exactly – see the
         * declaration of xDelay3ms in this function.
         */
        vTaskDelayUntil( &xLastWakeTime, xDelay3ms );
    }
}
```

***列表 4.17*** *示例 4.6 中使用的周期性任务*

图 4.11 显示了示例 4.6 产生的输出，图 4.12 给出了对观察到的行为的解释，该行为由执行序列所示。

<a name="fig4.11" title="Figure 4.11 The output produced when Example 4.6 is executed"></a>

***

```console
连续任务 2 运行
连续任务 2 运行
周期性任务正在运行
连续任务 1 运行
连续任务 1 运行
连续任务 1 运行
连续任务 1 运行
连续任务 1 运行
连续任务 2 运行
连续任务 2 运行
连续任务 2 运行
连续任务 2 运行
连续任务 2 运行
连续任务 1 运行
连续任务 1 运行
连续任务 1 运行
连续任务 1 运行
连续任务 1 运行
连续任务 1 运行
连续任务 1 运行
连续任务 1 运行
连续任务 1 运行
周期性任务正在运行
连续任务 2 运行
连续任务 2 运行
```

***图 4.11*** *当执行示例 4.6 时产生的输出*
***


<a name="fig4.12" title="Figure 4.12 The execution pattern of Example 4.6"></a>

***
![](media/figure_4.11_example_4.6_execution_pattern.png)
***图 4.12*** *示例 4.6 的执行模式*
***


## 4.8 空闲任务和空闲任务钩子

在示例 4.4 中创建的任务的大部分时间都处于 Blocked 状态。 在此状态下，它们无法运行，因此无法被调度器选择。

必须始终至少有一个任务能够进入 Running 状态[^6]。 为了确保这一点，调度器在调用 `vTaskStartScheduler()` 时会自动创建一个空闲任务。 空闲任务几乎只是在一个循环中等待，因此，就像第一个示例中的任务一样，它总是能够运行。

[^6]: 即使使用 FreeRTOS 的特殊低功耗功能，也是如此。 在这种情况下，FreeRTOS 执行的微控制器将被置于低功耗模式，如果应用程序创建的任何任务都无法执行。

空闲任务具有最低优先级（优先级零），以确保它永远不会阻止更高优先级应用程序任务进入 *Running* 状态。 但是，没有任何内容可以阻止应用程序设计者创建具有空闲任务相同优先级的任务，如果需要的话。 `FreeRTOSConfig.h` 中的编译时配置常量 `configIDLE_SHOULD_YIELD` 可用于防止空闲任务消耗本可以更高效地分配给具有 0 优先级的应用程序任务的处理时间。 第 4.12 节，调度算法，描述了 `configIDLE_SHOULD_YIELD`。

以最低优先级运行可确保空闲任务在更高优先级任务进入 Ready 状态时立即退出 *Running* 状态。 这可以在图 4.9 的 **tn** 时刻看到，此时空闲任务立即被交换出去，以便在任务 2 离开 *Blocked* 状态的瞬间执行任务 2。 任务 2 被认为抢占了空闲任务。 抢占是自动发生的，并且无需被抢占的任务知道。

> *注意：如果任务使用 `vTaskDelete()` API 函数删除自身，那么必须确保空闲任务不会被剥夺处理时间。 这是因为空闲任务负责清理已删除任务使用的内核资源。*

### 4.8.1 空闲任务钩子函数

可以通过使用空闲钩子（或空闲回调）函数，将应用程序特定的功能直接添加到空闲任务中。 空闲钩子函数是在空闲任务循环的每次迭代中自动调用的函数。

空闲任务钩子的常见用途包括：

- 在无需为该目的创建应用程序任务而产生 RAM 开销的情况下，执行低优先级、后台或连续处理功能。

- 测量剩余的处理能力。（空闲任务仅在所有更高优先级应用程序任务没有工作可做时运行；因此，测量分配给空闲任务的处理时间可以清楚地指示剩余的处理时间。）

- 将处理器置于低功耗模式，提供一种简单且自动的方法，在没有应用程序处理需要执行时节省电量（尽管可实现省电量低于无滴答空闲模式）。

### 4.8.2 空闲任务钩子函数实现的限制

空闲任务钩子函数必须遵守以下规则。

- 空闲任务钩子函数绝不能尝试阻塞或挂起自身。

  *注意：以任何方式阻塞空闲任务都可能导致一种情况，即没有任务可进入 *运行* 状态。*

- 如果应用程序任务使用 `vTaskDelete()` API 函数来删除自身，则空闲任务钩子函数必须始终在合理的时间范围内返回其调用者。 这是因为空闲任务负责清理分配给删除自身的任务的内核资源。 如果空闲任务永久停留在空闲钩子函数中，则无法进行此清理。

空闲任务钩子函数必须具有 Listing 4.18 中所示的名称和原型。

```c
void vApplicationIdleHook( void );
```

***Listing 4.18*** *空闲任务钩子函数名称和原型*

<a name="example4.7" title="Example 4.7 Defining an idle task hook function"></a>
---
***Example 4.7*** *定义空闲任务钩子函数*

---

在示例 4.4 中使用阻塞 `vTaskDelay()` API 调用创建了大量的空闲时间，即当两个应用程序任务都处于 *阻塞* 状态时，空闲任务执行的时间。 示例 4.7 通过添加空闲钩子函数利用了这段空闲时间，其源代码如 Listing 4.19 所示。

<a name="list4.19" title="Listing 4.19 A very simple Idle hook function"></a>

```c
/* 声明一个变量，该变量将由钩子函数递增。 */
volatile unsigned long ulIdleCycleCount = 0UL;

/*
 * 空闲钩子函数必须被调用 vApplicationIdleHook()，不接受任何参数，并且返回 void。
 */
void vApplicationIdleHook( void )
{
    /* 此钩子函数除了递增计数器之外什么也不做。 */
    ulIdleCycleCount++;
}
```

***Listing 4.19*** *一个非常简单的空闲钩子函数*

为了使空闲钩子函数被调用，必须在 FreeRTOSConfig.h 中将 `configUSE_IDLE_HOOK` 设置为 1。

实现创建任务的函数被稍微修改，以打印出 `ulIdleCycleCount` 的值，如 Listing 4.20 所示。

<a name="list4.20" title="Listing 4.20 The source code for the example task now prints out the ulIdleCycleCount value"></a>

```c
void vTaskFunction( void * pvParameters )
{
    char * pcTaskName;
    const TickType_t xDelay250ms = pdMS_TO_TICKS( 250 );

    /*
     * 要打印的字符串通过参数传递。将其转换为字符指针。
     */
    pcTaskName = ( char * ) pvParameters;

    /* 像大多数任务一样，此任务以无限循环实现。 */
    for( ;; )
    {
        /*
         * 打印此任务的名称以及 ulIdleCycleCount 被递增的次数。
         */
        vPrintLineAndNumber( pcTaskName, ulIdleCycleCount );

        /* 延迟 250 毫秒。 */
        vTaskDelay( xDelay250ms );
    }
}
```

***Listing 4.20*** *示例任务的源代码现在打印出 ulIdleCycleCount 值*

Figure 4.13 显示了 Example 4.7 产生的输出。 可以看到，空闲任务钩子函数在应用程序任务的每次迭代之间执行大约 400 万次（迭代次数取决于硬件速度）。

<a name="fig4.13" title="Figure 4.13 The output produced when Example 4.7 is executed"></a>

***

```console
C:\Temp>rtosdemo
Task 2 is running
ulIdleCycleCount = 0
Task 1 is running
ulIdleCycleCount = 0
Task 2 is running
ulIdleCycleCount = 3869504
Task 1 is running
ulIdleCycleCount = 3869504
Task 2 is running
ulIdleCycleCount = 8564623
Task 1 is running
ulIdleCycleCount = 8564623
Task 2 is running
ulIdleCycleCount = 13181489
Task 1 is running
ulIdleCycleCount = 13181489
Task 2 is running
ulIdleCycleCount = 17838406
Task 1 is running
ulIdleCycleCount = 17838406
Task 2 is running
```

***Figure 4.13*** *当执行 Example 4.7 时产生的输出*
***

## 4.9 更改任务的优先级

### 4.9.1 vTaskPrioritySet() API 函数

`vTaskPrioritySet()` API 函数在调度器启动后更改任务的优先级。 `vTaskPrioritySet()` API 函数仅在 FreeRTOSConfig.h 中将 `INCLUDE_vTaskPrioritySet` 设置为 1 时可用。

<a name="list4.21" title="Listing 4.21 The vTaskPrioritySet() API function prototype"></a>

```c
void vTaskPrioritySet( TaskHandle_t xTask,
                       UBaseType_t uxNewPriority );
```

***Listing 4.21*** *The vTaskPrioritySet() API 函数原型*

**vTaskPrioritySet() 参数**

- `pxTask`

  正在修改其优先级的任务的句柄（主题任务）。有关获取任务句柄的信息，请参阅 `xTaskCreate()` API 函数的 `pxCreatedTask` 参数，或 `xTaskCreateStatic()` API 函数的返回值。

  任务可以通过传递 NULL 代替有效的任务句柄来更改其自身的优先级。

- `uxNewPriority`

  要设置为主题任务的优先级。 这会自动限制为 `(configMAX_PRIORITIES – 1)` 的最大可用优先级，其中 `configMAX_PRIORITIES` 是 FreeRTOSConfig.h 头文件中的一个编译时常量。


### 4.9.2 uxTaskPriorityGet() API 函数

`uxTaskPriorityGet()` API 函数返回任务的优先级。 `uxTaskPriorityGet()` API 函数仅在 FreeRTOSConfig.h 中将 `INCLUDE_uxTaskPriorityGet` 设置为 1 时可用。

<a name="list4.22" title="Listing 4.22 The uxTaskPriorityGet() API function prototype"></a>

```c
UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );
```

***Listing 4.22*** *The uxTaskPriorityGet() API 函数原型*

**uxTaskPriorityGet() 参数和返回值**

- `pxTask`

  正在查询其优先级的任务的句柄（主题任务）。有关如何获取任务句柄的信息，请参阅 `xTaskCreate()` API 函数的 `pxCreatedTask` 参数，或 `xTaskCreateStatic()` API 函数的返回值。

  任务可以通过传递 NULL 代替有效的任务句柄来查询其自身的优先级。

- 返回值

  当前分配给正在查询的任务的优先级。

<a name="example4.8" title="Example 4.8 Changing task priorities"></a>
---
***Example 4.8*** *更改任务优先级*

---

调度器始终选择 *Ready* 状态最高的任务作为进入 *Running* 状态的任务。 Example 4.8 通过使用 `vTaskPrioritySet()` API 函数来更改两个任务之间的优先级来演示这一点。

Example 4.8 创建了两个具有不同优先级的任务。这两个任务都没有调用可能导致其进入 Blocked 状态的 API 函数，因此它们始终处于 *Ready* 状态或 Running 状态。因此，具有相对最高优先级的任务将始终被调度器选择进入 *Running* 状态。

Example 4.8 的行为如下：

1. 任务 1 (Listing 4.23) 具有最高的优先级，因此可以保证首先运行。任务 1 打印出几个字符串，然后再将任务 2 (Listing 4.24) 的优先级提高到高于其自身的优先级。

2. 任务 2 开始运行（进入 *Running* 状态），因为它具有相对最高的优先级。 任何时候只能有一个任务处于 Running 状态，因此当任务 2 处于 *Running* 状态时，任务 1 处于 *Ready* 状态。

3. 任务 2 在将其自身的优先级降低到低于任务 1 的优先级之前，会打印出一个消息。

4. 当任务 2 将其优先级降低后，任务 1 再次成为具有最高优先级的任务，因此任务 1 重新进入 *Running* 状态，将任务 2 强制返回到 *Ready* 状态。

<a name="list4.23" title="Listing 4.23 Example 4.8 中任务 1 的实现"></a>

```c
void vTask1( void * pvParameters )
{
    UBaseType_t uxPriority;

    /*
     * 此任务将始终在任务 2 之前运行，因为它具有更高的优先级创建。 任务 1 和任务 2 都不可能被阻塞，因此它们始终处于运行或就绪状态。
     */

    /*
     * 查询此任务运行的优先级 - 传入 NULL 表示“返回调用任务的优先级”。
     */
    uxPriority = uxTaskPriorityGet( NULL );

    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( "Task 1 is running" );

        /*
         * 将任务 2 的优先级设置为高于任务 1 的优先级，将导致
         * 任务 2 立即开始运行（因为此时任务 2 将是创建的两个任务中优先级更高的任务）。 注意在调用 vTaskPrioritySet() 时使用任务 2 的句柄 (xTask2Handle)。
         * Listing 4.25 显示了句柄是如何获得的。
         */
        vPrintLine( "About to raise the Task 2 priority" );
        vTaskPrioritySet( xTask2Handle, ( uxPriority + 1 ) );

        /*
         * 只有当任务 1 的优先级高于任务 2 时，任务 1 才会运行。
         * 因此，要使此任务到达此点，任务 2 必须已经执行并将其优先级降低到低于此任务的优先级。
         */
    }
}
```

***Listing 4.23*** *Example 4.8 中任务 1 的实现*


<a name="list4.24" title="Listing 4.24 Example 4.8 中任务 2 的实现"></a>


```c
void vTask2( void * pvParameters )
{
    UBaseType_t uxPriority;

    /*
     * 任务 1 将始终在 此任务之前运行，因为任务 1 是以更高的优先级创建的。 任务 1 和任务 2 都不可能被阻塞，因此它们始终处于运行或就绪状态。
     *
     * 查询此任务运行的优先级 - 传入 NULL 表示“返回调用任务的优先级”。
     */
    uxPriority = uxTaskPriorityGet( NULL );

    for( ;; )
    {
        /*
         * 要使此任务到达此点，任务 1 必须已经运行并将其优先级设置为高于其自身的优先级。
         */

         /* 打印此任务的名称。 */
        vPrintLine( "Task 2 is running" );

        /*
         * 将此任务的优先级降低回其原始值。
         * 将 NULL 作为任务句柄传入表示“更改调用任务的优先级”。 将优先级设置为低于任务 1 的优先级将导致
         * 任务 1 立即再次开始运行 - 抢占此任务。
         */
        vPrintLine( "About to lower the Task 2 priority" );
        vTaskPrioritySet( NULL, ( uxPriority - 2 ) );
    }
}
```

***Listing 4.24*** *Example 4.8 中任务 2 的实现*

每个任务都可以通过使用 NULL 代替有效的任务句柄来查询和设置其自身的优先级。 只有当任务希望引用与其自身不同的任务时，才需要任务句柄，例如当任务 1 更改任务 2 的优先级时。 为了允许任务 1 执行此操作，在任务 2 创建时获取并保存任务 2 句柄，如 Listing 4.25 中的注释所示。



<a name="list4.25" title="Listing 4.25 Example 4.8 中 main() 的实现"></a>

```c
/* 声明一个变量，用于保存任务 2 的句柄。 */
TaskHandle_t xTask2Handle = NULL;

int main( void )
{
    /*
     * 以优先级 2 创建第一个任务。 任务参数未使用，并设置为 NULL。 任务句柄也未使用，因此也设置为
     * NULL。
     */
    xTaskCreate( vTask1, "Task 1", 1000, NULL, 2, NULL );
    /* 任务以优先级 2 创建 ______^。 */

    /*
     * 以优先级 1 创建第二个任务 - 优先级低于任务 1 赋予的优先级。 同样，任务参数未使用，因此设置为 NULL-
     * 但这次需要任务句柄，因此将 xTask2Handle 的地址作为最后一个参数传入。
     */
    xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, &xTask2Handle );
    /* 任务句柄是最后一个参数 _____^^^^^^^^^^^^^ */

    /* 启动调度器，以便任务开始执行。 */
    vTaskStartScheduler();

    /*
     * 如果一切顺利，main() 将无法到达此处，因为调度器将现在运行已创建的任务。 如果 main() 达到此处，则表示没有足够的堆内存来创建空闲任务或定时器任务
     * （本书后面会描述）。 第二章提供了有关堆内存管理的更多信息。
     */
    for( ;; )
    {
    }
}
```

***Listing 4.25*** *Example 4.8 中 main() 的实现*

图 4.14 演示了 Example 4.8 中任务执行的顺序，结果输出如图 4.15 所示。

<a name="fig4.14" title="图 4.14 运行 Example 4.8 时任务执行的顺序"></a>

***
![](media/figure_4.14_example_4.8_execution_sequence.png)
***图 4.14*** *运行 Example 4.8 时任务执行的顺序*
***


<a name="fig4.15" title="图 4.15 执行 Example 4.8 时产生的输出"></a>

***

```console
Task1 is running
About to raise the Task2 priority
Task2 is running
About to lower the Task2 priority
Task1 is running
About to raise the Task2 priority
Task2 is running
About to lower the Task2 priority
Task1 is running
About to raise the Task2 priority
Task2 is running
About to lower the Task2 priority
Task1 is running
```

***图 4.15*** *执行 Example 4.8 时产生的输出*
***


## 4.10 删除任务

### 4.10.1 vTaskDelete() API 函数

`vTaskDelete()` API 函数用于删除任务。 `vTaskDelete()` API 函数仅在 FreeRTOSConfig.h 中将 `INCLUDE_vTaskDelete` 设置为 1 时可用。

在运行时连续创建和删除任务不是一个好的实践，因此如果发现需要此函数，请考虑其他设计选项，例如重用任务。

已删除的任务不再存在，无法再次进入 *运行* 状态。

如果使用动态内存分配创建的任务稍后删除了自身，则空闲任务负责释放为其分配的内存，例如已删除任务的数据结构和堆栈。因此，在这种情况发生时，应用程序不应完全剥夺空闲任务的所有处理时间。

> *注意：只有内核本身分配给任务的内存，在任务删除时才会被自动释放。任务实现过程中分配的任何内存或其他资源，如果不再需要，必须显式释放。*


<a name="list4.26" title="列表 4.26 vTaskDelete() API 函数原型"></a>


```c
void vTaskDelete( TaskHandle_t xTaskToDelete );
```

***列表 4.26*** *vTaskDelete() API 函数原型*

**vTaskDelete() 参数**

- `pxTaskToDelete`

  要删除的任务的句柄（主题任务）。有关获取任务句柄的信息，请参阅 `xTaskCreate()` API 函数的 `pxCreatedTask` 参数以及 `xTaskCreateStatic()` API 函数的返回值。

任务可以通过在有效任务句柄的位置传递 NULL 来删除自身。

<a name="example4.9" title="示例 4.9 删除任务"></a>
---
***示例 4.9*** *删除任务*

---

这是一个非常简单的示例，其行为如下。

1. 任务 1 由 `main()` 以优先级 1 创建。运行时，它以优先级 2 创建任务 2。任务 2 现在是最高优先级的任务，因此立即开始执行。列表 4.27 显示了 `main()` 的源代码。列表 4.28 显示了任务 1 的源代码。

2. 任务 2 除了删除自身之外什么也不做。它可以将 NULL 传递给 `vTaskDelete()` 来删除自身，但为了演示目的，它使用了自己的任务句柄。列表 4.29 显示了任务 2 的源代码。

3. 当任务 2 被删除后，任务 1 再次成为最高优先级的任务，因此它继续执行——此时它调用 `vTaskDelay()` 以阻塞一段时间。

4. 空闲任务在任务 1 处于阻塞状态时执行，并释放分配给现在已删除的任务 2 的内存。

1. 当任务 1 离开阻塞状态时，它再次成为最高优先级的 *就绪* 状态任务，从而抢占空闲任务。当它进入 *运行* 状态时，它再次创建任务 2，循环往复。

<a name="list4.27" title="清单 4.27 示例 4.9 的 main() 实现"></a>

```c
int main( void )
{
    /* 创建优先级为 1 的第一个任务。 */
    xTaskCreate( vTask1, "Task 1", 1000, NULL, 1, NULL );

    /* 启动调度器，使任务开始执行。 */
    vTaskStartScheduler();

    /* main() 不应该到达这里，因为调度器已经启动。 */
    for( ;; )
    {
    }
}
```

***清单 4.27*** *示例 4.9 的 main() 实现*
***


<a name="list4.28" title="清单 4.28 示例 4.9 的 Task 1 实现"></a>

```c
TaskHandle_t xTask2Handle = NULL;

void vTask1( void * pvParameters )
{
    const TickType_t xDelay100ms = pdMS_TO_TICKS( 100UL );

    for( ;; )
    {
        /* 打印此任务的名称。 */
        vPrintLine( "Task 1 is running" );

        /*
         * 以更高的优先级创建任务 2。
         * 将 xTask2Handle 的地址作为 pxCreatedTask 参数传递，
         * 这样 xTaskCreate 就可以将生成的任务句柄写入该变量。
         */
        xTaskCreate( vTask2, "Task 2", 1000, NULL, 2, &xTask2Handle );

        /*
         * 任务 2 具有更高的优先级。 为了使 Task 1 能够到达这里，任务 2 必须已经执行并删除自身。
         */
        vTaskDelay( xDelay100ms );
    }
}
```

***清单 4.28*** *示例 4.9 的 Task 1 实现*


<a name="list4.29" title="清单 4.29 示例 4.9 的 Task 2 实现"></a>


```c
void vTask2( void * pvParameters )
{
    /*
     * 任务 2 在启动时立即删除自身。
     * 要做到这一点，它可以调用 vTaskDelete() 并使用 NULL 作为参数。
     * 为了演示目的，它改为使用其自身的
     * 任务句柄调用 vTaskDelete()。
     */
    vPrintLine( "Task 2 is running and about to delete itself" );
    vTaskDelete( xTask2Handle );
}
```

***清单 4.29*** *示例 4.9 的 Task 2 实现*


<a name="fig4.16" title="图 4.16 执行示例 4.9 时产生的输出"></a>

***

```console
C:\Temp>rtosdemo
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
Task1 is running
Task2 is running and about to delete itself
```

***图 4.16*** *执行示例 4.9 时产生的输出*
***


<a name="fig4.17" title="图 4.17 示例 4.9 的执行序列"></a>

***
![](media/figure_4.17_example_4.9_execution_sequence.png)
***图 4.17*** *示例 4.9 的执行序列*
***



## 4.11 线程局部存储和可重入性

线程局部存储允许应用程序开发者在每个任务的任务控制块中存储任意数据。此功能最常用于存储通常由不可重入函数存储在全局变量中的数据。

可重入函数是指可以安全地从多个线程运行而不会产生任何副作用的函数。当在多线程环境中使用不可重入函数时，如果没有线程局部存储，必须特别小心地检查这些函数调用在临界区内的结果。过度使用临界区会降低RTOS的性能，因此线程局部存储通常比使用临界区更受欢迎。

线程局部存储的最常见用途是ISO C标准中使用的```errno```全局变量，该标准由C标准库和POSIX系统使用。```errno```全局变量用于为诸如strtof和strtol等常见的标准库函数提供扩展结果或错误代码。

### 4.11.1 C运行时线程局部存储实现

大多数嵌入式libc实现都提供了API，以确保不可重入函数可以在多线程环境中正确工作。FreeRTOS包含对两个常用的开源库的重入API的支持：
[newlib](https://sourceware.org/newlib/) 和
[picolibc](https://github.com/picolibc/picolibc)。
这些预构建的C运行时线程局部存储实现可以通过在项目的FreeRTOSConfig.h文件中定义以下相应的宏来启用：

- ```configUSE_NEWLIB_REENTRANT``` 用于 [newlib](https://sourceware.org/newlib/)
- ```configUSE_PICOLIBC_TLS``` 用于 [picolibc](https://github.com/picolibc/picolibc)

### 4.11.2 自定义C运行时线程局部存储

应用程序开发者可以通过在他们的FreeRTOSConfig.h文件中定义以下宏来实现线程局部存储：

- 将 ```configUSE_C_RUNTIME_TLS_SUPPORT``` 定义为 1 以启用C运行时线程局部存储支持。

- 将 ```configTLS_BLOCK_TYPE``` 定义为用于存储C运行时线程局部存储数据的c类型。

- 将 ```configINIT_TLS_BLOCK``` 定义为在初始化C运行时线程局部存储块时运行的c代码。

- 将 ```configSET_TLS_BLOCK``` 定义为在切换到新任务时运行的c代码。

- 将 ```configDEINIT_TLS_BLOCK``` 定义为在取消初始化C运行时线程局部存储块时运行的c代码。

### 4.11.3 应用程序线程局部存储

除了C运行时线程局部存储之外，应用程序开发者还可以定义一组应用程序特定的指针，将其包含在任务控制块中。可以通过在项目的FreeRTOSConfig.h文件中将 ```configNUM_THREAD_LOCAL_STORAGE_POINTERS``` 设置为非零数字来启用此功能。
```vTaskSetThreadLocalStoragePointer``` 和 ```pvTaskGetThreadLocalStoragePointer``` 函数（如清单4.30所示）可分别用于在运行时设置和获取每个线程局部存储指针的值。

<a name="list4.30" title="清单 4.30 线程局部存储指针API函数原型"></a>

```c
void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
                                           BaseType_t xIndex )

void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
                                        BaseType_t xIndex,
                                        void * pvValue );
```

***清单 4.30*** *线程局部存储指针API函数原型*


## 4.12 调度算法

### 4.12.1 任务状态和事件回顾

正在实际运行（使用处理时间）的任务处于 *运行* 状态。在单核处理器上，在任何给定时间只能有一个任务处于 *运行* 状态。 也可以在多于一个的内核上运行 FreeRTOS（非对称多处理，或 AMP），或者让 FreeRTOS 在多个内核上调度任务（对称多处理，或 SMP）。 这两种情况都未在此处描述。

未实际运行，但不在 *阻塞* 状态或 *挂起* 状态的任务处于 *就绪* 状态。 *就绪* 状态的任务可供调度器选择，作为进入 *运行* 状态的任务。 调度器始终选择最高优先级 *就绪* 状态的任务进入 *运行* 状态。

任务可以在 *阻塞* 状态下等待事件，并在事件发生时自动返回到 *就绪* 状态。 定时事件发生在特定时间，例如，当一个时间片过期时，通常用于实现周期性或超时行为。 同步事件发生在任务或中断服务例程使用任务通知、队列、事件组、消息缓冲区、流缓冲区或许多类型的信号量发送信息时。 它们通常用于指示异步活动，例如数据到达外设。


### 4.12.2 选择调度算法

调度算法是决定将哪个 *就绪* 状态任务过渡到 *运行* 状态的软件例程。

到目前为止的所有示例都使用了相同的调度算法，但可以使用 `configUSE_PREEMPTION` 和 `configUSE_TIME_SLICING` 配置常量来更改该算法。 这两个常量都在 FreeRTOSConfig.h 中定义。

还有一个配置常量 `configUSE_TICKLESS_IDLE` 也影响调度算法，因为它的使用可能会导致周期中断在一段时间内完全关闭。 `configUSE_TICKLESS_IDLE` 是一个高级选项，专门用于必须最大程度地减少其功耗的应用程序。 此部分提供的描述假定 `configUSE_TICKLESS_IDLE` 设置为 0，如果未定义该常量，则为默认设置。

在所有可能的单核配置中，FreeRTOS 调度器轮流选择具有相同优先级的任务。 这种“轮流”策略通常被称为“轮询调度”。 轮询调度算法不能保证任务之间平等地分配时间，仅保证具有相同优先级的 *就绪* 状态任务轮流进入 *运行* 状态。

<a name="tbl5" title="表 5 FreeRTOSConfig.h 设置以配置内核调度算法"></a>

***
| 调度算法 | 优先级 | `configUSE_PREEMPTION` | `configUSE_TIME_SLICING` |
|---------------------------------|-------------|------------------------|--------------------------|
| 具有时间片轮转的抢占式 | 是 | 1 | 1   |
| 没有时间片轮转的抢占式 | 是 | 1 | 0   |
| 协同式 | 否 | 0 | 任意 |

***表 5*** *FreeRTOSConfig.h 设置以配置内核调度算法*
* * *

### 4.12.3 具有时间片轮转的固定优先级抢占式调度

表 5 中显示的配置将 FreeRTOS 调度器设置为使用一种名为“具有时间片轮转的固定优先级抢占式调度”的调度算法，这是大多数小型 RTOS 应用程序使用的调度算法，也是迄今为止本书中所有示例使用的算法。 下表提供了对算法名称中使用的术语的描述。

**对描述调度策略的术语的解释：**

- 固定优先级

  被描述为“固定优先级”的调度算法不会更改分配给正在调度的任务的优先级，也不会阻止任务本身更改其自身的优先级或其它任务的优先级。

- 抢占式

  抢占式调度算法会在具有比 *运行* 状态任务更高的优先级的任务进入 *就绪* 状态时立即“抢占” *运行* 状态任务。 被抢占意味着在没有显式放弃或阻塞的情况下，被不情愿地从 *运行* 状态移动到 *就绪* 状态，以允许不同的任务进入 *运行* 状态。 任务抢占可以在任何时间发生，而不仅仅是在 RTOS 周期中断中。

- 时间片轮转

  时间片轮转用于在任务具有相同优先级时共享处理时间，即使这些任务没有显式放弃或进入 *阻塞* 状态。 使用 *时间片轮转* 的调度算法会在每个时间片结束时选择一个新的任务进入 *运行* 状态，如果存在具有与运行任务相同优先级的其他 *就绪* 状态任务。 一个时间片等于两个 RTOS 周期中断之间的时间。

图 4.18 和图 4.19 演示了当使用固定优先级抢占式调度与时间片轮转算法时任务的调度方式。 图 4.18 显示了当应用程序中的所有任务都具有唯一的优先级时，任务被选入 *运行* 状态的顺序。 图 4.19 显示了当应用程序中的两个任务共享一个优先级时，任务被选入 *运行* 状态的顺序。

<a name="fig4.18" title="Figure 4.18 Execution pattern highlighting task prioritization and preemption..."></a>

***
![](media/figure_4.18_preemption_execution_pattern.png)
***图 4.18*** *执行模式，突出显示任务优先级和抢占，在假设的应用程序中，每个任务都分配了一个唯一的优先级*
***

参考图 4.18：

- 空闲任务

  空闲任务运行在最低优先级，因此每当具有更高优先级的任务进入 *就绪* 状态时，它就会被抢占，例如在时间 t3、t5 和 t9。

- 任务 3

  任务 3 是一个事件驱动的任务，以相对较低的优先级执行，但高于空闲任务的优先级。 它的大部分时间都处于 *阻塞* 状态，等待其感兴趣的事件，每次事件发生时从 *阻塞* 状态转换到 *就绪* 状态。 所有 FreeRTOS 任务间通信机制（任务通知、队列、信号量、事件组等）都可以用来发送事件并以这种方式解除任务的阻塞。

  事件发生在时间 t3 和 t5，以及 t9 和 t12 之间。 在时间 t3 和 t5 发生的事件会被立即处理，因为在这些时间点，任务 3 是能够运行的最高优先级任务。 发生在 t9 和 t12 之间的时间的事件，直到 t12 才会被处理，因为在此之前，更高优先级的任务任务 1 和任务 2 仍在执行。 只有在时间 t12 时，任务 1 和任务 2 都在 *阻塞* 状态，使得任务 3 成为最高优先级的 *就绪* 状态任务。

- 任务 2

  任务 2 是一个周期性任务，其优先级高于任务 3 的优先级，但低于任务 1 的优先级。 任务的周期间隔意味着任务 2 希望在时间 t1、t6 和 t9 执行。

  在时间 t6，任务 3 处于 *运行* 状态，但任务 2 具有更高的相对优先级，因此抢占任务 3 并立即开始执行。 任务 2 完成其处理并于时间 t7 重新进入 *阻塞* 状态，此时任务 3 可以重新进入 *运行* 状态以完成其处理。 任务 3 本身在时间 t8 阻塞。

- 任务 1

  任务 1 也是一个事件驱动的任务。 它的优先级最高，因此可以抢占系统中的任何其他任务。 图中唯一显示的任务 1 事件发生在时间 t10，此时任务 1 抢占任务 2。 任务 2 只能在任务 1 在时间 t11 重新进入 *阻塞* 状态后完成其处理。

<a name="fig4.19" title="Figure 4.19 Execution pattern highlighting task prioritization and time slicing..."></a>

***
![](media/figure_4.19_time_slicing_execution_pattern.png)
***Figure 4.19*** *Execution pattern highlighting task prioritization and time slicing
in a hypothetical application in which two tasks run at the same priority*
***

参考图 4.19：

- 空闲任务和任务 2

  空闲任务和任务 2 都是连续处理任务，并且它们的优先级都为 0（最低优先级）。 调度器仅在没有能够运行的更高优先级任务时才将处理时间分配给优先级 0 任务，并通过时间分片来共享分配给优先级 0 任务的时间。 新的时间片在每个时钟中断时开始，在图 4.19 中发生在时间 t1、t2、t3、t4、t5、t8、t9、t10 和 t11。

空闲任务和任务 2 轮流进入 *运行* 状态，这可能导致这两个任务在同一时间片的部分时间内都处于 *运行* 状态，就像在时间 t5 和时间 t8 之间发生的那样。

- 任务 1

  任务 1 的优先级高于空闲任务的优先级。 任务 1 是一个事件驱动的任务，它的大部分时间都处于 *阻塞* 状态，等待其感兴趣的事件发生，每次事件发生时从 *阻塞* 状态转换到 *就绪* 状态。

  感兴趣的事件发生在时间 t6。 在 t6 时，任务 1 成为能够运行的最高优先级任务，因此任务 1 抢占了空闲任务，在时间片的中途。 事件处理在时间 t7 完成，此时任务 1 重新进入阻塞状态。

图 4.19 显示了空闲任务与由应用程序编写器创建的任务共享处理时间。 如果由应用程序编写器创建的空闲优先级任务有工作要做，但空闲任务没有，那么将那么多处理时间分配给空闲任务可能并不理想。 可以使用编译时配置常量 `configIDLE_SHOULD_YIELD` 来更改空闲任务的调度方式：

- 如果 `configIDLE_SHOULD_YIELD` 设置为 0，则空闲任务将保持在 *运行* 状态，直到被更高优先级的任务抢占为止，除非它被更高优先级的任务抢占。

- 如果 `configIDLE_SHOULD_YIELD` 设置为 1，则空闲任务将在其循环的每次迭代中放弃其分配的时间片剩余部分，如果其他空闲优先级任务处于 *就绪* 状态。

图 4.19 中显示的执行模式是在 `configIDLE_SHOULD_YIELD` 设置为 0 时观察到的。 图 4.20 中显示的执行模式是在相同的场景中，当 `configIDLE_SHOULD_YIELD` 设置为 1 时观察到的。

<a name="fig4.20" title="Figure 4.20 The execution pattern for the same scenario as shown in Figure 4.19..."></a>

***
![](media/figure_4.20_time_slicing_with_yield_execution_pattern.png)
***图 4.20*** *与图 4.19 中所示的相同场景的执行模式，但这次将 `configIDLE_SHOULD_YIELD` 设置为 1*
***

图 4.20 还显示，当 `configIDLE_SHOULD_YIELD` 设置为 1 时，在空闲任务之后选定的进入 *运行* 状态的任务不会执行整个时间片，而是仅在空闲任务放弃时剩余的时间片中执行。

### 4.12.4 带有优先级抢占，不带时间片轮转的调度

带有优先级抢占，不带时间片轮转的调度，保持与前一节中描述的相同的任务选择和抢占算法，但未使用时间片轮转来在相同优先级的任务之间共享处理时间。

表 5 显示了配置 FreeRTOS 调度器使用带有优先级抢占，不带时间片轮转的调度的 FreeRTOSConfig.h 设置。

正如在图 4.19 中所演示的，如果使用了时间片轮转，并且在能够运行的最高优先级状态下有多个就绪任务，那么调度器将在每个 RTOS 滴答中断期间（一个滴答中断标志着一个时间片结束）选择一个新的任务进入 *运行* 状态。 如果未使用时间片轮转，那么调度器仅在以下情况时选择一个新的任务进入 *运行* 状态：

- 具有更高优先级的任务进入 *就绪* 状态。

- *运行* 状态的任务进入 *阻塞* 或 *挂起* 状态。

当不使用时间片轮转时，任务上下文切换的次数比使用时间片轮转时少。因此，关闭时间片轮转可以减少调度器的处理开销。然而，关闭时间片轮转也可能导致具有相同优先级的任务接收到非常不同的处理时间，如图 4.21 所示。因此，在没有时间片轮转的情况下运行调度器被认为是高级技术，应该仅由经验丰富的用户使用。

<a name="fig4.21" title="Figure 4.21 Execution pattern that demonstrates how tasks of equal priority can..."></a>

***
![](media/figure_4.21_equal_priority_without_time_slicing_execution_pattern.png)
***图 4.21*** *执行模式，演示了当不使用时间片轮转时，具有相同优先级的任务可以接收到巨大的处理时间差异*
***

参考图 4.21，假设 `configIDLE_SHOULD_YIELD` 设置为 0：

- 滴答中断

  滴答中断发生在时间 t1、t2、t3、t4、t5、t8、t11、t12 和 t13 时。

- 任务 1

  任务 1 是一个高优先级事件驱动任务，它的大部分时间都花在 *Blocked* 状态，等待其感兴趣的事件。每当事件发生时，任务 1 就会从 *Blocked* 状态过渡到 *Ready* 状态（并且，由于它是最高优先级的 *Ready* 状态任务，进而进入 *Running* 状态）。图 4.21 显示了任务 1 在时间 t6 和 t7 之间处理一个事件，然后在时间 t9 和 t10 之间再次处理。

- 空闲任务和任务 2

  空闲任务和任务 2 都是连续处理任务，并且它们的优先级都为 0（空闲优先级）。连续处理任务不会进入 *Blocked* 状态。

  由于未使用时间片轮转，因此处于 *Running* 状态的空闲优先级任务将保持在 *Running* 状态，直到被更高优先级的任务 1 抢占。

  在图 4.21 中，空闲任务在时间 t1 开始运行，并保持在 *Running* 状态，直到在时间 t6 被任务 1 抢占，这比它进入 *Running* 状态后经历了四个完整的滴答周期还要长。

任务 2 在时间 t7 开始运行，此时任务 1 重新进入 *Blocked* 状态，等待另一个事件。任务 2 保持在 Running 状态，直到在时间 t9 被任务 1 抢占，这发生在它进入 *Running* 状态后不到一个滴答周期。

  在时间 t10，空闲任务重新进入 *Running* 状态，尽管它已经获得了比任务 2 多出四倍以上的处理时间。

### 4.12.5 协同调度

本书重点关注抢占式调度，但 FreeRTOS 也可以使用协同调度。表 5 显示了 FreeRTOSConfig.h 设置，这些设置配置 FreeRTOS 调度器以使用协同调度。

当使用协同调度器（因此假设应用程序提供的中断服务例程不会显式请求上下文切换）时，上下文切换仅在 Running 状态的任务进入 *Blocked* 状态，或 *Running* 状态的任务通过调用 `taskYIELD()` 显式放弃（手动请求重新调度）时发生。任务永不被抢占，因此不能使用时间片轮转。

图 4.22 演示了协同调度的行为。图 4.22 中的水平虚线显示了任务处于 Ready 状态的时间。

<a name="fig4.22" title="图 4.22 演示协同调度行为的执行模式"></a>

***
![](media/figure_4.22_cooperative_scheduler_execution_pattern.png)
***图 4.22*** *演示协同调度行为的执行模式*
***

参考图 4.22：

- 任务 1

  任务 1 具有最高的优先级。它从 *Blocked* 状态开始，等待一个信号量。

  在时间 t3，一个中断给出了信号量，导致任务 1 离开 *Blocked* 状态并进入 *Ready* 状态（从中断获取信号量在第 6 章中介绍）。

  在时间 t3，任务 1 是最高优先级的 *Ready* 状态任务，如果使用了抢占式调度器，任务 1 将成为 Running 状态的任务。但是，由于使用了协同调度器，任务 1 保持在 *Ready* 状态，直到时间 t4，此时 Running 状态的任务调用 `taskYIELD()`。

- 任务 2

  任务 2 的优先级介于任务 1 和任务 3 之间。它从 *Blocked* 状态开始，等待任务 3 在时间 t2 发送给它的消息。

  在时间 t2，任务 2 是最高优先级的 *Ready* 状态任务，如果使用了抢占式调度器，任务 2 将成为 Running 状态的任务。但是，由于使用了协同调度器，任务 2 保持在 *Ready* 状态，直到 *Running* 状态的任务进入 *Blocked* 状态或调用 `taskYIELD()`。

  *Running* 状态的任务在时间 t4 调用 `taskYIELD()`，但到那时任务 1 是最高优先级的 *Ready* 状态任务，因此任务 2 实际上直到任务 1 在时间 t5 重新进入 *Blocked* 状态才会成为 *Running* 状态的任务。

  在时间 t6，任务 2 重新进入 *Blocked* 状态以等待下一个消息，此时任务 3 再次成为最高优先级的 *Ready* 状态任务。

在多任务应用程序中，应用程序编写者必须注意不要让多个任务同时访问资源，因为同时访问可能会破坏资源。例如，考虑以下场景，其中访问的资源是一个 UART（串行端口）。两个任务向 UART 写入字符串；任务 1 写入“abcdefghijklmnop”，任务 2 写入“123456789”：

1. 任务 1 处于 *Running* 状态，并开始写入其字符串。它将“abcdefg”写入 UART，但在写入任何其他字符之前离开了 *Running* 状态。

1. 任务 2 进入 *Running* 状态，并将“123456789”写入 UART，然后离开 *Running* 状态。

2. 任务 1 重新进入 *Running* 状态，并将字符串的剩余字符写入 UART。

在这种情况下，实际写入 UART 的内容是“abcdefg123456789hijklmnop”。任务 1 写入的字符串没有像预期那样以不间断的序列写入 UART，而是被破坏了，因为任务 2 写入 UART 的字符串出现在其中。

通常情况下，使用协同调度器比使用抢占式调度器更容易避免因同时访问而导致的问题[^7]：

[^7]: 在本书后面会介绍安全共享资源的方法。FreeRTOS 本身提供的队列和信号量等资源始终可以安全地在任务之间共享。

- 当你使用抢占式调度器时，*Running* 状态的任务可能随时被抢占，包括当它正在共享的资源处于不一致状态时。正如 UART 示例所示，将资源置于不一致状态会导致数据损坏。

- 当你使用协同调度器时，你可以控制何时切换到另一个任务。因此，你可以确保在资源处于不一致状态时不会发生切换。

- 在上述 UART 示例中，你可以确保任务 1 在将整个字符串写入 UART 后才离开 *Running* 状态，从而消除字符串因另一个任务的活动而损坏的可能性。

如图 4.22 所示，使用协同调度器会使系统响应性低于使用抢占式调度器：

- 当使用抢占式调度器时，调度器会在任务成为最高优先级 *Ready* 状态的任务时立即开始运行该任务。这通常在必须在定义的时间段内对高优先级事件做出响应的实时系统中至关重要。

- 当使用协同调度器时，直到 *Running* 状态的任务进入 *Blocked* 状态或调用 `taskYIELD()`，才会切换到成为最高优先级 *Ready* 状态的任务。



