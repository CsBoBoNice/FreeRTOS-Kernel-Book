# 5 队列管理

## 5.1 简介

“队列”提供了一种任务到任务、任务到中断以及中断到任务的通信机制。

### 5.1.1 范围

本章涵盖以下内容：

- 如何创建队列。
- 队列如何管理其包含的数据。
- 如何向队列发送数据。
- 如何从队列接收数据。
- 在队列上阻塞的含义。
- 如何在多个队列上阻塞。
- 如何覆盖队列中的数据。
- 如何清空队列。
- 写入和读取队列时任务优先级的影响。

本章仅涵盖任务到任务的通信。第7章将介绍任务到中断和中断到任务的通信。

## 5.2 队列的特性

### 5.2.1 数据存储

队列可以容纳有限数量的固定大小的数据项[^8]。队列可以容纳的最大数据项数量称为其“长度”。队列的长度和每个数据项的大小在创建队列时设置。

[^8]: FreeRTOS消息缓冲区（将在第TBD章中介绍）提供了一种更轻量级的替代方案，用于存储可变长度消息。

队列通常用作先进先出（FIFO）缓冲区，数据写入队列的末尾（尾部），并从队列的前端（头部）移除。图5.1展示了数据在用作FIFO的队列中的写入和读取过程。也可以将数据写入队列的前端，并覆盖队列前端已有的数据。

<a name="fig5.1" title="图5.1 队列写入和读取的示例序列"></a>

* * *
![](media/image31.png)   
***图5.1*** *队列写入和读取的示例序列*
* * *

队列行为的实现方式有两种：

1. **复制队列**

    复制队列意味着发送到队列的数据会逐字节复制到队列中。

2. **引用队列**

    引用队列意味着队列仅保存发送到队列的数据的指针，而不是数据本身。

FreeRTOS使用复制队列的方法，因为它比引用队列更强大且更易于使用，原因如下：

- 复制队列并不妨碍队列也可以用于引用队列。例如，当数据大小使得将其复制到队列中不切实际时，可以将数据的指针复制到队列中。

- 可以直接将栈变量发送到队列，即使变量在声明它的函数退出后将不复存在。

- 可以在不首先分配缓冲区来保存数据的情况下将数据发送到队列——然后将数据复制到分配的缓冲区中并排队缓冲区的引用。

- 发送任务可以立即重新使用发送到队列的变量或缓冲区。

- 发送任务和接收任务完全解耦；应用程序设计者无需关心哪个任务“拥有”数据，或哪个任务负责释放数据。

- RTOS完全负责分配用于存储数据的内存。

- 内存保护系统限制对RAM的访问，在这种情况下，引用队列只能在发送和接收任务都可以访问被引用数据的情况下实现。复制队列允许数据跨越内存保护边界传递。


### 5.2.2 多任务访问

队列本身是独立的对象，任何知道其存在的任务或中断服务程序（ISR）都可以访问它。任意数量的任务都可以向同一个队列写入数据，同样，任意数量的任务也可以从同一个队列读取数据。在实际应用中，一个队列拥有多个写入者的情况非常常见，但拥有多个读取者的情况则相对较少。

### 5.2.3 队列读取的阻塞

当任务尝试从队列中读取数据时，可以选择指定一个“阻塞”时间。这是任务在队列为空时，为等待数据可用而保持在阻塞状态的时间。如果队列为空，任务将被置于阻塞状态，等待数据可用。当另一个任务或中断向队列中放入数据时，等待数据可用的任务将自动从阻塞状态转移到就绪状态。如果在数据可用之前指定的阻塞时间已过，任务也会自动从阻塞状态转移到就绪状态。

队列可以有多个读取者，因此一个队列可能有多个任务在等待数据时处于阻塞状态。在这种情况下，当数据可用时，只有一个任务会被解除阻塞。被解除阻塞的任务始终是等待数据的最高优先级任务。如果有两个或更多优先级相同的阻塞任务，那么等待时间最长的任务将被解除阻塞。


### 5.2.4 队列写入的阻塞

与从队列中读取时类似，任务在向队列写入时也可以选择指定一个阻塞时间。在这种情况下，阻塞时间是指如果队列已满，任务在等待队列空间可用时，处于阻塞状态的最长时间。

队列可以有多个写入者，因此一个已满的队列可能会有多个任务因等待完成发送操作而被阻塞。在这种情况下，当队列空间可用时，只有一个任务会被解除阻塞。被解除阻塞的任务总是优先级最高的等待空间的任务。如果有两个或多个被阻塞的任务优先级相同，则等待时间最长的任务会被解除阻塞。

### 5.2.5 多队列阻塞

队列可以被分组为集合，允许任务进入阻塞状态，以等待集合中任何队列上的数据变为可用。第5.6节《从多个队列接收》将演示队列集合的使用。


### 5.2.6 创建队列：静态分配与动态分配队列

队列通过句柄引用，句柄是`QueueHandle_t`类型的变量。在使用队列之前，必须显式地创建它。

有两个API函数用于创建队列：`xQueueCreate()`和`xQueueCreateStatic()`。

每个队列需要两块内存，第一块用于保存其数据结构，第二块用于保存队列数据。`xQueueCreate()`从堆中动态分配所需的内存，而`xQueueCreateStatic()`使用作为参数传递给函数的预分配内存。

## 5.3 使用队列

### 5.3.1 xQueueCreate() API函数

列表5.1展示了`xQueueCreate()`函数的原型。`xQueueCreateStatic()`有两个额外的参数，分别指向预分配的内存，用于保存队列的数据结构和数据存储区。

<a name="list5.1" title="列表5.1 xQueueCreate() API函数原型"></a>

```c
QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );
```
***列表5.1*** *xQueueCreate() API函数原型*

**xQueueCreate() 参数和返回值：**

- `uxQueueLength`

  所创建队列在任何时刻可以容纳的最大项数。

- `uxItemSize`

  可以存储在队列中的每个数据项的字节大小。

- 返回值

  如果返回NULL，则无法创建队列，因为FreeRTOS没有足够的堆内存来分配队列数据结构和存储区。第2章提供了有关FreeRTOS堆的更多信息。

  如果返回非NULL值，则队列创建成功，返回的值是所创建队列的句柄。

`xQueueReset()`是一个API函数，用于将先前创建的队列恢复到其初始的空状态。


### 5.3.2 xQueueSendToBack() 和 xQueueSendToFront() API 函数

正如其名，`xQueueSendToBack()` 将数据发送到队列的尾部，而 `xQueueSendToFront()` 则将数据发送到队列的头部。

`xQueueSend()` 等同于 `xQueueSendToBack()`，两者功能完全相同。

> *注意：切勿在中断服务例程中调用 `xQueueSendToFront()` 或 `xQueueSendToBack()`。应使用其对应的中断安全版本 `xQueueSendToFrontFromISR()` 和 `xQueueSendToBackFromISR()`。这些函数将在第7章中详细介绍。*

<a name="list5.2" title="Listing 5.2 The xQueueSendToFront() API function prototype"></a>

```c
BaseType_t xQueueSendToFront( QueueHandle_t xQueue,
                              const void * pvItemToQueue,
                              TickType_t xTicksToWait );
```
***Listing 5.2*** *xQueueSendToFront() API 函数的原型*

<a name="list5.3" title="Listing 5.3 The xQueueSendToBack() API function prototype"></a>

```c
BaseType_t xQueueSendToBack( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait );
```
***Listing 5.3*** *xQueueSendToBack() API 函数的原型*

**xQueueSendToFront() 和 xQueueSendToBack() 函数的参数及返回值**

- `xQueue`

  要发送（写入）数据的队列的句柄。该句柄由用于创建队列的 `xQueueCreate()` 或 `xQueueCreateStatic()` 函数返回。

- `pvItemToQueue`

  指向要复制到队列中的数据的指针。

  队列中每个数据项的大小在创建队列时设置，因此会从 `pvItemToQueue` 复制相应数量的字节到队列存储区。

- `xTicksToWait`

  如果队列已满，任务在等待队列空间可用时应保持在阻塞状态的最长时间。

  如果 `xTicksToWait` 为零且队列已满，`xQueueSendToFront()` 和 `xQueueSendToBack()` 将立即返回。

  阻塞时间以时钟周期为单位指定，因此其表示的绝对时间取决于时钟频率。可以使用宏 `pdMS_TO_TICKS()` 将以毫秒为单位的时间转换为以时钟周期为单位的时间。

  如果将 `xTicksToWait` 设置为 `portMAX_DELAY`，并且 `FreeRTOSConfig.h` 中的 `INCLUDE_vTaskSuspend` 设置为 1，任务将无限期等待（不会超时）。

- 返回值

  有两种可能的返回值：

  - `pdPASS`

    当数据成功发送到队列时返回 `pdPASS`。

    如果指定了阻塞时间（`xTicksToWait` 不为零），则调用任务可能会被置于阻塞状态以等待队列空间可用，但在阻塞时间到期之前数据已成功写入队列。

  - `errQUEUE_FULL`（与 `pdFAIL` 值相同）

    如果由于队列已满而无法将数据写入队列，则返回 `errQUEUE_FULL`。

    如果指定了阻塞时间（`xTicksToWait` 不为零），则调用任务将被置于阻塞状态以等待其他任务或中断释放队列空间，但在指定的阻塞时间到期之前未发生这种情况。


### 5.3.3 xQueueReceive() API 函数

`xQueueReceive()` 从队列中接收（读取）一个数据项。接收到的数据项会从队列中移除。

> *注意：切勿在中断服务例程中调用 `xQueueReceive()`。中断安全的 `xQueueReceiveFromISR()` API 函数将在第 7 章中介绍。*

<a name="list5.4" title="Listing 5.4 The xQueueReceive() API function prototype"></a>

```c
BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait );
```
***清单 5.4*** *xQueueReceive() API 函数原型*

**xQueueReceive() 函数参数和返回值**

- `xQueue`

  接收（读取）数据的队列句柄。该句柄由创建队列时调用的 `xQueueCreate()` 或 `xQueueCreateStatic()` 返回。

- `pvBuffer`

  指向用于存储接收数据的内存区域的指针。

  队列中每个数据项的大小在队列创建时设置。`pvBuffer` 指向的内存区域必须至少能够容纳该大小的字节数。

- `xTicksToWait`

  如果队列为空，任务应保持在阻塞状态以等待队列中数据可用的最大时间。

  如果 `xTicksToWait` 为零，那么当队列为空时，`xQueueReceive()` 将立即返回。

  阻塞时间以滴答周期为单位指定，因此它所表示的绝对时间取决于滴答频率。可以使用宏 `pdMS_TO_TICKS()` 将以毫秒为单位的时间转换为以滴答为单位的时间。

  如果将 `xTicksToWait` 设置为 `portMAX_DELAY`，并且在 FreeRTOSConfig.h 中将 `INCLUDE_vTaskSuspend` 设置为 1，则任务将无限期等待（不会超时）。

- 返回值

  有两种可能的返回值：
  
  - `pdPASS`

    当成功从队列中读取数据时返回 `pdPASS`。

    如果指定了阻塞时间（`xTicksToWait` 不为零），则调用任务可能会被置于阻塞状态以等待队列中数据可用，但在阻塞时间到期之前成功从队列中读取了数据。

  - `errQUEUE_EMPTY`（与 `pdFAIL` 值相同）

    如果因为队列为空而无法读取数据，则返回 `errQUEUE_EMPTY`。

    如果指定了阻塞时间（`xTicksToWait` 不为零），则调用任务将被置于阻塞状态以等待其他任务或中断向队列发送数据，但在该事件发生之前阻塞时间已到期。


### 5.3.4 uxQueueMessagesWaiting() API 函数

`uxQueueMessagesWaiting()` 用于查询队列中当前的消息数量。

> *注意：切勿在中断服务例程中调用 `uxQueueMessagesWaiting()`。应使用其替代函数 `uxQueueMessagesWaitingFromISR()`，该函数是中断安全的。*

<a name="list5.5" title="Listing 5.5 The uxQueueMessagesWaiting() API function prototype"></a>

```c
UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue );
```
***代码清单 5.5*** *uxQueueMessagesWaiting() API 函数原型*


**uxQueueMessagesWaiting() 函数参数及返回值**

- `xQueue`

  被查询队列的句柄。该队列句柄由创建队列时调用的 `xQueueCreate()` 或 `xQueueCreateStatic()` 函数返回。

- 返回值

  被查询队列中当前的消息数量。如果返回值为零，则表明队列为空。


<a name="example5.1" title="Example 5.1 Blocking when receiving from a queue"></a>
---
***示例 5.1*** *从队列接收数据时的阻塞*

---

本示例展示了如何创建一个队列，从多个任务向队列发送数据，以及从队列接收数据。队列被创建用于存储 `int32_t` 类型的数据项。向队列发送数据的任务未指定阻塞时间，而从队列接收数据的任务则指定了阻塞时间。

发送到队列的任务优先级低于从队列接收的任务。这意味着队列中应该永远不会包含超过一个项目，因为一旦数据被发送到队列，接收任务将解除阻塞，抢占发送任务（因为它的优先级更高），并移除数据，使队列再次为空。

该示例创建了两个任务实例，如清单5.6所示，一个任务持续将值100写入队列，另一个任务持续将值200写入同一个队列。任务参数用于将这些值传递到每个任务实例中。

<a name="list5.6" title="清单5.6 示例5.1中使用的发送任务的实现"></a>

```c
static void vSenderTask( void *pvParameters )
{

    int32_t lValueToSend;

    BaseType_t xStatus;

    /* 创建了两个此任务的实例，因此通过任务参数传递发送到队列的值——这样每个实例可以使用不同的值。队列被创建用于存储int32_t类型的值，因此将参数强制转换为所需类型。 */
    lValueToSend = ( int32_t ) pvParameters;

    /* 与大多数任务一样，此任务在无限循环中实现。 */
    for( ;; )
    {

        /* 将值发送到队列。

           第一个参数是数据发送到的队列。队列在调度器启动之前创建，因此在此任务开始执行之前。

           第二个参数是要发送的数据的地址，在本例中是lValueToSend的地址。

           第三个参数是阻塞时间——如果队列已满，任务应保持在阻塞状态以等待队列中空间变为可用。在本例中未指定阻塞时间，因为队列中应永远不会包含超过一个项目，因此永远不会满。 */
        xStatus = xQueueSendToBack( xQueue, &lValueToSend, 0 );

        if( xStatus != pdPASS )
        {
            /* 发送操作无法完成，因为队列已满——这一定是一个错误，因为队列中应永远不会包含超过一个项目！ */
            vPrintString( "无法发送到队列。\r\n" );
        }
    }
}
```
***清单5.6*** *示例5.1中使用的发送任务的实现*

清单5.7显示了从队列接收数据的任务的实现。接收任务指定了100毫秒的阻塞时间，然后进入阻塞状态以等待数据变为可用。当队列中有数据可用或100毫秒过去且没有数据变为可用时，它将离开阻塞状态。在本例中，有两个任务持续向队列写入数据，因此100毫秒的超时永远不会触发。

<a name="list5.7" title="代码清单 5.7  示例 5.1 的接收任务实现"></a>

```c
static void vReceiverTask( void *pvParameters )
{
    /* 声明变量，用于保存从队列中接收的值。 */
    int32_t lReceivedValue;
    BaseType_t xStatus;
    const TickType_t xTicksToWait = pdMS_TO_TICKS( 100 );

    /* 该任务也定义在一个无限循环中。 */
    for( ;; )
    {
        /* 此调用应始终发现队列为空，因为此任务会立即移除任何写入队列的数据。 */
        if( uxQueueMessagesWaiting( xQueue ) != 0 )
        {
            vPrintString( "队列应为空！\r\n" );
        }

        /* 从队列中接收数据。

           第一个参数是要从中接收数据的队列。
           该队列在调度器启动之前创建，因此在该任务首次运行之前就已存在。

           第二个参数是用于存放接收数据的缓冲区。在本例中，缓冲区只是一个变量的地址，
           该变量的大小足以容纳接收的数据。

           最后一个参数是阻塞时间——如果队列已经为空，任务将在阻塞状态下等待数据可用的最长时间。 */
        xStatus = xQueueReceive( xQueue, &lReceivedValue, xTicksToWait );

        if( xStatus == pdPASS )
        {
            /* 成功从队列中接收到数据，打印接收到的值。 */
            vPrintStringAndNumber( "Received = ", lReceivedValue );
        }
        else
        {
            /* 等待 100 毫秒后仍未从队列中接收到数据。这必定是错误，因为发送任务是自由运行的，
               并且会不断向队列写入数据。 */
            vPrintString( "无法从队列中接收数据。\r\n" );
        }
    }
}
```
***代码清单 5.7***  *示例 5.1 的接收任务实现*


代码清单 5.8 包含了 `main()` 函数的定义。该函数简单地创建了队列和三个任务，然后启动调度器。队列被创建为最多可容纳五个 `int32_t` 值，尽管任务优先级的关系意味着队列永远不会同时保存超过一个数据项。

<a name="list5.8" title="清单 5.8 例 5.1 中 main() 的实现"></a>

```c
/* 声明一个类型为 QueueHandle_t 的变量。此变量用于存储所有三个任务访问的队列句柄。 */
QueueHandle_t xQueue;

int main( void )
{
    /* 创建队列，最多容纳 5 个值，每个值的大小足以存储 int32_t 类型的变量。 */
    xQueue = xQueueCreate( 5, sizeof( int32_t ) );

    if( xQueue != NULL )
    {
        /* 创建两个向队列发送数据的任务实例。任务参数用于传递任务将写入队列的值，
           因此一个任务将连续向队列写入 100，而另一个任务将连续向队列写入 200。
           两个任务均以优先级 1 创建。 */
        xTaskCreate( vSenderTask, "Sender1", 1000, ( void * ) 100, 1, NULL );
        xTaskCreate( vSenderTask, "Sender2", 1000, ( void * ) 200, 1, NULL );

        /* 创建从队列读取数据的任务。该任务以优先级 2 创建，高于发送任务的优先级。 */
        xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 2, NULL );

        /* 启动调度器，使创建的任务开始执行。 */
        vTaskStartScheduler();
    }
    else
    {
        /* 队列无法创建。 */
    }

    /* 如果一切正常，则 main() 将永远不会到达此处，因为调度器正在运行任务。
       如果 main() 确实到达此处，则很可能是因为没有足够的 FreeRTOS 堆内存来创建空闲任务。
       第 3 章提供了有关堆内存管理的更多信息。 */
    for( ;; );
}
```
***清单 5.8*** *例 5.1 中 main() 的实现*

图 5.2 展示了例 5.1 产生的输出。

<a name="fig5.2" title="图5.2 执行示例5.1时产生的输出"></a>

* * *
![](media/image32.jpg)   
***图5.2*** *执行示例5.1时产生的输出*
* * *


图5.3展示了执行的顺序。

<a name="fig5.3" title="图5.3 示例5.1产生的执行顺序"></a>

* * *
![](media/image33.png)   
***图5.3*** *示例5.1产生的执行顺序*
* * *



## 5.4 从多个源接收数据

在FreeRTOS设计中，任务通常需要从多个源接收数据。接收任务需要知道数据的来源，以确定如何处理它。实现这一目标的一个简单设计模式是使用单个队列来传输既包含数据值又包含数据源的结构体，如图5.4所示。

<a name="fig5.4" title="图5.4 通过队列发送结构体的示例场景"></a>

* * *
![](media/image34.png)   
***图5.4*** *通过队列发送结构体的示例场景*
* * *

参考图5.4：

- 创建的队列持有`Data_t`类型的结构体。该结构体允许在一个消息中同时发送数据值和指示数据含义的枚举类型。

- 一个中央控制器任务执行主要的系统功能。它需要响应通过队列传递的输入和系统状态变化。

- 一个 CAN 总线任务用于封装 CAN 总线接口功能。当 CAN 总线任务接收并解码消息后，它会将已解码的消息以 `Data_t` 结构体发送给控制器任务。传递的结构体中的 `eDataID` 成员告诉控制器任务数据的类型。在这里所示的例子中，它是一个电机速度值。传递的结构体中的 `lDataValue` 成员则告诉控制器任务实际的电机速度值。

- 一个人机界面（HMI）任务用于封装所有的 HMI 功能。机器操作员可能通过多种方式输入命令和查询值，这些操作需要在 HMI 任务中检测和解释。当输入新命令时，HMI 任务会将命令以 `Data_t` 结构体发送给控制器任务。传递的结构体中的 `eDataID` 成员告诉控制器任务数据的类型。在这里所示的例子中，它是一个新的设定值。传递的结构体中的 `lDataValue` 成员则告诉控制器任务实际的设定值。

第 (RB-TBD) 章展示了如何扩展此设计模式，使得控制器任务可以直接回复排队结构的任务。

<a name="example5.2" title="示例 5.2 发送到队列时的阻塞，以及在队列上发送结构体"></a>
---
***示例 5.2*** *发送到队列时的阻塞，以及在队列上发送结构体*

---

示例 5.2 与示例 5.1 类似，但任务优先级相反，因此接收任务的优先级低于发送任务。此外，创建的队列中存储的是结构体而不是整数。

清单 5.9 展示了示例 5.2 中使用的结构体的定义。

<a name="list5.9" title="清单 5.9 将在队列中传递的结构体的定义，以及该示例中使用的两个变量的声明"></a>

```c
/* 定义一个枚举类型，用于标识数据的来源。 */
typedef enum
{
    eSender1,
    eSender2
} DataSource_t;

/* 定义将在队列中传递的结构体类型。 */
typedef struct
{
    uint8_t ucValue;
    DataSource_t eDataSource;
} Data_t;

/* 声明两个类型为 Data_t 的变量，它们将在队列中传递。 */
static const Data_t xStructsToSend[ 2 ] =
{
    { 100, eSender1 }, /* 由 Sender1 使用。 */
    { 200, eSender2 }  /* 由 Sender2 使用。 */
};
```
***清单 5.9*** *将在队列中传递的结构体的定义，以及该示例中使用的两个变量的声明*

在示例 5.1 中，接收任务的优先级最高，因此队列中永远不会包含超过一个项目。这是因为一旦数据被放入队列，接收任务就会抢占发送任务。在示例 5.2 中，发送任务的优先级更高，因此队列通常会满。这是因为一旦接收任务从队列中移除一个项目，它就会被其中一个发送任务抢占，该发送任务会立即重新填满队列。然后，发送任务重新进入阻塞状态，等待队列中再次有可用空间。

<a name="list5.10" title="代码清单 5.10 示例 5.2 中发送任务的实现"></a>

代码清单 5.10 展示了发送任务的实现。发送任务指定了 100 毫秒的阻塞时间，因此每次队列满时，它都会进入阻塞状态，等待队列中的空间可用。当队列中有可用空间，或者 100 毫秒内没有空间可用时，它将退出阻塞状态。在本例中，接收任务会持续释放队列中的空间，因此 100 毫秒的超时永远不会触发。

```c
static void vSenderTask( void *pvParameters )
{
    BaseType_t xStatus;
    const TickType_t xTicksToWait = pdMS_TO_TICKS( 100 );

    /* 与大多数任务一样，此任务在一个无限循环中实现。 */
    for( ;; )
    {
        /* 发送到队列。

           第二个参数是要发送的结构体的地址。该地址作为任务参数传入，因此直接使用 pvParameters。

           第三个参数是阻塞时间——如果队列已满，任务应保持在阻塞状态以等待队列中的空间可用的时间。这里指定了阻塞时间，因为发送任务的优先级高于接收任务，因此队列预计会变满。当两个发送任务都处于阻塞状态时，接收任务将移除队列中的项。 */
        xStatus = xQueueSendToBack( xQueue, pvParameters, xTicksToWait );

        if( xStatus != pdPASS )
        {
            /* 即使在等待 100 毫秒后，发送操作仍未能完成。这一定是错误，因为接收任务应在两个发送任务都处于阻塞状态时立即释放队列中的空间。 */
            vPrintString( "无法发送到队列。\r\n" );
        }
    }
}
```
***代码清单 5.10*** *示例 5.2 中发送任务的实现*

接收任务的优先级最低，因此只有在两个发送任务都处于阻塞状态时才会运行。发送任务只有在队列满时才会进入阻塞状态，因此接收任务只会在队列已满时执行。因此，即使没有指定阻塞时间，它也始终期望接收到数据。

<a name="list5.11" title="Listing 5.11 示例 5.2 的接收任务定义"></a>

```c
static void vReceiverTask( void *pvParameters )
{
    /* 声明用于存储从队列接收到的值的结构体。 */
    Data_t xReceivedStructure;
    BaseType_t xStatus;

    /* 该任务同样定义在一个无限循环中。 */
    for( ;; )
    {
        /* 由于该任务优先级最低，因此只有在发送任务处于阻塞状态时才会运行。
           发送任务只有在队列满时才会进入阻塞状态，因此该任务始终期望队列中的项数等于队列长度，
           本例中队列长度为 3。 */
        if( uxQueueMessagesWaiting( xQueue ) != 3 )
        {
            vPrintString( "队列应该已经满了！\r\n" );
        }

        /* 从队列中接收数据。

           第二个参数是接收数据的缓冲区。在本例中，缓冲区只是一个具有足够大小的变量地址，
           用于存储接收到的结构体。

           最后一个参数是阻塞时间——如果队列已为空，任务将在阻塞状态下等待数据可用的最长时间。
           本例中不需要阻塞时间，因为该任务仅在队列满时运行。 */
        xStatus = xQueueReceive( xQueue, &xReceivedStructure, 0 );

        if( xStatus == pdPASS )
        {
            /* 成功从队列中接收到数据，打印接收到的值及其来源。 */
            if( xReceivedStructure.eDataSource == eSender1 )
            {
                vPrintStringAndNumber( "来自发送者 1 = ", 
                                       xReceivedStructure.ucValue );
            }
            else
            {
                vPrintStringAndNumber( "来自发送者 2 = ", 
                                       xReceivedStructure.ucValue );
            }
        }
        else
        {
            /* 未从队列中接收到任何数据。这一定是错误，因为该任务仅在队列满时运行。 */
            vPrintString( "无法从队列中接收数据。\r\n" );
        }
    }
}
```
***清单 5.11*** *示例 5.2 的接收任务定义*

与之前的示例相比，`main()` 仅做了微小改动。队列被创建为可容纳三个 `Data_t` 结构体，并且发送任务和接收任务的优先级被反转。清单 5.12 展示了 `main()` 的实现。

<a name="list5.12" title="Listing 5.12 The implementation of main() for Example 5.2"></a>

```c
int main( void )
{
    /* 创建队列，最多可容纳 3 个类型为 Data_t 的结构体。 */
    xQueue = xQueueCreate( 3, sizeof( Data_t ) );

    if( xQueue != NULL )
    {
        /* 创建两个将数据写入队列的任务实例。
           参数用于传递任务将写入队列的结构体，
           因此一个任务将连续发送 xStructsToSend[ 0 ] 到队列，
           而另一个任务将连续发送 xStructsToSend[ 1 ]。
           两个任务的优先级均为 2，高于接收任务的优先级。 */
        xTaskCreate( vSenderTask, "Sender1", 1000, &( xStructsToSend[ 0 ] ),
                     2, NULL );
        xTaskCreate( vSenderTask, "Sender2", 1000, &( xStructsToSend[ 1 ] ),
                     2, NULL );

        /* 创建从队列中读取数据的任务。
           该任务的优先级为 1，低于发送任务的优先级。 */
        xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 1, NULL );

        /* 启动调度器，使创建的任务开始执行。 */
        vTaskStartScheduler();
    }
    else
    {
        /* 队列无法创建。 */
    }

    /* 如果一切正常，main() 将永远不会执行到这里，因为调度器现在正在运行任务。
       如果 main() 执行到这里，则可能是由于堆内存不足，无法创建空闲任务。
       第 3 章提供了有关堆内存管理的更多信息。 */
    for( ;; );
}
```
***清单 5.12*** *示例 5.2 中 main() 的实现*

图 5.5 展示了示例 5.2 的输出结果。

<a name="fig5.5" title="Figure 5.5 The output produced by Example 5.2"></a>

* * *
![](media/image35.jpg)   
***图 5.5*** *示例 5.2 生成的输出*
* * *

图 5.6 展示了由于发送任务的优先级高于接收任务的优先级而导致的执行顺序。下文进一步解释了图 5.6，并说明了为什么前四条消息来自同一个任务。

<a name="fig5.6" title="Figure 5.6 The sequence of execution produced by Example 5.2"></a>

* * *
![](media/image36.png)   
***图 5.6*** *示例 5.2 生成的执行顺序*
* * *

**图 5.6 的说明**

- t1

  任务 Sender 1 执行并向队列发送 3 个数据项。

- t2

  队列已满，因此 Sender 1 进入阻塞状态，等待其下一次发送完成。任务 Sender 2 现在是可以运行的优先级最高的任务，因此它进入运行状态。

- t3

  任务 Sender 2 发现队列已满，因此它进入阻塞状态，等待其第一次发送完成。任务 Receiver 现在是可以运行的优先级最高的任务，因此它进入运行状态。

- t4

  两个优先级高于接收任务的任务正在等待队列中的空间可用，导致任务 Receiver 在从队列中移除一个项目后立即被抢占。任务 Sender 1 和 Sender 2 具有相同的优先级，因此调度器选择等待时间最长的任务进入运行状态——在本例中为任务 Sender 1。

- t5

  任务 Sender 1 向队列发送另一个数据项。队列中只有一个空间可用，因此任务 Sender 1 进入阻塞状态，等待下一次发送完成。任务 Receiver 再次成为可以运行的优先级最高的任务，因此它进入运行状态。

  任务 Sender 1 已经向队列发送了四个项目，而任务 Sender 2 仍在等待向队列发送其第一个项目。

- t6

  两个优先级高于接收任务的任务正在等待队列中的空间可用，因此任务 Receiver 在从队列中移除一个项目后立即被抢占。这一次，Sender 2 的等待时间比 Sender 1 更长，因此 Sender 2 进入运行状态。

- t7

  任务发送者2向队列发送一个数据项。由于队列中只有一个空间，发送者2进入阻塞状态，等待其下一次发送完成。由于发送者1和发送者2两个任务都在等待队列中有可用空间，因此任务接收者是唯一可以进入运行状态的任务。

## 5.5 处理大型或可变大小数据

### 5.5.1 队列指针

如果队列中存储的数据量较大，则最好使用队列来传递指向数据的指针，而不是逐字节地将数据本身复制到队列中或从队列中复制出来。传递指针在处理时间和创建队列所需的内存大小方面都更高效。然而，在使用队列传递指针时，必须格外小心，以确保：

- 被指向内存的所有者明确定义。

  当通过指针在任务之间共享内存时，必须确保两个任务不会同时修改内存内容，或执行任何可能导致内存内容无效或不一致的操作。理想情况下，在将指针发送到队列之前，只有发送任务才应被允许访问该内存；在从队列接收指针之后，只有接收任务才应被允许访问该内存。

- 被指向的内存保持有效。

  如果被指向的内存是动态分配的，或者是从预分配缓冲池中获取的，则必须明确一个任务负责释放该内存。在内存被释放后，任何任务都不应尝试访问该内存。

  指针永远不应用于访问分配在任务栈上的数据。在栈帧发生变化后，该数据将不再有效。

通过示例，列表 5.13、5.14 和 5.15 演示了如何使用队列将缓冲区指针从一个任务发送到另一个任务：

- 列表 5.13 创建了一个最多可容纳 5 个指针的队列。

- 列表 5.14 分配了一个缓冲区，将字符串写入缓冲区，然后将指向该缓冲区的指针发送到队列。

- 列表 5.15 从队列接收指向缓冲区的指针，然后打印缓冲区中包含的字符串。

<a name="list5.13" title="列表 5.13 创建存储指针的队列"></a>

```c
/* 声明一个 QueueHandle_t 类型的变量，用于保存创建的队列的句柄。 */
QueueHandle_t xPointerQueue;

/* 创建一个最多可容纳 5 个指针的队列，本例中为字符指针。 */
xPointerQueue = xQueueCreate( 5, sizeof( char * ) );
```
***列表 5.13*** *创建存储指针的队列*

<a name="list5.14" title="列表 5.14 使用队列发送缓冲区指针"></a>

```c
/* 一个任务，它获取一个缓冲区，将字符串写入缓冲区，然后将缓冲区的地址发送到列表 5.13 中创建的队列。 */
void vStringSendingTask( void *pvParameters )
{
    char *pcStringToSend;
    const size_t xMaxStringLength = 50;
    BaseType_t xStringNumber = 0;

    for( ;; )
    {
        /* 获取一个至少为 xMaxStringLength 字符大小的缓冲区。
           prvGetBuffer() 的实现未展示——它可能从预分配缓冲池中获取缓冲区，或者只是动态分配缓冲区。 */
        pcStringToSend = ( char * ) prvGetBuffer( xMaxStringLength );

        /* 将字符串写入缓冲区。 */
        snprintf( pcStringToSend, xMaxStringLength, "String number %d\r\n",
                  xStringNumber );

        /* 增加计数器，以便在每次任务迭代时字符串都不同。 */
        xStringNumber++;

        /* 将缓冲区的地址发送到列表 5.13 中创建的队列。缓冲区的地址存储在 pcStringToSend 变量中。 */
        xQueueSend( xPointerQueue,   /* 队列的句柄。 */
                    &pcStringToSend, /* 指向缓冲区的指针的地址。 */
                    portMAX_DELAY );
    }
}
```
***列表 5.14*** *使用队列发送缓冲区指针*

<a name="list5.15" title="列表 5.15 使用队列接收缓冲区指针"></a>

```c
/* 一个任务，它从列表 5.13 中创建的队列接收缓冲区的地址，并在列表 5.14 中写入。缓冲区包含一个字符串，将其打印出来。 */

void vStringReceivingTask( void *pvParameters )
{
    char *pcReceivedString;

    for( ;; )
    {
        /* 接收缓冲区的地址。 */
        xQueueReceive( xPointerQueue,     /* 队列的句柄。 */
                       &pcReceivedString, /* 将缓冲区的地址存储在 pcReceivedString 中。 */
                       portMAX_DELAY );

        /* 缓冲区包含一个字符串，将其打印出来。 */
        vPrintString( pcReceivedString );

        /* 不再需要缓冲区 - 释放它以便可以重新使用或释放。 */
        prvReleaseBuffer( pcReceivedString );
    }
}
```
***列表 5.15*** *使用队列接收缓冲区指针*

### 5.5.2 使用队列发送不同类型和长度的数据[^9]

[^9]: FreeRTOS 消息缓冲区是队列的一种轻量级替代方案，用于存储可变长度的数据。

本书的前几节演示了两种强大的设计模式：向队列发送结构体，以及向队列发送指针。结合这些技术，任务可以使用单个队列从任何数据源接收任何数据类型。FreeRTOS+TCP TCP/IP 栈的实现提供了一个实际的例子，展示了如何实现这一点。

TCP/IP 栈运行在自己的任务中，必须处理来自许多不同源的事件。不同的事件类型与不同类型和长度的数据相关联。`IPStackEvent_t` 结构体描述了发生在 TCP/IP 任务外部的所有事件，并通过队列发送到 TCP/IP 任务。清单 5.16 展示了 `IPStackEvent_t` 结构体。`IPStackEvent_t` 结构体的 `pvData` 成员是一个指针，可以直接保存一个值，也可以指向一个缓冲区。

<a name="list5.16" title="清单 5.16 用于向 FreeRTOS+TCP 的 TCP/IP 栈任务发送事件的结构"></a>

```c
/* TCP/IP 栈中用于标识事件的枚举类型的子集。 */
typedef enum
{
    eNetworkDownEvent = 0, /* 网络接口已丢失或需要（重新）连接。 */
    eNetworkRxEvent,       /* 从网络接收到一个数据包。 */
    eTCPAcceptEvent,       /* 调用 FreeRTOS_accept() 以接受或等待新客户端。 */

/* 其他事件类型在此列出，但未在此清单中显示。 */

} eIPEvent_t;

/* 描述事件的结构体，并通过队列发送到 TCP/IP 任务。 */
typedef struct IP_TASK_COMMANDS
{
    /* 标识事件的枚举类型。参见上面的 eIPEvent_t 定义。 */
    eIPEvent_t eEventType;

    /* 可保存值或指向缓冲区的通用指针。 */
    void *pvData;

} IPStackEvent_t;
```
***清单 5.16*** *用于向 FreeRTOS+TCP 的 TCP/IP 栈任务发送事件的结构*

示例 TCP/IP 事件及其关联数据包括：

- `eNetworkRxEvent`：从网络接收到一个数据包。

网络接口使用`IPStackEvent_t`类型的结构体向TCP/IP任务发送数据接收事件。结构体的`eEventType`成员被设置为`eNetworkRxEvent`，而结构体的`pvData`成员则用于指向包含接收数据的缓冲区。清单5.17展示了一个伪代码示例。

<a name="list5.17" title="清单5.17 展示如何使用IPStackEvent_t结构体将从网络接收的数据发送到TCP/IP任务的伪代码"></a>

```c
void vSendRxDataToTheTCPTask( NetworkBufferDescriptor_t *pxRxedData )
{
    IPStackEvent_t xEventStruct;

    /* 完成IPStackEvent_t结构体。接收的数据存储在pxRxedData中。 */
    xEventStruct.eEventType = eNetworkRxEvent;
    xEventStruct.pvData = ( void * ) pxRxedData;

    /* 将IPStackEvent_t结构体发送到TCP/IP任务。 */
    xSendEventStructToIPTask( &xEventStruct );
}
```
***清单5.17*** *展示如何使用IPStackEvent_t结构体将从网络接收的数据发送到TCP/IP任务的伪代码*

- `eTCPAcceptEvent`: 表示一个套接字将接受或等待来自客户端的连接。

调用 `FreeRTOS_accept()` 的任务使用 `IPStackEvent_t` 类型的结构体向 TCP/IP 任务发送接受事件。结构体的 `eEventType` 成员设置为 `eTCPAcceptEvent`，结构体的 `pvData` 成员设置为正在接受连接的套接字句柄。清单 5.18 展示了一个伪代码示例。

<a name="list5.18" title="清单 5.18 展示如何使用 IPStackEvent_t 结构体将正在接受连接的套接字句柄发送给 TCP/IP 任务的伪代码"></a>

```c
void vSendAcceptRequestToTheTCPTask( Socket_t xSocket )
{
    IPStackEvent_t xEventStruct;

    /* 填充 IPStackEvent_t 结构体。 */
    xEventStruct.eEventType = eTCPAcceptEvent;
    xEventStruct.pvData = ( void * ) xSocket;

    /* 将 IPStackEvent_t 结构体发送给 TCP/IP 任务。 */
    xSendEventStructToIPTask( &xEventStruct );
}
```
***清单 5.18*** *展示如何使用 IPStackEvent_t 结构体将正在接受连接的套接字句柄发送给 TCP/IP 任务的伪代码*

- `eNetworkDownEvent`：网络需要连接或重新连接。

网络接口使用`IPStackEvent_t`类型的结构向TCP/IP任务发送网络断开事件。该结构的`eEventType`成员被设置为`eNetworkDownEvent`。网络断开事件不关联任何数据，因此结构的`pvData`成员未被使用。清单5.19展示了一个伪代码示例。

<a name="list5.19" title="清单5.19 展示如何使用IPStackEvent_t结构向TCP/IP任务发送网络断开事件的伪代码"></a>

```c
void vSendNetworkDownEventToTheTCPTask( Socket_t xSocket )
{
    IPStackEvent_t xEventStruct;

    /* 完成IPStackEvent_t结构。 */
    xEventStruct.eEventType = eNetworkDownEvent;

    xEventStruct.pvData = NULL; /* 未使用，但设置为NULL以确保完整性。 */

    /* 将IPStackEvent_t结构发送到TCP/IP任务。 */
    xSendEventStructToIPTask( &xEventStruct );
}
```
***清单5.19*** *展示如何使用IPStackEvent_t结构向TCP/IP任务发送网络断开事件的伪代码*

清单5.20展示了TCP/IP任务中接收和处理这些事件的代码。可以看到，从队列中接收到的`IPStackEvent_t`结构的`eEventType`成员用于确定如何解释`pvData`成员。

<a name="list5.20" title="代码清单 5.20 展示如何接收和处理 IPStackEvent_t 结构体的伪代码"></a>

  ```c
  IPStackEvent_t xReceivedEvent;

  /* 在网络事件队列上阻塞，直到接收到事件或 xNextIPSleep 个时钟周期过去仍未接收到事件。
     如果 xQueueReceive() 调用因超时返回而非接收到事件，则将 eEventType 设置为 eNoEvent。 */
  xReceivedEvent.eEventType = eNoEvent;
  xQueueReceive( xNetworkEventQueue, &xReceivedEvent, xNextIPSleep );

  /* 接收到了哪个事件（如果有的话）？ */
  switch( xReceivedEvent.eEventType )
  {
      case eNetworkDownEvent :
           /* 尝试（重新）建立连接。此事件未关联任何数据。 */
           prvProcessNetworkDownEvent();
           break;

      case eNetworkRxEvent:
           /* 网络接口接收到一个新数据包。接收到的数据的指针存储在 IPStackEvent_t 结构体的 pvData 成员中。
              处理接收到的数据。 */
           prvHandleEthernetPacket( ( NetworkBufferDescriptor_t * )
                                    ( xReceivedEvent.pvData ) );
           break;

      case eTCPAcceptEvent:
           /* FreeRTOS_accept() API 函数被调用。正在接受连接的套接字的句柄存储在接收到的 IPStackEvent_t 结构体的 pvData 成员中。 */
           xSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );
           xTCPCheckNewClient( xSocket );
           break;

      /* 其他事件类型以相同方式处理，但此处未展示。 */

  }
  ```
  ***代码清单 5.20*** *展示如何接收和处理 IPStackEvent_t 结构体的伪代码*


## 5.6 从多个队列接收数据

### 5.6.1 队列集

在许多应用设计中，常常需要单个任务接收不同大小、具有不同含义以及来自不同来源的数据。上一节演示了如何使用接收结构的单个队列以简洁高效的方式实现这一需求。然而，有时应用设计者需要在设计选择受到限制的情况下工作，这就不得不为某些数据源使用单独的队列。例如，集成到设计中的第三方代码可能假设存在一个专用队列。在这种情况下，可以使用“队列集”。

队列集允许任务从多个队列接收数据，而无需任务逐个轮询队列来确定哪个队列（如果有）包含数据。

使用队列集从多个数据源接收数据的设计不如使用接收结构的单个队列实现相同功能的设计简洁和高效。因此，建议仅在设计约束使其使用绝对必要时才使用队列集。

以下部分描述了如何使用队列集：

- 创建队列集。

- 将队列添加到队列集中。

  信号量也可以添加到队列集中。信号量将在本书后续章节中介绍。

- 从队列集中读取数据以确定队列集中哪些队列包含数据。

  当队列集中的某个队列接收到数据时，该接收队列的句柄会被发送到队列集，并在任务调用从队列集读取数据的函数时返回。因此，如果从队列集返回了一个队列句柄，则可以确定该句柄引用的队列包含数据，任务随后可以直接从该队列读取数据。

  > *注意：如果队列是队列集的成员，则每次从其句柄从队列集中接收时都必须从该队列读取数据，并且在从其句柄从队列集中接收之前不得从该队列读取数据。*

通过将 FreeRTOSConfig.h 中的 `configUSE_QUEUE_SETS` 编译时配置常量设置为 1，可以启用队列集功能。


### 5.6.2 xQueueCreateSet() API 函数

在使用队列集之前，必须显式创建它。在编写本文时，尚未实现 `xQueueCreateSetStatic()`。然而，队列集本身也是队列，因此可以通过精心设计的 `xQueueCreateStatic()` 调用使用预分配的内存来创建队列集。

队列集通过句柄引用，句柄是 `QueueSetHandle_t` 类型的变量。`xQueueCreateSet()` API 函数用于创建队列集，并返回一个引用该队列集的 `QueueSetHandle_t` 句柄。

<a name="list5.21" title="Listing 5.21 The xQueueCreateSet() API function prototype"></a>

```c
QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength);
```
***清单 5.21*** *xQueueCreateSet() API 函数原型*

**xQueueCreateSet() 参数和返回值**

- `uxEventQueueLength`

  当队列集中的某个队列接收到数据时，接收队列的句柄会被发送到队列集。`uxEventQueueLength` 定义了所创建的队列集在任何时刻可以容纳的最大队列句柄数量。

  只有在队列集中的队列接收到数据时，队列句柄才会被发送到队列集。如果队列已满，则无法接收数据，因此如果队列集中的所有队列都已满，则不会有队列句柄被发送到队列集。因此，队列集在任何时刻需要容纳的最大项数是队列集中所有队列长度的总和。

  例如，如果队列集中有三个空队列，每个队列的长度为五，那么队列集中的队列总共可以接收十五个项（三个队列乘以每个队列五个项），之后队列集中的所有队列都将满。在这个例子中，`uxEventQueueLength` 必须设置为十五，以确保队列集能够接收发送给它的所有项。

  信号量也可以添加到队列集中。信号量将在本书后面介绍。为了计算所需的 `uxEventQueueLength`，二进制信号量的长度为一，互斥量的长度为一，计数信号量的长度由信号量的最大计数值给出。

  再举一个例子，如果队列集包含一个长度为三的队列和一个二进制信号量（其长度为一），则 `uxEventQueueLength` 必须设置为四（三加一）。

- 返回值

  如果返回 NULL，则表示由于 FreeRTOS 没有足够的堆内存来分配队列集数据结构和存储区域，因此无法创建队列集。第 3 章提供了有关 FreeRTOS 堆的更多信息。

  如果返回非 NULL 值，则表示队列集创建成功，返回的值是所创建队列集的句柄。


### 5.6.3 xQueueAddToSet() API 函数

`xQueueAddToSet()` 用于将队列或信号量添加到队列集合中。信号量将在本书后续部分进行描述。

<a name="list5.22" title="代码清单 5.22 xQueueAddToSet() API 函数原型"></a>

```c
BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,
                           QueueSetHandle_t xQueueSet );
```
***代码清单 5.22*** *xQueueAddToSet() API 函数原型*

**xQueueAddToSet() 参数和返回值**

- `xQueueOrSemaphore`

  要添加到队列集合中的队列或信号量的句柄。

  队列句柄和信号量句柄都可以被强制转换为 `QueueSetMemberHandle_t` 类型。

- `xQueueSet`

  队列或信号量将要添加到的队列集合的句柄。

- 返回值

  有两种可能的返回值：

  1. `pdPASS`

     表示队列集合创建成功。

  1. `pdFAIL`

     表示无法将队列或信号量添加到队列集合中。

  队列和二进制信号量只有在为空时才能被添加到集合中。计数信号量只有在计数为零时才能被添加到集合中。队列和信号量同一时间只能是一个集合的成员。


### 5.6.4 xQueueSelectFromSet() API 函数

`xQueueSelectFromSet()` 从队列集合中读取一个队列句柄。

当作为集合成员的队列或信号量接收到数据时，接收队列或信号量的句柄会被发送到队列集合中，并在任务调用 `xQueueSelectFromSet()` 时返回。如果从 `xQueueSelectFromSet()` 调用中返回了句柄，则可以确定该句柄所引用的队列或信号量中包含数据，调用任务必须直接从该队列或信号量中读取数据。

> *注意：除非队列或信号量的句柄已从 `xQueueSelectFromSet()` 调用中返回，否则不要从作为集合成员的队列或信号量中读取数据。每次从 `xQueueSelectFromSet()` 调用中返回队列句柄或信号量句柄时，只能从队列或信号量中读取一个数据项。*

<a name="list5.23" title="Listing 5.23 The xQueueSelectFromSet() API function prototype"></a>

```c
QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,
                                            const TickType_t xTicksToWait );
```
***清单 5.23*** *xQueueSelectFromSet() API 函数原型*

**xQueueSelectFromSet() 参数和返回值**

- `xQueueSet`

  正在接收（读取）队列句柄或信号量句柄的队列集合的句柄。该队列集合句柄是通过调用用于创建队列集合的 `xQueueCreateSet()` 返回的。

- `xTicksToWait`

  调用任务在等待从队列集中接收队列或信号量句柄时，应保持在阻塞状态的最长时间，前提是队列集中的所有队列和信号量都为空。

  如果 `xTicksToWait` 为零，则 `xQueueSelectFromSet()` 会在队列集中所有队列和信号量为空时立即返回。

  阻塞时间以滴答周期为单位指定，因此其表示的绝对时间取决于滴答频率。可以使用宏 `pdMS_TO_TICKS()` 将以毫秒为单位的时间转换为以滴答为单位的时间。

  如果将 `xTicksToWait` 设置为 `portMAX_DELAY`，且 `FreeRTOSConfig.h` 中的 `INCLUDE_vTaskSuspend` 设置为 1，则任务将无限期等待（不会超时）。

- 返回值

  返回值不为 NULL 时，将是一个已知包含数据的队列或信号量的句柄。如果指定了阻塞时间（`xTicksToWait` 不为零），则调用任务可能被置入阻塞状态以等待队列或信号量中的数据可用，但在阻塞时间到期之前成功从队列集中读取了句柄。句柄以 `QueueSetMemberHandle_t` 类型返回，可强制转换为 `QueueHandle_t` 类型或 `SemaphoreHandle_t` 类型。

如果返回值为 `NULL`，则表示无法从队列集中读取句柄。如果指定了阻塞时间（`xTicksToWait` 不为零），则调用任务将被置于阻塞状态，等待其他任务或中断向队列集中的队列或信号量发送数据，但在发生之前阻塞时间已到期。

<a name="example5.3" title="示例 5.3 使用队列集"></a>
---
***示例 5.3*** *使用队列集</i></h3>

---

本示例创建了两个发送任务和一个接收任务。发送任务通过两个独立的队列向接收任务发送数据，每个任务对应一个队列。这两个队列被添加到同一个队列集中，接收任务从队列集中读取数据，以确定哪个队列包含数据。

任务、队列和队列集都在 `main()` 中创建——其实现见代码清单 5.24。

<a name="list5.24" title="代码清单 5.24 示例 5.3 的 main() 实现"></a>

```c
/* 声明两个类型为 QueueHandle_t 的变量。两个队列都被添加到同一个队列集中。 */
static QueueHandle_t xQueue1 = NULL, xQueue2 = NULL;

/* 声明一个类型为 QueueSetHandle_t 的变量。这是两个队列被添加到的队列集。 */
static QueueSetHandle_t xQueueSet = NULL;

int main( void )
{
    /* 创建两个队列，它们都发送字符指针。接收任务的优先级高于发送任务的优先级，
       因此队列中任何时候都不会有超过一个项目。*/
    xQueue1 = xQueueCreate( 1, sizeof( char * ) );
    xQueue2 = xQueueCreate( 1, sizeof( char * ) );

    /* 创建队列集。两个队列将被添加到集合中，每个队列最多可以包含 1 个项目，
       因此队列集在任何时候需要容纳的最大队列句柄数为 2（2 个队列乘以每个队列 1 个项目）。 */
    xQueueSet = xQueueCreateSet( 1 * 2 );

    /* 将两个队列添加到集合中。 */
    xQueueAddToSet( xQueue1, xQueueSet );
    xQueueAddToSet( xQueue2, xQueueSet );

    /* 创建向队列发送数据的任务。 */
    xTaskCreate( vSenderTask1, "Sender1", 1000, NULL, 1, NULL );
    xTaskCreate( vSenderTask2, "Sender2", 1000, NULL, 1, NULL );

    /* 创建从队列集读取数据以确定哪个队列包含数据的任务。 */
    xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 2, NULL );

    /* 启动调度器，使创建的任务开始执行。 */
    vTaskStartScheduler();

    /* 正常情况下，vTaskStartScheduler() 不应该返回，因此以下代码永远不会执行。 */
    for( ;; );
    return 0;
}
```
***代码清单 5.24*** *示例 5.3 的 main() 实现*

第一个发送任务使用 `xQueue1` 每 100 毫秒向接收任务发送一个字符指针。第二个发送任务使用 `xQueue2` 每 200 毫秒向接收任务发送一个字符指针。字符指针指向一个标识发送任务的字符串。代码清单 5.25 展示了这两个任务的实现。

<a name="list5.25" title="代码清单 5.25 示例 5.3 中使用的发送任务"></a>

```c
void vSenderTask1( void *pvParameters )
{
    const TickType_t xBlockTime = pdMS_TO_TICKS( 100 );
    const char * const pcMessage = "Message from vSenderTask1\r\n";

    /* 与大多数任务一样，此任务在一个无限循环中实现。 */

    for( ;; )
    {

        /* 阻塞 100ms。 */
        vTaskDelay( xBlockTime );

        /* 将此任务的字符串发送到 xQueue1。虽然队列只能容纳一个项目，
           但无需使用阻塞时间。这是因为从队列读取的任务优先级高于此任务；
           一旦此任务写入队列，它将被从队列读取的任务抢占，
           因此在 xQueueSend() 调用返回时，队列已经再次为空。
           阻塞时间设置为 0。 */
        xQueueSend( xQueue1, &pcMessage, 0 );
    }
}

/*-----------------------------------------------------------*/

void vSenderTask2( void *pvParameters )
{
    const TickType_t xBlockTime = pdMS_TO_TICKS( 200 );
    const char * const pcMessage = "Message from vSenderTask2\r\n";

    /* 与大多数任务一样，此任务在一个无限循环中实现。 */
    for( ;; )
    {
        /* 阻塞 200ms。 */
        vTaskDelay( xBlockTime );

        /* 将此任务的字符串发送到 xQueue2。虽然队列只能容纳一个项目，
           但无需使用阻塞时间。这是因为从队列读取的任务优先级高于此任务；
           一旦此任务写入队列，它将被从队列读取的任务抢占，
           因此在 xQueueSend() 调用返回时，队列已经再次为空。
           阻塞时间设置为 0。 */
        xQueueSend( xQueue2, &pcMessage, 0 );
    }
}
```
***代码清单 5.25*** *示例 5.3 中使用的发送任务*


发送任务写入的队列是同一个队列集的成员。每次任务向其中一个队列发送数据时，队列的句柄都会被发送到队列集。接收任务调用 `xQueueSelectFromSet()` 从队列集中读取队列句柄。接收任务从队列集接收到队列句柄后，它知道接收到的句柄所引用的队列中包含数据，因此它直接从队列中读取数据。它从队列中读取的数据是一个指向字符串的指针，接收任务会将该字符串打印出来。

如果 `xQueueSelectFromSet()` 的调用超时，它将返回 NULL。在示例 5.3 中，`xQueueSelectFromSet()` 的调用使用了无限阻塞时间，因此它永远不会超时，并且只会返回一个有效的队列句柄。因此，接收任务在使用返回值之前不需要检查 `xQueueSelectFromSet()` 是否返回了 NULL。

`xQueueSelectFromSet()` 仅当句柄引用的队列中包含数据时才会返回一个队列句柄，因此在从队列中读取数据时不需要使用阻塞时间。

清单 5.26 展示了接收任务的实现。

<a name="list5.26" title="清单 5.26 示例 5.3 中使用的接收任务"></a>

```c
void vReceiverTask( void *pvParameters )
{
    QueueHandle_t xQueueThatContainsData;
    char *pcReceivedString;

    /* 与大多数任务一样，此任务是在一个无限循环中实现的。 */
    for( ;; )
    {
        /* 阻塞队列集，等待集合中的某个队列包含数据。将 xQueueSelectFromSet() 返回的 QueueSetMemberHandle_t 值强制转换为 QueueHandle_t，因为已知集合中的所有成员都是队列（队列集中不包含任何信号量）。 */
        xQueueThatContainsData = ( QueueHandle_t ) xQueueSelectFromSet(
                                                     xQueueSet, portMAX_DELAY );

        /* 从队列集中读取时使用了无限阻塞时间，因此 xQueueSelectFromSet() 只有在集合中的某个队列包含数据时才会返回，并且 xQueueThatContainsData 不可能为 NULL。从队列中读取数据。由于已知队列中包含数据，因此不需要指定阻塞时间。阻塞时间设置为 0。 */
        xQueueReceive( xQueueThatContainsData, &pcReceivedString, 0 );

        /* 打印从队列中接收到的字符串。 */
        vPrintString( pcReceivedString );
    }
}
```
***清单 5.26*** *示例 5.3 中使用的接收任务*

图 5.7 展示了示例 5.3 的输出。可以看到，接收任务从两个发送任务接收字符串。`vSenderTask1()` 使用的阻塞时间是 `vSenderTask2()` 的一半，这导致 `vSenderTask1()` 发送的字符串打印的频率是 `vSenderTask2()` 的两倍。

<a name="fig5.7" title="图 5.7 执行示例 5.3 时产生的输出"></a>

* * *
![](media/image37.jpg)   
***图 5.7*** *执行示例 5.3 时产生的输出*
* * *

### 5.6.5 更现实的队列集使用场景

示例 5.3 展示了一个非常简单的案例；队列集中仅包含队列，并且包含的两个队列都用于发送字符指针。在实际应用中，队列集可能同时包含队列和信号量，并且队列可能不会都持有相同的数据类型。在这种情况下，使用 `xQueueSelectFromSet()` 返回的值之前，有必要对其进行测试。代码清单 5.27 展示了当队列集包含以下成员时，如何使用 `xQueueSelectFromSet()` 返回的值：

- 一个二值信号量。
- 一个用于读取字符指针的队列。
- 一个用于读取 `uint32_t` 类型值的队列。

列表 5.27 假设队列和信号量已被创建并添加到队列集合中。

<a name="list5.27" title="列表 5.27 使用包含队列和信号量的队列集合"></a>

```c
/* 用于接收字符指针的队列句柄。 */
QueueHandle_t xCharPointerQueue;

/* 用于接收uint32_t类型值的队列句柄。 */
QueueHandle_t xUint32tQueue;

/* 二进制信号量的句柄。 */
SemaphoreHandle_t xBinarySemaphore;

/* 包含上述两个队列和二进制信号量的队列集合句柄。 */
QueueSetHandle_t xQueueSet;

void vAMoreRealisticReceiverTask( void *pvParameters )
{
    QueueSetMemberHandle_t xHandle;
    char *pcReceivedString;
    uint32_t ulRecievedValue;
    const TickType_t xDelay100ms = pdMS_TO_TICKS( 100 );

    for( ;; )
    {
        /* 在队列集合上阻塞，最多等待100ms，以等待集合中的任何一个成员包含数据。 */
        xHandle = xQueueSelectFromSet( xQueueSet, xDelay100ms );

        /* 测试xQueueSelectFromSet()返回的值。如果返回值为NULL，则xQueueSelectFromSet()调用超时。
           如果返回值不为NULL，则返回值将是集合中某个成员的句柄。QueueSetMemberHandle_t
           值可以强制转换为QueueHandle_t或SemaphoreHandle_t。是否需要显式转换取决于编译器。 */

        if( xHandle == NULL )
        {
            /* xQueueSelectFromSet()调用超时。 */
        }
        else if( xHandle == ( QueueSetMemberHandle_t ) xCharPointerQueue )
        {
            /* xQueueSelectFromSet()返回了接收字符指针的队列的句柄。从队列中读取数据。
               已知队列包含数据，因此使用阻塞时间为0。 */
            xQueueReceive( xCharPointerQueue, &pcReceivedString, 0 );

            /* 可以在此处处理接收到的字符指针... */
        }
        else if( xHandle == ( QueueSetMemberHandle_t ) xUint32tQueue )
        {
            /* xQueueSelectFromSet()返回了接收uint32_t类型值的队列的句柄。从队列中读取数据。
               已知队列包含数据，因此使用阻塞时间为0。 */
            xQueueReceive(xUint32tQueue, &ulRecievedValue, 0 );

            /* 可以在此处处理接收到的值... */
        }
        else if( xHandle == ( QueueSetMemberHandle_t ) xBinarySemaphore )
        {
```
```c
            /* 调用xQueueSelectFromSet()返回了二进制信号量的句柄。
               现在获取该信号量。由于信号量已知可用，因此使用阻塞时间为0。 */
            xSemaphoreTake( xBinarySemaphore, 0 );

            /* 在获取信号量后需要执行的任何处理可以在此处进行... */
        }
    }
}
```
***清单 5.27*** *使用包含队列和信号量的队列集*


## 5.7 使用队列创建邮箱

在嵌入式社区中，术语尚未达成统一共识，因此“邮箱”在不同的实时操作系统中可能具有不同的含义。在本书中，术语“邮箱”用于指代长度为1的队列。队列之所以被称为邮箱，是因为它在应用程序中的使用方式，而不是因为它与队列在功能上存在差异：

- 队列用于将数据从一个任务发送到另一个任务，或从中断服务例程发送到任务。发送方将数据项放入队列，接收方从队列中移除数据项。数据通过队列从发送方传递到接收方。

- 邮箱用于保存任何任务或任何中断服务例程都可以读取的数据。数据不会通过邮箱传递，而是保留在邮箱中，直到被覆盖。发送方会覆盖邮箱中的值。接收方从邮箱中读取值，但不会从邮箱中移除该值。

本章介绍两个队列API函数，它们使队列能够被用作邮箱。

清单5.28展示了如何创建一个用作邮箱的队列。

<a name="list5.28" title="清单5.28 创建一个用作邮箱的队列"></a>

```c
/* 邮箱可以保存一个固定大小的数据项。数据项的大小在创建邮箱（队列）时设置。
   在本例中，邮箱被创建为保存一个Example_t结构体。Example_t包括一个时间戳，
   以便邮箱中保存的数据可以记录邮箱最后一次更新的时间。本示例中的时间戳仅用于
   演示目的——邮箱可以保存应用程序编写者所需的任何数据，且数据不需要包含时间戳。 */
typedef struct xExampleStructure
{
    TickType_t xTimeStamp;
    uint32_t ulValue;
} Example_t;

/* 邮箱是一个队列，因此它的句柄存储在类型为QueueHandle_t的变量中。 */
QueueHandle_t xMailbox;

void vAFunction( void )
{
    /* 创建将用作邮箱的队列。队列的长度为1，以便它可以与下面描述的
       xQueueOverwrite() API函数一起使用。 */
    xMailbox = xQueueCreate( 1, sizeof( Example_t ) );
}
```
***清单5.28*** *创建一个用作邮箱的队列*


### 5.7.1 xQueueOverwrite() API 函数

与 `xQueueSendToBack()` API 函数类似，`xQueueOverwrite()` API 函数用于向队列发送数据。与 `xQueueSendToBack()` 不同的是，如果队列已满，`xQueueOverwrite()` 会覆盖队列中已有的数据。

`xQueueOverwrite()` 只能用于长度为 1 的队列。覆盖模式总是会写入队列的前端并更新队列前端指针，但不会更新等待的消息数量。如果定义了 `configASSERT`，当队列长度大于 1 时，将会触发断言。

> *注意：切勿在中断服务例程中调用 `xQueueOverwrite()`。应使用其对应的中断安全版本 `xQueueOverwriteFromISR()`。*

<a name="list5.29" title="Listing 5.29 The xQueueOverwrite() API function prototype"></a>

```c
BaseType_t xQueueOverwrite( QueueHandle_t xQueue, const void * pvItemToQueue );
```
***清单 5.29*** *xQueueOverwrite() API 函数原型*

**xQueueOverwrite() 参数和返回值**

- `xQueue`

  数据将被发送（写入）到的队列句柄。该队列句柄是通过调用 `xQueueCreate()` 或 `xQueueCreateStatic()` 创建队列时返回的。

- `pvItemToQueue`

  指向要复制到队列中的数据的指针。

  队列可容纳的每个数据项的大小在创建队列时设置，因此将从 `pvItemToQueue` 复制相应数量的字节到队列存储区域。

- 返回值

  `xQueueOverwrite()` 即使在队列已满时也会写入队列，因此 `pdPASS` 是唯一可能的返回值。

清单 5.30 展示了如何使用 `xQueueOverwrite()` 向清单 5.28 中创建的邮箱（队列）写入数据。

<a name="list5.30" title="Listing 5.30 Using the xQueueOverwrite() API function"></a>

```c
void vUpdateMailbox( uint32_t ulNewValue )
{
    /* Example_t 已在清单 5.28 中定义。 */
    Example_t xData;

    /* 将新数据写入 Example_t 结构体。*/
    xData.ulValue = ulNewValue;

    /* 使用 RTOS 滴答计数作为 Example_t 结构体中存储的时间戳。 */
    xData.xTimeStamp = xTaskGetTickCount();

    /* 将结构体发送到邮箱——覆盖邮箱中已有的任何数据。 */
    xQueueOverwrite( xMailbox, &xData );
}
```
***清单 5.30*** *使用 xQueueOverwrite() API 函数*


### 5.7.2 xQueuePeek() API 函数

`xQueuePeek()` 从队列中接收（读取）一个数据项，但*不会*将该数据项从队列中移除。`xQueuePeek()` 从队列头部接收数据，但不会修改队列中存储的数据，也不会改变队列中数据的存储顺序。

> *注意：切勿从中断服务例程中调用 `xQueuePeek()`。应使用其中断安全版本 `xQueuePeekFromISR()` 代替。*

*`xQueuePeek()` 的函数参数和返回值与 `xQueueReceive()` 相同。*

<a name="list5.31" title="Listing 5.31 The xQueuePeek() API function prototype"></a>

```c
BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait );
```
***Listing 5.31*** *xQueuePeek() API 函数原型*


清单 5.32 展示了如何使用 `xQueuePeek()` 接收清单 5.30 中发布到邮箱（队列）中的数据项。

<a name="list5.32" title="Listing 5.32 Using the xQueuePeek() API function"></a>

```c
BaseType_t vReadMailbox( Example_t *pxData )
{
    TickType_t xPreviousTimeStamp;
    BaseType_t xDataUpdated;

    /* 此函数使用从邮箱接收到的最新值更新 Example_t 结构体。在 *pxData 被新数据覆盖之前，
       记录其中已经包含的时间戳。 */
    xPreviousTimeStamp = pxData->xTimeStamp;

    /* 使用邮箱中的数据更新 pxData 所指向的 Example_t 结构体。如果此处使用 xQueueReceive()，
       则邮箱将被清空，其他任务将无法再读取该数据。使用 xQueuePeek() 代替 xQueueReceive() 
       可以确保数据保留在邮箱中。

       指定了阻塞时间，因此如果邮箱为空，调用任务将被置于阻塞状态以等待邮箱中包含数据。
       使用了无限阻塞时间，因此无需检查 xQueuePeek() 的返回值，因为 xQueuePeek() 只
       会在有数据可用时返回。 */
    xQueuePeek( xMailbox, pxData, portMAX_DELAY );

    /* 如果从邮箱中读取的值自上次调用此函数以来已更新，则返回 pdTRUE。否则返回 pdFALSE。 */
    if( pxData->xTimeStamp > xPreviousTimeStamp )
    {
        xDataUpdated = pdTRUE;
    }
    else
    {
        xDataUpdated = pdFALSE;
    }

    return xDataUpdated;
}
```
***Listing 5.32*** *使用 xQueuePeek() API 函数*

