# 8 资源管理

## 8.1 章节介绍与范围

在多任务系统中，如果一个任务开始访问资源但在被转换出运行状态之前未完成访问，可能会出现错误。如果任务将资源留在不一致的状态，那么任何其他任务或中断对同一资源的访问可能会导致数据损坏或其他类似问题。

以下是一些示例：

* 访问外设

  考虑以下情景，其中两个任务尝试向液晶显示器（LCD）写入数据。

  1. 任务A执行并开始向LCD写入字符串"Hello world"。

  2. 任务A在输出字符串的开头部分--"Hello w"后被任务B抢占。

  3. 任务B在进入阻塞状态之前向LCD写入"Abort, Retry, Fail?"。

  4. 任务A从被抢占的地方继续执行，并完成输出其字符串的剩余字符--"orld"。

LCD现在显示了被破坏的字符串"Hello wAbort, Retry, Fail?orld"。

* 读、修改、写操作

  列表8.1显示了一行C代码，以及如何将C代码通常翻译成汇编代码的示例。可以看到，PORTA的值首先从内存读取到寄存器中，在寄存器中修改，然后写回内存。这称为读、修改、写操作。

   <a name="list8.1" title="Listing 8.1 An example read, modify, write sequence"></a>

   ```c
   /* The C code being compiled. */
   PORTA |= 0x01;

   /* The assembly code produced when the C code is compiled. */
   LOAD  R1,[#PORTA] ; Read a value from PORTA into R1
   MOVE  R2,#0x01    ; Move the absolute constant 1 into R2
   OR    R1,R2       ; Bitwise OR R1 (PORTA) with R2 (constant 1)
   STORE R1,[#PORTA] ; Store the new value back to PORTA
   ```
   ***Listing 8.1*** *An example read, modify, write sequence*

   这是一个“非原子”操作，因为它需要多条指令才能完成，并且可以被中断。考虑以下情景，其中两个任务尝试更新一个称为PORTA的内存映射寄存器。

1. 任务A将PORTA的值加载到寄存器中——这是操作的读取部分。

   2. 在任务A完成修改和写入操作之前，任务B抢占了任务A。

   3. 任务B更新了PORTA的值，然后进入阻塞状态。

   4. 任务A从被抢占的地方继续执行。它修改了已经在寄存器中持有的PORTA值的副本，然后将更新后的值写回PORTA。

   在这种情况下，任务A更新并写回了一个过时的PORTA值。任务B在任务A复制PORTA值之后，并在任务A将其修改后的值写回PORTA寄存器之前修改了PORTA。当任务A写入PORTA时，它覆盖了任务B已经执行的修改，从而有效地破坏了PORTA寄存器的值。

   这个示例使用了外设寄存器，但相同的原理也适用于对变量执行读取、修改、写入操作。

- 非原子访问变量

  更新结构体的多个成员，或者更新一个比架构的自然字长更大的变量（例如，在16位机器上更新一个32位变量），都是非原子操作的例子。如果它们被中断，可能会导致数据丢失或损坏。

- 函数可重入性

  如果从多个任务或从任务和中断中调用函数是安全的，那么该函数就是“可重入”的。可重入函数被称为“线程安全”，因为它们可以从多个执行线程访问而不会冒数据或逻辑操作被损坏的风险。

  每个任务都维护自己的堆栈和自己的处理器（硬件）寄存器值。如果一个函数不访问堆栈上存储的数据或寄存器中保存的数据，那么该函数就是可重入的，并且是线程安全的。清单8.2是一个可重入函数的例子。清单8.3是一个不可重入函数的例子。
如果应用程序使用newlib C库，必须在FreeRTOSConfig.h中将`configUSE_NEWLIB_REENTRANT`设置为1，以确保newlib所需的线程本地存储正确分配。

  如果应用程序使用picolibc C库，必须在FreeRTOSConfig.h中将`configUSE_PICOLIBC_TLS`设置为1，以确保picolibc所需的线程本地存储正确分配。

  如果应用程序使用任何其他C库，并且它需要线程本地存储（TLS），必须在FreeRTOSConfig.h中将`configUSE_C_RUNTIME_TLS_SUPPORT`设置为1，并实现以下宏：
  - `configTLS_BLOCK_TYPE` - 每个任务的TLS块的类型。
  - `configINIT_TLS_BLOCK` - 初始化每个任务的TLS块。
  - `configSET_TLS_BLOCK` - 更新当前TLS块。在上下文切换期间调用，以确保使用正确的TLS块。
  - `configDEINIT_TLS_BLOCK` - 释放TLS块。

  <a name="list8.2" title="Listing 8.2 An example of a reentrant function"></a>

  ```c
  /* 将参数传递给函数。这将通过堆栈或处理器寄存器传递。无论哪种方式，都是安全的，因为每个调用该函数的任务或中断都维护自己的堆栈和自己的寄存器值集，因此每个调用该函数的任务或中断都将拥有lVar1的自己的副本。 */
  long lAddOneHundred( long lVar1 )
  {
      /* 此函数作用域变量也将分配到堆栈或寄存器，具体取决于编译器和优化级别。每个调用此函数的任务或中断都将拥有lVar2的自己的副本。 */
      long lVar2;

      lVar2 = lVar1 + 100;
      return lVar2;
  }
  ```
  ***Listing 8.2*** *一个可重入函数的示例*

  <a name="list8.3" title="Listing 8.3 An example of a function that is not reentrant"></a>

  ```c
  /* 在这种情况下，lVar1是一个全局变量，因此每个调用lNonsenseFunction的任务都将访问该变量的同一个单一副本。 */
  long lVar1;

  long lNonsenseFunction( void )
  {
      /* lState是静态的，因此不会在堆栈上分配。每个调用此函数的任务都将访问该变量的同一个单一副本。 */
      static long lState = 0;
      long lReturn;

      switch( lState )
      {
          case 0 : lReturn = lVar1 + 10;
                   lState = 1;
                   break;

          case 1 : lReturn = lVar1 + 20;
                   lState = 0;
                   break;
      }
  }
  ```
  ***Listing 8.3*** *一个不可重入函数的示例*



### 8.1.1 互斥

为了确保数据一致性始终得到维护，对任务之间共享的资源或任务和中断之间共享的资源的访问必须使用“互斥”技术进行管理。目标是确保一旦任务开始访问一个非重入且非线程安全的共享资源，该任务在资源返回到一致状态之前具有对资源的独占访问权。

FreeRTOS 提供了几种可以用来实现互斥的功能，但最好的互斥方法是（尽可能地，因为这往往不切实际）设计应用程序，使资源不共享，并且每个资源只从单个任务访问。

### 8.1.2 范围

本章涵盖以下内容：

- 资源管理和控制何时以及为什么是必要的。
- 什么是临界区。
- 互斥意味着什么。
- 暂停调度器意味着什么。
- 如何使用互斥锁。
- 如何创建和使用门卫任务。
- 优先级反转是什么，以及优先级继承如何减少（但不能消除）其影响。


## 8.2 临界区和挂起调度器

### 8.2.1 基本临界区

基本临界区是由对宏 `taskENTER_CRITICAL()` 和 `taskEXIT_CRITICAL()` 的调用包围的代码区域。临界区也称为临界区域。

`taskENTER_CRITICAL()` 和 `taskEXIT_CRITICAL()` 不接受任何参数，也不返回值[^23]。它们的使用示例如清单 8.4 所示。

[^23]: 函数样式的宏并不真正“返回值”，就像真正的函数那样。本书在最简单的情况下将“返回值”这一术语应用于宏，以便将宏视为函数。

<a name="list8.4" title="清单 8.4 使用临界区保护对寄存器的访问"></a>

```c
/* 通过将其放在临界区内，确保对 PORTA 寄存器的访问不会被中断。进入临界区。 */
taskENTER_CRITICAL();

/* 在调用 taskENTER_CRITICAL() 和调用 taskEXIT_CRITICAL() 之间不能发生切换到另一个任务。中断仍然可以在允许中断嵌套的 FreeRTOS 端口上执行，但只有逻辑优先级高于分配给 configMAX_SYSCALL_INTERRUPT_PRIORITY 常量的值的中断——并且这些中断不允许调用 FreeRTOS API 函数。 */
PORTA |= 0x01;

/* 对 PORTA 的访问已完成，因此可以安全地退出临界区。 */
taskEXIT_CRITICAL();
```
***清单 8.4*** *使用临界区保护对寄存器的访问*


随本书一起提供的示例项目使用一个名为 `vPrintString()` 的函数将字符串写入标准输出，当使用 FreeRTOS Windows 端口时，标准输出是终端窗口。`vPrintString()` 由许多不同的任务调用；因此，理论上，其实现可以使用临界区保护对标准输出的访问，如清单 8.5 所示。

<a name="list8.5" title="Listing 8.5 vPrintString() 的一种可能实现"></a>

```c
void vPrintString( const char *pcString )
{
    /* 使用临界区作为粗略的互斥方法，将字符串写入标准输出。 */
    taskENTER_CRITICAL();
    {
        printf( "%s", pcString );
        fflush( stdout );
    }
    taskEXIT_CRITICAL();
}
```
***Listing 8.5*** *vPrintString() 的一种可能实现*


以这种方式实现的临界区是提供互斥的一种非常粗略的方法。它们通过禁用中断来工作，要么完全禁用，要么禁用到由 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 设置的中断优先级，具体取决于使用的 FreeRTOS 端口。抢占式上下文切换只能在中断中发生，因此只要中断保持禁用状态，调用 `taskENTER_CRITICAL()` 的任务在退出临界区之前将保持在运行状态。

基本的临界区必须保持非常短，否则它们将对中断响应时间产生不利影响。每次调用 `taskENTER_CRITICAL()` 必须紧密配对调用 `taskEXIT_CRITICAL()`。因此，标准输出（stdout，或计算机写入其输出数据的流）不应使用临界区进行保护（如列表 8.5 所示），因为写入终端可能是一个相对较长的操作。本章的示例探讨了替代方案。

嵌套的临界区是安全的，因为内核会跟踪嵌套的深度。只有当嵌套深度返回到零时，临界区才会退出，即每个先前的`taskENTER_CRITICAL()`调用都执行了一个`taskEXIT_CRITICAL()`调用。

调用`taskENTER_CRITICAL()`和`taskEXIT_CRITICAL()`是任务在运行FreeRTOS的处理器上更改中断使能状态的唯一合法方式。通过任何其他方式更改中断使能状态将使宏的嵌套计数无效。

`taskENTER_CRITICAL()`和`taskEXIT_CRITICAL()`不以'FromISR'结尾，因此不能从中断服务例程中调用。`taskENTER_CRITICAL_FROM_ISR()`是`taskENTER_CRITICAL()`的中断安全版本，`taskEXIT_CRITICAL_FROM_ISR()`是`taskEXIT_CRITICAL()`的中断安全版本。中断安全版本仅为允许中断嵌套的FreeRTOS端口提供——在不允许中断嵌套的端口中，它们将过时。

`taskENTER_CRITICAL_FROM_ISR()` 返回一个值，必须传递给匹配的 `taskEXIT_CRITICAL_FROM_ISR()` 调用。这在清单 8.6 中有所演示。

<a name="list8.6" title="清单 8.6 在中断服务例程中使用临界区"></a>

```c
void vAnInterruptServiceRoutine( void )
{
    /* 声明一个变量，用于保存 taskENTER_CRITICAL_FROM_ISR() 的返回值。 */
    UBaseType_t uxSavedInterruptStatus;

    /* 此部分的 ISR 可以被任何优先级更高的中断中断。 */

    /* 使用 taskENTER_CRITICAL_FROM_ISR() 保护此 ISR 的某个区域。
       保存 taskENTER_CRITICAL_FROM_ISR() 返回的值，以便将其传递给匹配的 taskEXIT_CRITICAL_FROM_ISR() 调用。 */
    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();

    /* 此部分的 ISR 在调用 taskENTER_CRITICAL_FROM_ISR() 和 taskEXIT_CRITICAL_FROM_ISR() 之间，因此只能被优先级高于 configMAX_SYSCALL_INTERRUPT_PRIORITY 常量设置的中断中断。 */

    /* 通过调用 taskEXIT_CRITICAL_FROM_ISR() 退出临界区，将匹配的 taskENTER_CRITICAL_FROM_ISR() 调用返回的值传递进去。 */
    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

    /* 此部分的 ISR 可以被任何优先级更高的中断中断。 */
}
```
***清单 8.6*** *在中断服务例程中使用临界区*

使用更多的处理时间执行进入和随后退出临界区的代码，而不是执行实际被临界区保护的代码，是浪费的。基本的临界区进入非常快，退出非常快，并且总是确定性的，因此在被保护的代码区域非常短时使用它们是理想的。

### 8.2.2 暂停（或锁定）调度程序

关键部分也可以通过暂停调度程序来创建。有时暂停调度程序也称为“锁定”调度程序。

基本的关键部分保护代码区域免受其他任务和中断的访问，但通过暂停调度程序实现的关键部分只保护代码区域免受其他任务的访问，因为中断仍然启用。

如果关键部分太长，无法通过简单禁用中断来实现，可以通过暂停调度程序来实现。然而，在调度程序暂停期间的中断活动可能会使恢复（或“取消暂停”）调度程序成为一个相对较长的操作，因此必须考虑在每种情况下使用哪种方法是最好的。

### 8.2.3 vTaskSuspendAll() API 函数

<a name="list8.7" title="Listing 8.7 The vTaskSuspendAll() API function prototype"></a>

```c
void vTaskSuspendAll( void );
```
***Listing 8.7*** *The vTaskSuspendAll() API function prototype*

调度程序通过调用 `vTaskSuspendAll()` 来暂停。暂停调度程序可以防止上下文切换发生，但保持中断启用。如果在调度程序暂停期间中断请求上下文切换，则请求将保持挂起，并在调度程序恢复（取消暂停）时执行。

在调度程序暂停期间不得调用 FreeRTOS API 函数。


### 8.2.4 xTaskResumeAll() API 函数

<a name="list8.8" title="Listing 8.8 The xTaskResumeAll() API function prototype"></a>

```c
BaseType_t xTaskResumeAll( void );
```
***Listing 8.8*** *xTaskResumeAll() API 函数原型*

调度器通过调用 `xTaskResumeAll()` 来恢复（取消暂停）。

**xTaskResumeAll() 返回值**

- 返回值

  在调度器暂停时请求的上下文切换将被保留并仅在调度器恢复时执行。如果在 `xTaskResumeAll()` 返回之前执行了一个挂起的上下文切换，则返回 `pdTRUE`。否则返回 `pdFALSE`。

调用 `vTaskSuspendAll()` 和 `xTaskResumeAll()` 可以嵌套，因为内核保留了嵌套深度的计数。调度器仅在嵌套深度返回零时才会恢复，即每个先前的 `vTaskSuspendAll()` 调用都执行了一个 `xTaskResumeAll()` 调用。

Listing 8.9 显示了 `vPrintString()` 的实际实现，它暂停调度器以保护对终端输出的访问。

<a name="list8.9" title="Listing 8.9 The implementation of vPrintString()"></a>

```c
void vPrintString( const char *pcString )
{
    /* Write the string to stdout, suspending the scheduler as a method of
       mutual exclusion. */
    vTaskSuspendScheduler();
    {
        printf( "%s", pcString );
        fflush( stdout );
    }
    xTaskResumeScheduler();
}
```
***Listing 8.9*** *vPrintString() 的实现*


## 8.3 互斥锁（和二进制信号量）

互斥锁是一种特殊类型的二进制信号量，用于控制两个或多个任务之间共享资源的访问。互斥锁一词源自“互斥”。`configUSE_MUTEXES` 必须在 FreeRTOSConfig.h 中设置为 1，以使互斥锁可用。

在互斥场景中使用时，互斥锁可以被视为与共享资源相关联的令牌。为了合法地访问资源，任务必须首先成功“获取”令牌（成为令牌持有者）。当令牌持有者完成资源使用后，必须“释放”令牌。只有在令牌被返回后，另一个任务才能成功获取令牌，然后安全地访问相同的共享资源。如果任务不持有令牌，则不允许访问共享资源。该机制如图 8.1 所示。

尽管互斥锁和二进制信号量具有许多相似之处，但图 8.1 中所示的互斥锁用于互斥的场景与图 7.6 中所示的二进制信号量用于同步的场景完全不同。主要区别在于信号量在被获取后的处理方式：

- 用于互斥的信号量必须始终被返回。
- 用于同步的信号量通常被丢弃且不返回。

<a name="fig8.1" title="图 8.1 使用互斥锁实现的互斥"></a>

* * *
![](media/image63.png)
***图 8.1*** *使用互斥锁实现的互斥*
* * *

该机制纯粹依赖于应用程序编写者的纪律。任务在任何时候都可以访问资源，但每个任务“同意”在不能成为互斥锁持有者的情况下不这样做。


### 8.3.1 xSemaphoreCreateMutex() API 函数

FreeRTOS 还包括 `xSemaphoreCreateMutexStatic()` 函数，该函数在编译时静态分配创建互斥锁所需的内存：互斥锁是一种信号量。所有各种类型的 FreeRTOS 信号量句柄都存储在 `SemaphoreHandle_t` 类型的变量中。

在使用互斥锁之前，必须先创建它。要创建互斥锁类型的信号量，请使用 `xSemaphoreCreateMutex()` API 函数。

<a name="list8.10" title="Listing 8.10 The xSemaphoreCreateMutex() API function prototype"></a>

```c
SemaphoreHandle_t xSemaphoreCreateMutex( void );
```
***Listing 8.10*** *The xSemaphoreCreateMutex() API function prototype*

**xSemaphoreCreateMutex() 返回值**

- 返回值

  如果返回 NULL，则表示无法创建互斥锁，因为没有足够的堆内存可供 FreeRTOS 分配互斥锁数据结构。第 3 章提供了有关堆内存管理的更多信息。

  非 NULL 的返回值表示互斥锁已成功创建。返回的值应存储为创建的互斥锁的句柄。

<a name="example8.1" title="示例 8.1 重写 vPrintString() 以使用信号量"></a>
---
***示例 8.1*** *重写 vPrintString() 以使用信号量*

---

这个示例创建了一个名为 `prvNewPrintString()` 的 `vPrintString()` 的新版本，然后从多个任务调用新函数。`prvNewPrintString()` 在功能上与 `vPrintString()` 完全相同，但使用互斥锁控制对标准输出的访问，而不是锁定调度程序。`prvNewPrintString()` 的实现如清单 8.11 所示。

<a name="list8.11" title="清单 8.11 prvNewPrintString() 的实现"></a>

```c
static void prvNewPrintString( const char *pcString )
{
    /* 互斥锁在调度程序启动之前创建，因此在该任务执行时已经存在。

       尝试获取互斥锁，无限期阻塞以等待互斥锁（如果立即不可用）。xSemaphoreTake() 的调用只会在成功获取互斥锁时返回，因此无需检查函数返回值。如果使用任何其他延迟期，则必须在访问共享资源（在这种情况下是标准输出）之前检查 xSemaphoreTake() 是否返回 pdTRUE。如本书前面所述，不建议在生产代码中使用无限超时。 */
    xSemaphoreTake( xMutex, portMAX_DELAY );
    {
        /* 以下行只会在成功获取互斥锁后执行。现在可以自由访问标准输出，因为一次只能有一个任务拥有互斥锁。 */
        printf( "%s", pcString );
        fflush( stdout );

        /* 必须归还互斥锁！ */
    }
    xSemaphoreGive( xMutex );
}
```
***清单 8.11*** *prvNewPrintString() 的实现*

`prvNewPrintString()` 由两个实例的任务 `prvPrintTask()` 重复调用，每次调用之间使用随机延迟时间。任务参数用于将唯一字符串传递给每个任务实例。`prvPrintTask()` 的实现如清单 8.12 所示。

<a name="list8.12" title="Listing 8.12 The implementation of prvPrintTask() for Example 8.1"></a>

```c
static void prvPrintTask( void *pvParameters )
{
    char *pcStringToPrint;
    const TickType_t xMaxBlockTimeTicks = 0x20;

    /* Two instances of this task are created. The string printed by the task
       is passed into the task using the task's parameter. The parameter is
       cast to the required type. */
    pcStringToPrint = ( char * ) pvParameters;

    for( ;; )
    {
        /* Print out the string using the newly defined function. */
        prvNewPrintString( pcStringToPrint );

        /* Wait a pseudo random time. Note that rand() is not necessarily
           reentrant, but in this case it does not really matter as the code
           does not care what value is returned. In a more secure application
           a version of rand() that is known to be reentrant should be used -
           or calls to rand() should be protected using a critical section. */
        vTaskDelay( ( rand() % xMaxBlockTimeTicks ) );
    }
}
```
***Listing 8.12*** *The implementation of prvPrintTask() for Example 8.1*


As normal, `main()` simply creates the mutex, creates the tasks, then
starts the scheduler. The implementation is shown in Listing 8.13.

两个实例的 `prvPrintTask()` 是以不同的优先级创建的，因此优先级较低的任务有时会被优先级较高的任务抢占。由于使用了互斥锁来确保每个任务都能互斥地访问终端，即使发生抢占，显示的字符串也会是正确的，不会被破坏。通过减少任务在阻塞状态下花费的最大时间，可以增加抢占的频率，该时间由 `xMaxBlockTimeTicks` 常量设置。

使用 FreeRTOS Windows 端口时，特定于示例 8.1 的说明：

- 调用 `printf()` 会生成一个 Windows 系统调用。Windows 系统调用不受 FreeRTOS 控制，可能会引入不稳定性。
- Windows 系统调用的执行方式使得即使不使用互斥锁，也很少看到被破坏的字符串。

<a name="list8.13" title="清单 8.13 示例 8.1 的 main() 的实现"></a>

```c
int main( void )
{
    /* 在使用信号量之前，必须显式创建它。在这个示例中创建了一个互斥信号量。 */
    xMutex = xSemaphoreCreateMutex();

    /* 在创建任务之前，检查信号量是否成功创建。 */
    if( xMutex != NULL )
    {
        /* 创建两个实例的任务，这些任务写入标准输出。它们写入的字符串作为任务的参数传递给任务。任务以不同的优先级创建，因此会发生一些抢占。 */
        xTaskCreate( prvPrintTask, "Print1", 1000,
                     "Task 1 ***************************************\r\n",
                     1, NULL );

        xTaskCreate( prvPrintTask, "Print2", 1000,
                     "Task 2 ---------------------------------------\r\n",
                     2, NULL );

        /* 启动调度程序，以便创建的任务开始执行。 */
        vTaskStartScheduler();
    }

    /* 如果一切正常，main() 将永远不会到达这里，因为调度程序现在正在运行任务。如果 main() 到达这里，那么很可能是因为没有足够的堆内存来创建空闲任务。第 3 章提供了有关堆内存管理的更多信息。 */
    for( ;; );
}
```
***清单 8.13*** *示例 8.1 的 main() 的实现*

执行示例 8.1 时生成的输出显示在图 8.2 中。图 8.3 描述了一个可能的执行序列。

<a name="fig8.2" title="图 8.2 执行示例 8.1 时产生的输出"></a>

* * *
![](media/image64.jpg)
***图 8.2*** *执行示例 8.1 时产生的输出*
* * *

图 8.2 显示，如预期的那样，终端上显示的字符串没有任何损坏。随机排序是由于任务使用的随机延迟期导致的。

<a name="fig8.3" title="图 8.3 示例 8.1 的可能执行序列"></a>

* * *
![](media/image65.png)
***图 8.3*** *示例 8.1 的可能执行序列*
* * *

### 8.3.2 优先级反转

图 8.3 展示了使用互斥锁提供互斥访问的潜在陷阱之一。所描绘的执行序列显示了优先级较高的任务 2 不得不等待优先级较低的任务 1 放弃对互斥锁的控制。优先级较高的任务被较低优先级的任务以这种方式延迟，称为“优先级反转”。这种不良行为会进一步加剧，如果在高优先级任务等待信号量时开始执行一个中等优先级的任务，结果将是高优先级任务等待低优先级任务，而低优先级任务甚至无法执行。这通常被称为 _无界优先级反转_，因为中等优先级任务可能会无限期地阻塞低和高优先级任务。

这种最坏情况在图 8.4 中显示。

<a name="fig8.4" title="图 8.4 最坏情况的优先级反转场景"></a>

* * *
![](media/image66.png)
***图 8.4*** *最坏情况的优先级反转场景*
* * *

优先级反转可能是一个重大问题，但在小型嵌入式系统中，它通常可以在系统设计时通过考虑资源的访问方式来避免。


### 8.3.3 优先级继承

FreeRTOS互斥锁和二进制信号量非常相似——区别在于互斥锁包含基本的“优先级继承”机制，而二进制信号量则没有。优先级继承是一种减少优先级反转负面影响的方案。它并不能“修复”优先级反转，但通过确保反转始终是时间有界的，从而减轻了其影响。然而，优先级继承使系统时序分析变得复杂，依赖它来实现正确的系统操作并不是好习惯。

优先级继承的工作原理是临时提高互斥锁持有者的优先级，使其与尝试获取相同互斥锁的最高优先级任务相同。持有互斥锁的低优先级任务“继承”正在等待互斥锁的任务的优先级。这由图8.5演示。当互斥锁持有者释放互斥锁时，其优先级会自动恢复到原始值。

<a name="fig8.5" title="图8.5 优先级继承减少优先级反转的影响"></a>

* * *
![](media/image67.png)
***图8.5*** *优先级继承减少优先级反转的影响*
* * *

如上所述，优先级继承功能影响使用互斥锁的任务的优先级。因此，互斥锁不能在中断服务例程中使用。

FreeRTOS实现了一个基本的优先级继承机制，该机制在优化空间和执行周期方面进行了设计。完整的优先级继承机制需要更多的数据和处理器周期来确定任何时刻的继承优先级，特别是当一个任务同时持有多个互斥锁时。

需要记住优先级继承机制的具体行为：
* 如果一个任务在未先释放已持有的互斥锁的情况下获取互斥锁，则其继承的优先级可能会进一步提高。
* 一个任务将保持在其最高继承优先级，直到它释放了所有持有的互斥锁。这与释放互斥锁的顺序无关。
* 如果持有多个互斥锁，任务将保持在最高继承优先级，无论等待任何持有的互斥锁的任务是否完成等待（超时）。


### 8.3.4 死锁（或致命拥抱）

“死锁”是使用互斥锁进行互斥时的另一个潜在陷阱。死锁有时也被称为更具戏剧性的名字“致命拥抱”。

死锁发生在两个任务都无法继续执行，因为它们都在等待对方持有的资源。考虑以下情景，其中任务A和任务B都需要获取互斥锁X和互斥锁Y才能执行某个操作：

1. 任务A执行并成功获取互斥锁X。

2. 任务A被任务B抢占。

3. 任务B成功获取互斥锁Y，然后尝试获取互斥锁X，但互斥锁X被任务A持有，因此对任务B不可用。任务B选择进入阻塞状态，等待互斥锁X被释放。

4. 任务A继续执行。它尝试获取互斥锁Y，但互斥锁Y被任务B持有，因此对任务A不可用。任务A选择进入阻塞状态，等待互斥锁Y被释放。

在这个情景的结尾，任务A在等待任务B持有的互斥锁，而任务B在等待任务A持有的互斥锁。死锁发生了，因为没有一个任务能够继续执行。

与优先级反转一样，避免死锁的最佳方法是在设计时考虑其潜在性，并设计系统以确保死锁不会发生。特别是，正如本书中之前所述，通常不建议任务无限期等待（没有超时）获取互斥锁。相反，使用一个比预期等待互斥锁的最大时间稍长的超时时间——然后在该时间内无法获取互斥锁将是设计错误的症状，可能是死锁。

在实际中，死锁在小型嵌入式系统中并不是一个大问题，因为系统设计师可以对整个应用程序有很好的理解，因此可以识别并消除可能发生死锁的地方。


### 8.3.5 递归互斥锁

任务也可能与自身发生死锁。如果任务尝试在未先返回互斥锁的情况下多次获取同一互斥锁，就会发生这种情况。考虑以下情景：

1. 任务成功获取一个互斥锁。

2. 在持有互斥锁的同时，任务调用一个库函数。

3. 库函数的实现尝试获取同一互斥锁，并进入阻塞状态以等待互斥锁可用。

在该情景结束时，任务处于阻塞状态以等待互斥锁被返回，但任务已经是互斥锁的持有者。发生死锁是因为任务处于阻塞状态以等待自身。

可以通过使用递归互斥锁代替标准互斥锁来避免这种类型的死锁。递归互斥锁可以被同一任务多次“获取”，并且只有在对每个前一个“获取”递归互斥锁的调用执行一次“释放”递归互斥锁的调用后才会被返回。

标准互斥锁和递归互斥锁的创建和使用方式相似：

- 标准互斥锁使用 `xSemaphoreCreateMutex()` 创建。递归互斥锁使用 `xSemaphoreCreateRecursiveMutex()` 创建。这两个API函数具有相同的原型。

- 标准互斥锁使用 `xSemaphoreTake()` 获取。递归互斥锁使用 `xSemaphoreTakeRecursive()` 获取。这两个API函数具有相同的原型。

- 标准互斥锁使用 `xSemaphoreGive()` 释放。递归互斥锁使用 `xSemaphoreGiveRecursive()` 释放。这两个API函数具有相同的原型。

清单 8.14 演示了如何创建和使用递归互斥锁。

<a name="list8.14" title="Listing 8.14 Creating and using a recursive mutex"></a>

```c
/* Recursive mutexes are variables of type SemaphoreHandle_t. */
SemaphoreHandle_t xRecursiveMutex;

/* The implementation of a task that creates and uses a recursive mutex. */
void vTaskFunction( void *pvParameters )
{
    const TickType_t xMaxBlock20ms = pdMS_TO_TICKS( 20 );

    /* Before a recursive mutex is used it must be explicitly created. */
    xRecursiveMutex = xSemaphoreCreateRecursiveMutex();

    /* Check the semaphore was created successfully. configASSERT() is
       described in section 11.2. */
    configASSERT( xRecursiveMutex );

    /* As per most tasks, this task is implemented as an infinite loop. */
    for( ;; )
    {
        /* ... */

        /* Take the recursive mutex. */
        if( xSemaphoreTakeRecursive( xRecursiveMutex, xMaxBlock20ms ) == pdPASS )
        {
            /* The recursive mutex was successfully obtained. The task can now
               access the resource the mutex is protecting. At this point the
               recursive call count (which is the number of nested calls to
               xSemaphoreTakeRecursive()) is 1, as the recursive mutex has
               only been taken once. */

            /* While it already holds the recursive mutex, the task takes the
               mutex again. In a real application, this is only likely to occur
               inside a sub-function called by this task, as there is no
               practical reason to knowingly take the same mutex more than
               once. The calling task is already the mutex holder, so the
               second call to xSemaphoreTakeRecursive() does nothing more than
               increment the recursive call count to 2. */
            xSemaphoreTakeRecursive( xRecursiveMutex, xMaxBlock20ms );

            /* ... */

            /* The task returns the mutex after it has finished accessing the
               resource the mutex is protecting. At this point the recursive
               call count is 2, so the first call to xSemaphoreGiveRecursive()
               does not return the mutex. Instead, it simply decrements the
               recursive call count back to 1. */
            xSemaphoreGiveRecursive( xRecursiveMutex );

            /* The next call to xSemaphoreGiveRecursive() decrements the
               recursive call count to 0, so this time the recursive mutex is
               returned. */
            xSemaphoreGiveRecursive( xRecursiveMutex );

            /* Now one call to xSemaphoreGiveRecursive() has been executed for
               every proceeding call to xSemaphoreTakeRecursive(), so the task
               is no longer the mutex holder. */
        }
    }
}
```
***Listing 8.14*** *Creating and using a recursive mutex*



### 8.3.6 互斥锁和任务调度

如果两个优先级不同的任务使用相同的互斥锁，那么FreeRTOS调度策略会使任务的执行顺序明确；能够运行的最高优先级任务将被选为进入运行状态的任务。例如，如果一个高优先级任务处于阻塞状态以等待一个由低优先级任务持有的互斥锁，那么高优先级任务将在低优先级任务返回互斥锁后立即抢占低优先级任务。高优先级任务将成为互斥锁的持有者。这种情况已经在图8.5中看到。

然而，当任务具有相同优先级时，常常会错误地假设任务的执行顺序。如果任务1和任务2具有相同的优先级，并且任务1处于阻塞状态以等待一个由任务2持有的互斥锁，那么任务1不会在任务2“释放”互斥锁时抢占任务2。相反，任务2将保持在运行状态，任务1将从阻塞状态简单地移动到就绪状态。这种情况如图8.6所示，其中垂直线标记了时钟中断发生的时间。

<a name="fig8.6" title="图 8.6 当具有相同优先级的任务使用相同的互斥锁时的可能执行序列"></a>

* * *
![](media/image68.png)
***图 8.6*** *当具有相同优先级的任务使用相同的互斥锁时的可能执行序列*
* * *

在图 8.6 所示的场景中，FreeRTOS 调度器在互斥锁可用时并不会立即将任务 1 设置为运行状态，因为：

- 任务 1 和任务 2 具有相同的优先级，因此除非任务 2 进入阻塞状态，否则在下一个时钟中断之前（假设 `configUSE_TIME_SLICING` 在 FreeRTOSConfig.h 中设置为 1）不应切换到任务 1。
- 如果一个任务在紧密循环中使用互斥锁，并且每次任务“释放”互斥锁时都发生上下文切换，那么该任务将只能保持运行状态一段时间。如果两个或更多任务在紧密循环中使用相同的互斥锁，那么处理时间将被快速切换任务之间的开销浪费。

如果多个任务在紧密循环中使用互斥锁，并且这些任务具有相同的优先级，那么必须小心确保这些任务获得大约相等的处理时间。任务可能不会获得相等处理时间的原因如图 8.7 所示，该图展示了如果创建两个具有相同优先级的任务（如清单 8.15 所示），可能会发生的执行序列。

<a name="list8.15" title="Listing 8.15 A task that uses a mutex in a tight loop"></a>

```c
/* 一个在紧密循环中使用互斥锁的任务的实现。该任务在本地缓冲区中创建一个文本字符串，然后将字符串写入显示器。对显示器的访问由互斥锁保护。 */

void vATask( void *pvParameter )
{
    extern SemaphoreHandle_t xMutex;
    char cTextBuffer[ 128 ];

    for( ;; )
    {
        /* 生成文本字符串——这是一个快速操作。 */
        vGenerateTextInALocalBuffer( cTextBuffer );

        /* 获取保护对显示器访问的互斥锁。 */
        xSemaphoreTake( xMutex, portMAX_DELAY );

        /* 将生成的文本写入显示器——这是一个慢操作。 */
        vCopyTextToFrameBuffer( cTextBuffer );

        /* 文本已写入显示器，因此返回互斥锁。 */
        xSemaphoreGive( xMutex );
    }
}
```
***Listing 8.15*** *A task that uses a mutex in a tight loop*


Listing 8.15 的注释指出，创建字符串是一个快速操作，而更新显示器是一个慢操作。因此，由于在更新显示器时持有互斥锁，任务将在其大部分运行时间内持有互斥锁。

在图 8.7 中，垂直线标记了时钟中断发生的时间。

<a name="fig8.7" title="图 8.7 如果创建两个具有相同优先级的任务实例，则可能发生的执行序列，如清单 8.15 所示"></a>

* * *
![](media/image69.png)
***图 8.7*** *如果创建两个具有相同优先级的任务实例，则可能发生的执行序列，如清单 8.15 所示*
* * *

图 8.7 中的步骤 7 显示任务 1 重新进入阻塞状态——这发生在 `xSemaphoreTake()` API 函数内部。

图 8.7 说明任务 1 将被阻止获得互斥锁，直到时间片的开始与任务 2 不持有互斥锁的短时间段之一重合。

图 8.7 中所示的情况可以通过在调用 `xSemaphoreGive()` 之后添加对 `taskYIELD()` 的调用来避免。这在清单 8.16 中得到了演示，其中在任务持有互斥锁时，如果时钟计数发生变化，则调用 `taskYIELD()`。

<a name="list8.16" title="清单 8.16 确保在循环中使用互斥锁的任务获得更均等的处理时间，同时确保处理时间不会因任务切换过于频繁而浪费"></a>

```c
void vFunction( void *pvParameter )
{
    extern SemaphoreHandle_t xMutex;
    char cTextBuffer[ 128 ];
    TickType_t xTimeAtWhichMutexWasTaken;

    for( ;; )
    {
        /* 生成文本字符串——这是一个快速操作。 */
        vGenerateTextInALocalBuffer( cTextBuffer );

        /* 获取保护对显示器访问的互斥锁。 */
        xSemaphoreTake( xMutex, portMAX_DELAY );

        /* 记录获取互斥锁的时间。 */
        xTimeAtWhichMutexWasTaken = xTaskGetTickCount();

        /* 将生成的文本写入显示器——这是一个慢操作。 */
        vCopyTextToFrameBuffer( cTextBuffer );

        /* 文本已写入显示器，因此返回互斥锁。 */
        xSemaphoreGive( xMutex );

        /* 如果在每次迭代中调用taskYIELD()，那么这个任务将只在运行状态下保持短时间，
           处理时间将因任务之间快速切换而浪费。因此，只有在互斥锁被持有时刻计数发生变化时才调用taskYIELD()。 */
        if( xTaskGetTickCount() != xTimeAtWhichMutexWasTaken )
        {
            taskYIELD();
        }
    }
}
```
***清单 8.16*** *确保在循环中使用互斥锁的任务获得更均等的处理时间，同时确保处理时间不会因任务切换过于频繁而浪费*



## 8.4 门卫任务

门卫任务提供了一种实现互斥的干净方法，而不会冒着优先级反转或死锁的风险。

门卫任务是一个拥有资源的任务。只有门卫任务才被允许直接访问资源——任何其他需要访问资源的任务只能通过使用门卫的服务间接访问。

### 8.4.1 重写 `vPrintString()` 以使用门卫任务

示例 8.2 提供了另一种实现 `vPrintString()` 的替代方案。这次，使用门卫任务来管理对标准输出的访问。当一个任务想要将消息写入标准输出时，它不会直接调用打印函数，而是将消息发送给门卫。

门卫任务使用 FreeRTOS 队列来串行化对标准输出的访问。任务的内部实现不必考虑互斥，因为它是唯一被允许直接访问标准输出的任务。

门卫任务大部分时间都处于阻塞状态，等待队列中的消息到达。当消息到达时，门卫只需将消息写入标准输出，然后返回阻塞状态以等待下一条消息。门卫任务的实现如清单 8.18 所示。

中断可以发送到队列，因此中断服务例程也可以安全地使用门卫的服务将消息写入终端。在这个示例中，使用一个tick钩子函数每200个tick输出一条消息。

tick钩子（或tick回调）是一个在每个tick中断期间由内核调用的函数。要使用tick钩子函数：

1. 在FreeRTOSConfig.h中将`configUSE_TICK_HOOK`设置为1。

2. 提供钩子函数的实现，使用清单8.17中显示的精确函数名称和原型。

<a name="list8.17" title="清单8.17 tick钩子函数的名称和原型"></a>

```c
void vApplicationTickHook( void );
```
***清单8.17*** *tick钩子函数的名称和原型*

tick钩子函数在tick中断的上下文中执行，因此必须保持非常短，只使用适量的堆栈空间，并且不能调用不以'FromISR()'结尾的任何FreeRTOS API函数。

调度程序将始终在tick钩子函数之后立即执行，因此从tick钩子中调用的中断安全的FreeRTOS API函数不需要使用其`pxHigherPriorityTaskWoken`参数，并且可以将该参数设置为NULL。

<a name="list8.18" title="Listing 8.18 The gatekeeper task"></a>

```c
static void prvStdioGatekeeperTask( void *pvParameters )
{
    char *pcMessageToPrint;

    /* This is the only task that is allowed to write to standard out. Any
       other task wanting to write a string to the output does not access
       standard out directly, but instead sends the string to this task. As
       only this task accesses standard out there are no mutual exclusion or
       serialization issues to consider within the implementation of the task
       itself. */
    for( ;; )
    {
        /* Wait for a message to arrive. An indefinite block time is specified
           so there is no need to check the return value – the function will
           only return when a message has been successfully received. */
        xQueueReceive( xPrintQueue, &pcMessageToPrint, portMAX_DELAY );

        /* Output the received string. */
        printf( "%s", pcMessageToPrint );
        fflush( stdout );

        /* Loop back to wait for the next message. */
    }
}
```
***Listing 8.18*** *The gatekeeper task*

<a name="example8.2" title="Example 8.2 The alternative implementation for print task"></a>
---
***Example 8.2*** *The alternative implementation for print task*

---

The task that writes to the queue is shown in Listing 8.19. As before,
two separate instances of the task are created, and the string the task
writes to the queue is passed into the task using the task parameter.

<a name="list8.19" title="示例 8.2 的打印任务实现"></a>

```c
static void prvPrintTask( void *pvParameters )
{
    int iIndexToString;
    const TickType_t xMaxBlockTimeTicks = 0x20;

    /* 创建了两个此任务的实例。任务参数用于将数组中的字符串索引传递给任务。将其转换为所需的类型。 */
    iIndexToString = ( int ) pvParameters;

    for( ;; )
    {
        /* 不直接打印字符串，而是通过队列将字符串指针传递给守门任务。队列在调度器启动之前创建，因此在该任务首次执行时已经存在。未指定阻塞时间，因为队列中应该总是有空间。 */
        xQueueSendToBack( xPrintQueue, &( pcStringsToPrint[ iIndexToString ]), 0 );

        /* 等待一个伪随机时间。请注意，rand() 并不一定是可重入的，但在本例中这并不重要，因为代码不关心返回的值。在更安全的应用程序中，应该使用已知可重入的 rand() 版本，或者使用临界区保护对 rand() 的调用。 */
        vTaskDelay( ( rand() % xMaxBlockTimeTicks ) );
    }
}
```

***列表 8.19*** *示例 8.2 的打印任务实现*


时钟钩子函数计算其被调用的次数，每当计数达到 200 时，将其消息发送给守门任务。仅用于演示目的，时钟钩子写入队列的前端，任务写入队列的后端。时钟钩子的实现如列表 8.20 所示。

<a name="list8.20" title="Listing 8.20 The tick hook implementation"></a>

```c
void vApplicationTickHook( void )
{
    static int iCount = 0;

    /* Print out a message every 200 ticks. The message is not written out
       directly, but sent to the gatekeeper task. */
    iCount++;

    if( iCount >= 200 )
    {
        /* As xQueueSendToFrontFromISR() is being called from the tick hook, it
           is not necessary to use the xHigherPriorityTaskWoken parameter (the
           third parameter), and the parameter is set to NULL. */
        xQueueSendToFrontFromISR( xPrintQueue,
                                  &( pcStringsToPrint[ 2 ] ),
                                  NULL );

        /* Reset the count ready to print out the string again in 200 ticks
           time. */
        iCount = 0;
    }
}
```
***Listing 8.20*** *The tick hook implementation*


与往常一样，`main()` 创建了运行示例所需的队列和任务，然后启动调度程序。`main()` 的实现如清单 8.21 所示。

```c
/* 定义任务和中断通过门卫打印的字符串。 */
static char *pcStringsToPrint[] =
{
    "任务 1 ****************************************************\r\n",
    "任务 2 ----------------------------------------------------\r\n",
    "从时钟钩子中断打印的消息 ##############\r\n"
};

/*-----------------------------------------------------------*/

/* 声明一个QueueHandle_t类型的变量。队列用于从打印任务和时钟中断发送消息到门卫任务。 */
QueueHandle_t xPrintQueue;

/*-----------------------------------------------------------*/

int main( void )
{
    /* 在使用队列之前，必须显式创建它。队列被创建以容纳最多5个字符指针。 */
    xPrintQueue = xQueueCreate( 5, sizeof( char * ) );

    /* 检查队列是否成功创建。 */
    if( xPrintQueue != NULL )
    {
        /* 创建两个实例的任务，这些任务向门卫发送消息。任务使用的字符串的索引通过任务参数（xTaskCreate()的第4个参数）传递给任务。任务以不同的优先级创建，因此优先级较高的任务将偶尔抢占优先级较低的任务。 */
        xTaskCreate( prvPrintTask, "Print1", 1000, ( void * ) 0, 1, NULL );
        xTaskCreate( prvPrintTask, "Print2", 1000, ( void * ) 1, 2, NULL );

        /* 创建门卫任务。这是唯一一个被允许直接访问标准输出的任务。 */
        xTaskCreate( prvStdioGatekeeperTask, "Gatekeeper", 1000, NULL, 0, NULL );

        /* 启动调度程序，以便创建的任务开始执行。 */
        vTaskStartScheduler();
    }

    /* 如果一切正常，main()将永远不会到达这里，因为调度程序现在正在运行任务。如果main()到达这里，那么很可能是因为没有足够的堆内存来创建空闲任务。第3章提供了更多关于堆内存管理的信息。 */
    for( ;; );
}
```
<a name="list8.21" title="Listing 8.21 The implementation of main() for Example 8.2"></a>

***Listing 8.21*** *Example 8.2的main()实现*


执行示例8.2时产生的输出如图8.8所示。可以看到，来自任务的字符串和来自中断的字符串都正确打印出来，没有任何损坏。

<a name="fig8.8" title="图 8.8 执行示例 8.2 时生成的输出"></a>

* * *
![](media/image70.jpg)
***图 8.8*** *执行示例 8.2 时生成的输出*
* * *

门卫任务的优先级低于打印任务，因此发送给门卫的消息将保留在队列中，直到两个打印任务都处于阻塞状态。在某些情况下，将门卫的优先级设置得更高是合适的，这样消息可以立即处理，但这样做的代价是门卫会延迟优先级较低的任务，直到它完成访问受保护的资源。


