# 8 资源管理

## 8.1 章节介绍与范围

在多任务系统中，如果一个任务开始访问某个资源，但在其访问完成之前被切换出运行状态，则可能会发生错误。如果任务使资源处于不一致的状态，那么任何其他任务或中断对同一资源的访问都可能导致数据损坏或其他类似问题。

以下是一些示例：

* 访问外设

  考虑以下场景，其中两个任务尝试向液晶显示器（LCD）写入数据。

  1. 任务A执行并开始向LCD写入字符串"Hello world"。

  2. 任务A在仅输出字符串的开头部分"Hello w"后被任务B抢占。

  3. 任务B在进入阻塞状态之前向LCD写入"Abort, Retry, Fail?"。

  4. 任务A从被抢占的点继续执行，并完成输出其字符串的剩余字符"orld"。

LCD 现在显示损坏的字符串 "Hello wAbort, Retry, Fail?orld"。

* 读、修改、写操作

  清单 8.1 展示了一行 C 代码，以及该 C 代码通常会被翻译成的汇编代码示例。可以看到，PORTA 的值首先从内存中读取到寄存器中，在寄存器中进行修改，然后再写回内存。这被称为读、修改、写操作。

  <a name="list8.1" title="清单 8.1 一个读、修改、写序列的示例"></a>

  ```c
  /* 正在编译的 C 代码。 */
  PORTA |= 0x01;

  /* 编译 C 代码时生成的汇编代码。 */
  LOAD  R1,[#PORTA] ; 从 PORTA 读取值到 R1
  MOVE  R2,#0x01    ; 将绝对常量 1 移动到 R2
  OR    R1,R2       ; 将 R1 (PORTA) 与 R2 (常量 1) 进行按位或操作
  STORE R1,[#PORTA] ; 将新值存储回 PORTA
  ```
  ***清单 8.1*** *一个读、修改、写序列的示例*

  这是一种“非原子”操作，因为它需要多条指令才能完成，并且可能会被中断。考虑以下场景，其中两个任务尝试更新一个名为 PORTA 的内存映射寄存器。

1. 任务A将PORTA的值加载到寄存器中——这是操作的读取部分。

   2. 任务A在完成同一操作的修改和写入部分之前，被任务B抢占。

   3. 任务B更新PORTA的值，然后进入阻塞状态。

   4. 任务A从中断点继续执行。它修改了已经保存在寄存器中的PORTA值的副本，然后将更新后的值写回PORTA。

   在这种场景下，任务A更新并写回了一个过时的PORTA值。任务B在任务A获取PORTA值的副本之后，任务A将其修改后的值写回PORTA寄存器之前，修改了PORTA。当任务A写入PORTA时，它覆盖了任务B已经执行的修改，从而实际上破坏了PORTA寄存器的值。

   这个示例使用了外设寄存器，但在对变量执行读取、修改、写入操作时，同样的原则也适用。

- 非原子访问变量

  更新结构的多个成员，或更新大于体系结构自然字长的变量（例如，在16位机器上更新32位变量），都是非原子操作的例子。如果这些操作被中断，可能会导致数据丢失或损坏。

- 函数可重入性

  如果一个函数可以从多个任务中安全调用，或者同时从任务和中断中调用，那么该函数就是“可重入的”。可重入函数被称为“线程安全”的，因为它们可以从多个执行线程中访问，而不会有数据或逻辑操作损坏的风险。

  每个任务维护自己的栈和自己的处理器（硬件）寄存器值集。如果一个函数不访问栈上存储的数据或寄存器中保存的数据以外的任何数据，那么该函数就是可重入的，并且是线程安全的。清单8.2是一个可重入函数的例子。清单8.3是一个不可重入函数的例子。
如果应用程序使用 newlib C 库，则必须在 FreeRTOSConfig.h 中将 `configUSE_NEWLIB_REENTRANT` 设置为 1，以确保正确分配 newlib 所需的线程本地存储。

如果应用程序使用 picolibc C 库，则必须在 FreeRTOSConfig.h 中将 `configUSE_PICOLIBC_TLS` 设置为 1，以确保正确分配 picolibc 所需的线程本地存储。

如果应用程序使用其他 C 库并且需要线程本地存储（TLS），则必须在 FreeRTOSConfig.h 中将 `configUSE_C_RUNTIME_TLS_SUPPORT` 设置为 1，并实现以下宏：
- `configTLS_BLOCK_TYPE` - 每个任务的 TLS 块的类型。
- `configINIT_TLS_BLOCK` - 初始化每个任务的 TLS 块。
- `configSET_TLS_BLOCK` - 更新当前 TLS 块。在上下文切换期间调用，以确保使用正确的 TLS 块。
- `configDEINIT_TLS_BLOCK` - 释放 TLS 块。


<a name="list8.2" title="Listing 8.2 一个可重入函数的示例"></a>

```c
/* 一个参数被传递到函数中。这个参数要么通过栈传递，要么通过处理器寄存器传递。无论哪种方式都是安全的，因为每个调用该函数的任务或中断都维护自己的栈和寄存器值集，所以每个调用该函数的任务或中断都会有自己的 lVar1 副本。 */
long lAddOneHundred( long lVar1 )
{
    /* 这个函数作用域的变量也将分配到栈或寄存器中，具体取决于编译器和优化级别。每个调用此函数的任务或中断都会有自己的 lVar2 副本。 */
    long lVar2;

    lVar2 = lVar1 + 100;
    return lVar2;
}
```
***代码清单 8.2*** *一个可重入函数的示例*


<a name="list8.3" title="Listing 8.3 一个不可重入函数的示例"></a>

```c
/* 在这种情况下，lVar1 是一个全局变量，因此每个调用 lNonsenseFunction 的任务都会访问同一个变量的唯一副本。 */
long lVar1;

long lNonsenseFunction( void )
{
    /* lState 是静态的，因此不会分配到栈上。每个调用此函数的任务都会访问同一个变量的唯一副本。 */
    static long lState = 0;
    long lReturn;

    switch( lState )
    {
        case 0 : lReturn = lVar1 + 10;
                 lState = 1;
                 break;

        case 1 : lReturn = lVar1 + 20;
                 lState = 0;
                 break;
    }
}
```
***代码清单 8.3*** *一个不可重入函数的示例*



### 8.1.1 互斥锁

为了确保数据的一致性始终得以维持，必须使用“互斥锁”技术来管理对在任务之间共享或任务与中断之间共享的资源的访问。目标是确保，一旦某个任务开始访问一个不可重入且非线程安全的共享资源，该任务将独占该资源的访问权，直到资源恢复到一致状态。

FreeRTOS 提供了多种可用于实现互斥锁的功能，但最佳的互斥锁方法（在可能的情况下，尽管通常并不实际）是设计应用程序，使资源不被共享，并且每个资源仅由一个任务访问。

### 8.1.2 范围

本章节涵盖以下内容：

- 何时以及为什么需要进行资源管理和控制。
- 什么是临界区。
- 互斥锁的含义。
- 挂起调度器的含义。
- 如何使用互斥锁。
- 如何创建和使用看门人任务。
- 什么是优先级反转，以及优先级继承如何减少（但不能消除）其影响。


## 8.2 临界区与调度器挂起

### 8.2.1 基本临界区

基本临界区是指被`taskENTER_CRITICAL()`和`taskEXIT_CRITICAL()`宏调用包围的代码区域。临界区也被称为关键区域。

`taskENTER_CRITICAL()`和`taskEXIT_CRITICAL()`不接收任何参数，也不返回值[^23]。它们的使用如代码清单8.4所示。

[^23]: 类函数宏并不像真正的函数那样“返回值”。当将宏视为函数来理解最为简单时，本书会使用“返回值”这一术语来描述宏。


<a name="list8.4" title="代码清单 8.4 使用临界区保护对寄存器的访问"></a>

```c
/* 将PORTA寄存器的访问置于临界区内，以确保其不会被中断。进入临界区。 */
taskENTER_CRITICAL();

/* 在调用taskENTER_CRITICAL()和taskEXIT_CRITICAL()之间，不会发生任务切换。
   在允许中断嵌套的FreeRTOS端口上，中断仍然可以执行，但只有逻辑优先级高于
   configMAX_SYSCALL_INTERRUPT_PRIORITY常量值的中断——并且这些中断
   不允许调用FreeRTOS API函数。 */
PORTA |= 0x01;

/* 对PORTA的访问已完成，因此可以安全地退出临界区。 */
taskEXIT_CRITICAL();
```
***代码清单 8.4*** *使用临界区保护对寄存器的访问*


本书附带的示例项目使用了一个名为`vPrintString()`的函数将字符串写入标准输出，在使用FreeRTOS Windows端口时，标准输出是终端窗口。`vPrintString()`被许多不同任务调用；因此，理论上，其实现可以使用临界区来保护对标准输出的访问，如代码清单8.5所示。

<a name="list8.5" title="Listing 8.5 A possible implementation of vPrintString()"></a>

```c
void vPrintString( const char *pcString )
{
    /* 将字符串写入标准输出，使用临界区作为互斥的简单方法。 */
    taskENTER_CRITICAL();
    {
        printf( "%s", pcString );
        fflush( stdout );
    }
    taskEXIT_CRITICAL();
}
```
***清单 8.5*** *vPrintString() 的一种可能实现*

以这种方式实现的临界区是一种非常简单的互斥方法。它们通过禁用中断来工作，要么完全禁用，要么禁用到由 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 设置的中断优先级，具体取决于所使用的 FreeRTOS 移植版本。抢占式上下文切换只能从中断内部发生，因此，只要中断保持禁用状态，调用 `taskENTER_CRITICAL()` 的任务将保证保持在运行状态，直到退出临界区。

基本临界区必须保持非常短，否则它们会对中断响应时间产生不利影响。每次调用 `taskENTER_CRITICAL()` 都必须与调用 `taskEXIT_CRITICAL()` 紧密配对。因此，标准输出（stdout，即计算机写入其输出数据的流）不应使用临界区进行保护（如清单 8.5 所示），因为写入终端可能是一个相对较长的操作。本章中的示例探讨了替代解决方案。

临界区可以安全地嵌套，因为内核会记录嵌套深度。只有当嵌套深度恢复到零时，即每次调用`taskENTER_CRITICAL()`后都相应执行了一次`taskEXIT_CRITICAL()`，临界区才会退出。

调用`taskENTER_CRITICAL()`和`taskEXIT_CRITICAL()`是任务修改运行FreeRTOS的处理器中断使能状态的唯一合法方式。通过其他任何方式修改中断使能状态都会使宏的嵌套计数无效。

`taskENTER_CRITICAL()`和`taskEXIT_CRITICAL()`不以'FromISR'结尾，因此不能从中断服务例程中调用。`taskENTER_CRITICAL_FROM_ISR()`是`taskENTER_CRITICAL()`的中断安全版本，`taskEXIT_CRITICAL_FROM_ISR()`是`taskEXIT_CRITICAL()`的中断安全版本。这些中断安全版本仅适用于允许中断嵌套的FreeRTOS移植版本——在不允许中断嵌套的移植版本中，它们将变得多余。

`taskENTER_CRITICAL_FROM_ISR()` 返回一个值，该值必须传递给匹配的 `taskEXIT_CRITICAL_FROM_ISR()` 调用。这在下述代码清单 8.6 中进行了演示。


<a name="list8.6" title="代码清单 8.6 在中断服务例程中使用临界区"></a>

```c
void vAnInterruptServiceRoutine( void )
{
    /* 声明一个变量，用于保存 taskENTER_CRITICAL_FROM_ISR() 的返回值。 */
    UBaseType_t uxSavedInterruptStatus;

    /* ISR 的这一部分可以被任何更高优先级的中断打断。 */

    /* 使用 taskENTER_CRITICAL_FROM_ISR() 保护 ISR 的这一区域。
       保存 taskENTER_CRITICAL_FROM_ISR() 的返回值，以便可以传递给匹配的
       taskEXIT_CRITICAL_FROM_ISR() 调用。 */
    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();

    /* ISR 的这一部分位于 taskENTER_CRITICAL_FROM_ISR() 和 
       taskEXIT_CRITICAL_FROM_ISR() 调用之间，因此只能被优先级高于
       configMAX_SYSCALL_INTERRUPT_PRIORITY 常量设置值的中断打断。 */

    /* 通过调用 taskEXIT_CRITICAL_FROM_ISR() 再次退出临界区，
       并传入匹配的 taskENTER_CRITICAL_FROM_ISR() 调用返回的值。 */
    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

    /* ISR 的这一部分可以被任何更高优先级的中断打断。 */
}
```
***代码清单 8.6*** *在中断服务例程中使用临界区*


如果执行进入和退出临界区的代码所花费的处理时间比实际被临界区保护的代码还要多，这是不合理的。基本的临界区进入和退出都非常快，并且始终是确定性的，这使得它们在保护非常短的代码区域时非常理想。

### 8.2.2 挂起（或锁定）调度器

通过挂起调度器也可以创建临界区。挂起调度器有时也被称为“锁定”调度器。

基本的临界区保护一段代码不被其他任务和中断访问，而通过挂起调度器实现的临界区只保护一段代码不被其他任务访问，因为中断仍然处于启用状态。

对于因过长而无法通过简单禁用中断来实现的临界区，可以通过挂起调度器来实现。然而，在调度器挂起期间的中断活动可能会使恢复（或“解除挂起”）调度器的操作变得相对较长，因此必须考虑在每种情况下使用哪种方法最为合适。

### 8.2.3 vTaskSuspendAll() API 函数

<a name="list8.7" title="Listing 8.7 The vTaskSuspendAll() API function prototype"></a>

```c
void vTaskSuspendAll( void );
```
***清单 8.7*** *vTaskSuspendAll() API 函数原型*

通过调用 `vTaskSuspendAll()` 可以挂起调度器。挂起调度器会阻止上下文切换的发生，但会保持中断启用。如果调度器挂起期间有中断请求上下文切换，则该请求将被挂起，只有在调度器恢复（解除挂起）时才会执行。

在调度器挂起期间，不得调用 FreeRTOS API 函数。


### 8.2.4 xTaskResumeAll() API 函数


<a name="list8.8" title="Listing 8.8 The xTaskResumeAll() API function prototype"></a>

```c
BaseType_t xTaskResumeAll( void );
```
***代码清单 8.8*** *xTaskResumeAll() API 函数原型*


通过调用 `xTaskResumeAll()` 可以恢复（取消挂起）调度器。

**xTaskResumeAll() 返回值**

- 返回值

  在调度器被挂起期间请求的上下文切换会被挂起，只有在调度器恢复时才会执行。如果在 `xTaskResumeAll()` 返回前执行了挂起的上下文切换，则返回 `pdTRUE`，否则返回 `pdFALSE`。

由于内核会记录嵌套深度，因此嵌套调用 `vTaskSuspendAll()` 和 `xTaskResumeAll()` 是安全的。调度器只有在嵌套深度恢复到零时才会被恢复——即每次调用 `vTaskSuspendAll()` 后都对应执行一次 `xTaskResumeAll()` 调用时。

代码清单 8.9 展示了 `vPrintString()` 的实际实现，该函数通过挂起调度器来保护对终端输出的访问。


<a name="list8.9" title="Listing 8.9 The implementation of vPrintString()"></a>

```c
void vPrintString( const char *pcString )
{
    /* 将字符串写入 stdout，通过挂起调度器作为互斥方法。 */
    vTaskSuspendScheduler();
    {
        printf( "%s", pcString );
        fflush( stdout );
    }
    xTaskResumeScheduler();
}
```
***代码清单 8.9*** *vPrintString() 的实现*


## 8.3 互斥锁（与二值信号量）

互斥锁（Mutex）是一种特殊的二值信号量，用于控制两个或多个任务对共享资源的访问。MUTEX一词源于"MUTual EXclusion"（互斥）。在FreeRTOSConfig.h中，必须将`configUSE_MUTEXES`设置为1，才能使互斥锁可用。

在互斥场景中使用时，可以将互斥锁视为与共享资源相关联的令牌。任务要合法地访问资源，必须首先成功“获取”令牌（成为令牌持有者）。当令牌持有者使用完资源后，必须“归还”令牌。只有当令牌被归还后，其他任务才能成功获取令牌，并安全地访问相同的共享资源。任务不允许访问共享资源，除非它持有令牌。这一机制如图8.1所示。

尽管互斥锁和二值信号量具有许多共同特性，但图8.1中所示的场景（使用互斥锁实现互斥）与图7.6中所示的场景（使用二值信号量实现同步）完全不同。主要区别在于信号量被获取后的处理方式：

- 用于互斥的信号量必须始终被归还。
- 用于同步的信号量通常被丢弃而不归还。

<a name="fig8.1" title="图8.1 使用互斥锁实现的互斥"></a>

* * *
![](media/image63.png)   
***图8.1*** *使用互斥锁实现的互斥*
* * *

该机制完全依赖于应用程序编写者的规范。任务在任何时候都可以访问资源，但每个任务“约定”不会这样做，除非它能够成为互斥锁的持有者。


### 8.3.1 xSemaphoreCreateMutex() API 函数

FreeRTOS 还包含 `xSemaphoreCreateMutexStatic()` 函数，该函数在编译时静态分配创建互斥锁所需的内存：互斥锁是信号量的一种。所有不同类型的 FreeRTOS 信号量的句柄都存储在 `SemaphoreHandle_t` 类型的变量中。

在使用互斥锁之前，必须先创建它。要创建互斥锁类型的信号量，请使用 `xSemaphoreCreateMutex()` API 函数。

<a name="list8.10" title="Listing 8.10 The xSemaphoreCreateMutex() API function prototype"></a>

```c
SemaphoreHandle_t xSemaphoreCreateMutex( void );
```
***清单 8.10*** *xSemaphoreCreateMutex() API 函数原型*


**xSemaphoreCreateMutex() 返回值**

- 返回值

  如果返回 NULL，则表示无法创建互斥锁，因为 FreeRTOS 没有足够的堆内存来分配互斥锁数据结构。第 3 章提供了有关堆内存管理的更多信息。

  返回非 NULL 值表示互斥锁已成功创建。返回的值应存储为所创建互斥锁的句柄。

<a name="example8.1" title="Example 8.1 Rewriting vPrintString() to use a semaphore"></a>
---
***示例 8.1*** *重写 vPrintString() 以使用信号量*

---

本示例创建了一个新版本的 `vPrintString()`，名为 `prvNewPrintString()`，然后从多个任务中调用该新函数。`prvNewPrintString()` 在功能上与 `vPrintString()` 完全相同，但使用互斥量而不是通过锁定调度器来控制对标准输出的访问。`prvNewPrintString()` 的实现如代码清单 8.11 所示。


<a name="list8.11" title="Listing 8.11 The implementation of prvNewPrintString()"></a>

```c
static void prvNewPrintString( const char *pcString )
{
    /* 互斥量在调度器启动之前创建，因此在该任务执行时已经存在。

       尝试获取互斥量，如果互斥量不能立即获得，则无限期阻塞等待。xSemaphoreTake() 
       的调用只有在成功获取互斥量后才会返回，因此不需要检查函数返回值。如果使用了
       其他任何延迟时间，则代码必须检查 xSemaphoreTake() 是否返回 pdTRUE，然后
       才能访问共享资源（在本例中是标准输出）。如本书前面提到的，无限期超时不
       建议用于生产代码。 */
    xSemaphoreTake( xMutex, portMAX_DELAY );
    {
        /* 以下代码只有在成功获取互斥量后才会执行。现在可以自由访问标准输出，因为
           同一时间只有一个任务能持有互斥量。 */
        printf( "%s", pcString );
        fflush( stdout );

        /* 必须归还互斥量！ */
    }
    xSemaphoreGive( xMutex );
}
```
***代码清单 8.11*** *prvNewPrintString() 的实现*


`prvNewPrintString()` 由 `prvPrintTask()` 实现的两个任务实例重复调用。每次调用之间使用随机延迟时间。任务参数用于将唯一的字符串传递给每个任务实例。`prvPrintTask()` 的实现如代码清单 8.12 所示。

<a name="list8.12" title="清单 8.12 示例 8.1 中 prvPrintTask() 的实现"></a>

```c
static void prvPrintTask( void *pvParameters )
{
    char *pcStringToPrint;
    const TickType_t xMaxBlockTimeTicks = 0x20;

    /* 创建了两个此任务的实例。任务打印的字符串通过任务的参数传递进来。
       参数被强制转换为所需的类型。 */
    pcStringToPrint = ( char * ) pvParameters;

    for( ;; )
    {
        /* 使用新定义的函数打印字符串。 */
        prvNewPrintString( pcStringToPrint );

        /* 等待一个伪随机时间。注意 rand() 不一定是可重入的，
           但在这种情况下并不重要，因为代码并不关心返回的值。
           在更安全的应用程序中，应使用已知可重入的 rand() 版本，
           或者应使用临界区保护对 rand() 的调用。 */
        vTaskDelay( ( rand() % xMaxBlockTimeTicks ) );
    }
}
```
***清单 8.12*** *示例 8.1 中 prvPrintTask() 的实现*

通常，`main()` 只是创建互斥锁、创建任务，然后启动调度器。其实现如清单 8.13 所示。

`prvPrintTask()`的两个实例以不同的优先级创建，因此优先级较低的任务有时会被优先级较高的任务抢占。由于使用了互斥锁来确保每个任务都能互斥地访问终端，即使在发生抢占时，显示的字符串也总是正确的，且不会被破坏。通过减小任务在阻塞状态中停留的最长时间（由常量`xMaxBlockTimeTicks`设置），可以增加抢占的频率。

以下是在FreeRTOS Windows移植版本中使用示例8.1时的注意事项：

- 调用`printf()`会生成一个Windows系统调用。Windows系统调用不受FreeRTOS控制，可能会引入不稳定性。

- Windows系统调用的执行方式意味着即使没有使用互斥锁，也很少会看到字符串被破坏的情况。


<a name="list8.13" title="Listing 8.13 The implementation of main() for Example 8.1"></a>

```c
int main( void )
{
    /* 在使用信号量之前，必须显式创建它。在本示例中，创建了一个互斥锁类型的信号量。 */
    xMutex = xSemaphoreCreateMutex();

    /* 在创建任务之前，检查信号量是否成功创建。 */
    if( xMutex != NULL )
    {
        /* 创建两个写入stdout的任务实例。它们写入的字符串作为任务参数传递给任务。
           任务以不同的优先级创建，因此会发生一些抢占。 */
        xTaskCreate( prvPrintTask, "Print1", 1000,
                     "Task 1 ***************************************\r\n",
                     1, NULL );

        xTaskCreate( prvPrintTask, "Print2", 1000,
                     "Task 2 ---------------------------------------\r\n", 
                     2, NULL );

        /* 启动调度器，以便创建的任务开始执行。 */
        vTaskStartScheduler();
    }

    /* 如果一切正常，main()将永远不会到达这里，因为调度器现在正在运行任务。
       如果main()确实到达这里，那么很可能是因为没有足够的堆内存来创建空闲任务。
       第3章提供了关于堆内存管理的更多信息。 */
    for( ;; );
}
```
***清单8.13*** *示例8.1中main()的实现*


执行示例8.1时产生的输出如图8.2所示。图8.3描述了一个可能的执行序列。

<a name="fig8.2" title="Figure 8.2 The output produced when Example 8.1 is executed"></a>

* * *
![](media/image64.jpg)   
***图 8.2*** *执行示例 8.1 时产生的输出*
* * *

图 8.2 显示，正如预期的那样，终端上显示的字符串没有出现损坏。随机顺序是任务使用的随机延迟时间的结果。


<a name="fig8.3" title="Figure 8.3 A possible sequence of execution for Example 8.1"></a>

* * *
![](media/image65.png)   
***图 8.3*** *示例 8.1 的一个可能执行顺序*
* * *



### 8.3.2 优先级反转

图 8.3 展示了使用互斥锁提供互斥时的一个潜在问题。图中描述的执行顺序显示，高优先级的任务 2 必须等待低优先级的任务 1 释放互斥锁的控制权。这种高优先级任务被低优先级任务延迟的现象被称为“优先级反转”。如果在高优先级任务等待信号量时，一个中等优先级的任务开始执行，这种不良行为将进一步加剧——结果将导致高优先级任务等待低优先级任务，而低优先级任务甚至无法执行。这种情况通常被称为 _无界优先级反转_，因为中等优先级的任务可能会无限期地阻塞低优先级和高优先级的任务。
这种最坏的情况如图 8.4 所示。


<a name="fig8.4" title="Figure 8.4 A worst case priority inversion scenario"></a>

* * *
![](media/image66.png)   
***图 8.4*** *一个最坏的优先级反转场景*
* * *

优先级反转可能是一个严重的问题，但在小型嵌入式系统中，通常可以通过在系统设计时考虑资源的访问方式来避免这一问题。


### 8.3.3 优先级继承

FreeRTOS中的互斥锁和二进制信号量非常相似——区别在于互斥锁包含一个基本的“优先级继承”机制，而二进制信号量则没有。优先级继承是一种方案，旨在最小化优先级反转的负面影响。它并不能“修复”优先级反转，而是通过确保反转总是有时间限制来减轻其影响。然而，优先级继承使系统时序分析变得复杂，依赖它来确保系统正确运行并不是一种好的实践。

优先级继承的工作原理是临时将互斥锁持有者的优先级提升到试图获取同一互斥锁的最高优先级任务的优先级。持有互斥锁的低优先级任务“继承”了等待该互斥锁任务的优先级。这一点如图8.5所示。当互斥锁持有者归还互斥锁时，其优先级会自动重置为原始值。


<a name="fig8.5" title="图8.5 优先级继承最小化优先级反转的影响"></a>

* * *
![](media/image67.png)   
***图8.5*** *优先级继承最小化优先级反转的影响*
* * *

正如刚才所见，优先级继承功能会影响使用互斥锁的任务的优先级。因此，互斥锁不能在中断服务例程中使用。

FreeRTOS实现了一个基本的优先级继承机制，该机制在设计时考虑了优化空间和执行周期。完整的优先级继承机制需要更多的数据和处理器周期来确定任何时刻继承的优先级，尤其是在任务同时持有多个互斥锁的情况下。

优先级继承机制需要记住的特定行为：
* 如果一个任务在未先释放已持有的互斥锁的情况下获取另一个互斥锁，其继承的优先级可能会进一步提升。
* 任务将保持其最高继承优先级，直到它释放了所有持有的互斥锁。这与互斥锁的释放顺序无关。
* 如果任务持有多个互斥锁，无论等待任何持有互斥锁的任务是否完成等待（超时），任务都将保持最高继承优先级。


### 8.3.4 死锁（或致命拥抱）

“死锁”是使用互斥锁进行互斥的另一个潜在问题。死锁有时也被称为更具戏剧性的名称“致命拥抱”。

当两个任务因彼此持有对方所需的资源而无法继续执行时，就会发生死锁。考虑以下场景，其中任务A和任务B都需要获取互斥锁X*和*互斥锁Y才能执行操作：

1. 任务A执行并成功获取互斥锁X。

2. 任务A被任务B抢占。

3. 任务B成功获取互斥锁Y，然后尝试获取互斥锁X——但互斥锁X被任务A持有，因此任务B无法获取。任务B选择进入阻塞状态，等待互斥锁X被释放。

4. 任务A继续执行。它尝试获取互斥锁Y——但互斥锁Y被任务B持有，因此任务A无法获取。任务A选择进入阻塞状态，等待互斥锁Y被释放。

在此场景结束时，任务A正在等待任务B持有的互斥锁，而任务B正在等待任务A持有的互斥锁。由于两个任务都无法继续执行，因此发生了死锁。

与优先级反转一样，避免死锁的最佳方法是在设计时考虑其可能性，并设计系统以确保死锁不会发生。特别是，正如本书前面所述，任务无限期地等待（没有超时）获取互斥锁通常是不良做法。相反，应使用一个比预期等待互斥锁的最长时间稍长的超时时间——如果在该时间内无法获取互斥锁，则可能是设计错误的征兆，这可能是死锁。

在实践中，死锁在小型嵌入式系统中并不是一个大问题，因为系统设计者可以很好地理解整个应用程序，从而识别并消除可能发生死锁的区域。


### 8.3.5 递归互斥锁

任务也有可能与自身发生死锁。这种情况会发生在任务试图多次获取同一个互斥锁，而没有先释放该互斥锁时。考虑以下场景：

1. 任务成功获取了一个互斥锁。

2. 在持有该互斥锁时，任务调用了一个库函数。

3. 库函数的实现尝试获取相同的互斥锁，并进入阻塞状态，等待互斥锁变为可用。

在此场景结束时，任务处于阻塞状态，等待互斥锁被释放，但任务本身已经是该互斥锁的持有者。由于任务处于阻塞状态等待自身，因此发生了死锁。

这种类型的死锁可以通过使用递归互斥锁来避免。递归互斥锁可以被同一个任务多次获取，并且只有在每次调用`take`递归互斥锁后都执行一次`give`递归互斥锁时，互斥锁才会被释放。

标准互斥锁和递归互斥锁的创建和使用方式类似：

- 标准互斥锁使用`xSemaphoreCreateMutex()`创建。递归互斥锁使用`xSemaphoreCreateRecursiveMutex()`创建。这两个API函数具有相同的原型。

- 标准互斥锁使用`xSemaphoreTake()`获取。递归互斥锁使用`xSemaphoreTakeRecursive()`获取。这两个API函数具有相同的原型。

- 标准互斥锁使用`xSemaphoreGive()`释放。递归互斥锁使用`xSemaphoreGiveRecursive()`释放。这两个API函数具有相同的原型。

代码清单8.14展示了如何创建和使用递归互斥锁。


<a name="list8.14" title="Listing 8.14 Creating and using a recursive mutex"></a>

```c
/* 递归互斥锁是SemaphoreHandle_t类型的变量。 */
SemaphoreHandle_t xRecursiveMutex;

/* 创建并使用递归互斥锁的任务实现。 */
void vTaskFunction( void *pvParameters )
{
    const TickType_t xMaxBlock20ms = pdMS_TO_TICKS( 20 );

    /* 在使用递归互斥锁之前，必须显式创建它。 */
    xRecursiveMutex = xSemaphoreCreateRecursiveMutex();

    /* 检查信号量是否成功创建。configASSERT()在11.2节中描述。 */
    configASSERT( xRecursiveMutex );

    /* 与大多数任务一样，此任务实现为一个无限循环。 */
    for( ;; )
    {
        /* ... */

        /* 获取递归互斥锁。 */
        if( xSemaphoreTakeRecursive( xRecursiveMutex, xMaxBlock20ms ) == pdPASS )
        {
            /* 递归互斥锁成功获取。任务现在可以访问互斥锁保护的资源。此时递归调用计数（即嵌套调用xSemaphoreTakeRecursive()的次数）为1，因为递归互斥锁只被获取了一次。 */

            /* 在已经持有递归互斥锁的情况下，任务再次获取互斥锁。在实际应用中，这种情况很可能发生在此任务调用的子函数中，因为没有实际理由明知故犯地多次获取同一个互斥锁。调用任务已经是互斥锁的持有者，因此第二次调用xSemaphoreTakeRecursive()只会将递归调用计数增加到2。 */
            xSemaphoreTakeRecursive( xRecursiveMutex, xMaxBlock20ms );

            /* ... */

            /* 任务在完成访问互斥锁保护的资源后释放互斥锁。此时递归调用计数为2，因此第一次调用xSemaphoreGiveRecursive()不会释放互斥锁。相反，它只是将递归调用计数减回到1。 */
            xSemaphoreGiveRecursive( xRecursiveMutex );

            /* 下一次调用xSemaphoreGiveRecursive()将递归调用计数减到0，因此这次递归互斥锁被释放。 */
            xSemaphoreGiveRecursive( xRecursiveMutex );

            /* 现在，每次调用xSemaphoreTakeRecursive()后都执行了一次xSemaphoreGiveRecursive()，因此任务不再是互斥锁的持有者。 */
        }
    }
}
```
***代码清单 8.14*** *创建和使用递归互斥锁*


### 8.3.6 互斥锁与任务调度

如果两个不同优先级的任务使用同一个互斥锁，那么 FreeRTOS 的调度策略会明确任务的执行顺序；能够运行的最高优先级任务将被选为进入运行状态的任务。例如，如果高优先级任务处于阻塞状态以等待由低优先级任务持有的互斥锁，那么一旦低优先级任务释放互斥锁，高优先级任务将抢占低优先级任务。随后，高优先级任务将成为互斥锁的持有者。这一场景已在图 8.5 中展示。

然而，当任务具有相同优先级时，人们对任务执行顺序的假设常常是错误的。如果任务 1 和任务 2 具有相同的优先级，并且任务 1 处于阻塞状态以等待由任务 2 持有的互斥锁，那么当任务 2 释放互斥锁时，任务 1 不会抢占任务 2。相反，任务 2 将继续保持运行状态，而任务 1 只会从阻塞状态转为就绪状态。这一场景如图 8.6 所示，其中的垂直线标记了滴答中断发生的时间点。

<a name="fig8.6" title="图 8.6 当具有相同优先级的任务使用同一个互斥锁时可能的执行顺序"></a>

* * *
![](media/image68.png)   
***图 8.6*** *当具有相同优先级的任务使用同一个互斥锁时可能的执行顺序*
* * *

在图 8.6 所示的场景中，FreeRTOS 调度器并没有在互斥锁可用时立即将任务 1 切换为运行状态，原因如下：

- 任务 1 和任务 2 具有相同的优先级，因此除非任务 2 进入阻塞状态，否则不会切换到任务 1，直到下一个 tick 中断（假设 FreeRTOSConfig.h 中的 `configUSE_TIME_SLICING` 设置为 1）。

- 如果一个任务在紧密循环中使用互斥锁，并且每次任务“释放”互斥锁时都发生上下文切换，那么该任务只能在运行状态下停留很短的时间。如果两个或更多任务在紧密循环中使用同一个互斥锁，那么快速切换任务会浪费处理时间。

如果有多个任务在紧密循环中使用同一个互斥锁，并且这些任务具有相同的优先级，则必须注意确保这些任务获得大致相等的处理时间。图 8.7 演示了任务可能无法获得相等处理时间的原因，该图展示了如果以相同优先级创建两个清单 8.15 所示任务的实例时可能发生的执行顺序。

<a name="list8.15" title="代码清单 8.15 在紧凑循环中使用互斥锁的任务"></a>

```c
/* 这是一个在紧凑循环中使用互斥锁的任务实现。该任务在本地缓冲区中创建文本字符串，
   然后将字符串写入显示器。访问显示器时使用互斥锁进行保护。 */

void vATask( void *pvParameter )
{
    extern SemaphoreHandle_t xMutex;
    char cTextBuffer[ 128 ];

    for( ;; )
    {
        /* 生成文本字符串——这是一个快速操作。 */
        vGenerateTextInALocalBuffer( cTextBuffer );

        /* 获取保护显示器访问的互斥锁。 */
        xSemaphoreTake( xMutex, portMAX_DELAY );

        /* 将生成的文本写入显示器——这是一个慢速操作。 */
        vCopyTextToFrameBuffer( cTextBuffer );

        /* 文本已写入显示器，因此释放互斥锁。 */
        xSemaphoreGive( xMutex );
    }
}
```
***代码清单 8.15*** *在紧凑循环中使用互斥锁的任务*


代码清单 8.15 中的注释指出，创建字符串是一个快速操作，而更新显示器是一个慢速操作。因此，由于在更新显示器时持有互斥锁，该任务将在其大部分运行时间内持有互斥锁。

在图8.7中，垂直线标记了发生tick中断的时间点。


<a name="fig8.7" title="图8.7 如果以相同优先级创建两个由列表8.15所示任务的实例，则可能发生的执行顺序"></a>

* * *
![](media/image69.png)   
***图8.7*** *如果以相同优先级创建两个由列表8.15所示任务的实例，则可能发生的执行顺序*
* * *

图8.7中的步骤7显示任务1重新进入阻塞状态——这发生在`xSemaphoreTake()` API函数内部。

图8.7表明，任务1将无法获取互斥锁，直到某个时间片的开始与任务2不持有互斥锁的短暂时期重合。

图8.7所示的场景可以通过在`xSemaphoreGive()`调用后添加`taskYIELD()`调用来避免。这在列表8.16中得到了演示，其中如果任务持有互斥锁时tick计数发生了变化，则会调用`taskYIELD()`。

<a name="list8.16" title="Listing 8.16 确保在循环中使用互斥量的任务获得更均等的处理时间..."></a>

```c
void vFunction( void *pvParameter )
{
    extern SemaphoreHandle_t xMutex;
    char cTextBuffer[ 128 ];
    TickType_t xTimeAtWhichMutexWasTaken;

    for( ;; )
    {
        /* 生成文本字符串——这是一个快速操作。 */
        vGenerateTextInALocalBuffer( cTextBuffer );

        /* 获取保护显示访问的互斥量。 */
        xSemaphoreTake( xMutex, portMAX_DELAY );

        /* 记录获取互斥量的时间。 */
        xTimeAtWhichMutexWasTaken = xTaskGetTickCount();

        /* 将生成的文本写入显示——这是一个慢速操作。 */
        vCopyTextToFrameBuffer( cTextBuffer );

        /* 文本已写入显示，因此释放互斥量。 */
        xSemaphoreGive( xMutex );

        /* 如果在每次迭代中都调用taskYIELD()，那么该任务将只能在Running状态下保持很短的时间，
           并且由于任务之间的快速切换，处理时间将被浪费。因此，仅在持有互斥量期间
           的滴答计数发生变化时调用taskYIELD()。 */
        if( xTaskGetTickCount() != xTimeAtWhichMutexWasTaken )
        {
            taskYIELD();
        }
    }
}
```
***代码清单 8.16*** *确保在循环中使用互斥量的任务获得更均等的处理时间，同时确保不会因任务切换过于频繁而浪费处理时间*



## 8.4 看门人任务

看门人任务提供了一种干净的方法来实现互斥，而不会出现优先级反转或死锁的风险。

看门人任务是一个独占资源所有权的任务。只有看门人任务被允许直接访问资源——任何其他需要访问资源的任务只能通过使用看门人任务的服务间接访问资源。

### 8.4.1 重写 `vPrintString()` 以使用看门人任务

示例 8.2 提供了 `vPrintString()` 的另一种替代实现。这次，使用了一个看门人任务来管理对标准输出的访问。当一个任务想要向标准输出写入消息时，它不会直接调用打印函数，而是将消息发送给看门人。

看门人任务使用 FreeRTOS 队列来序列化对标准输出的访问。任务的内部实现不需要考虑互斥，因为它是唯一被允许直接访问标准输出的任务。

看门人任务大部分时间处于阻塞状态，等待队列中的消息到达。当消息到达时，看门人任务只需将消息写入标准输出，然后返回到阻塞状态等待下一条消息。看门人任务的实现如清单 8.18 所示。

## 中断与队列

中断可以向队列发送数据，因此中断服务例程也可以安全地使用“守门员”服务将消息写入终端。在本示例中，使用了一个Tick钩子函数来每200个Tick输出一条消息。

Tick钩子（或Tick回调）是由内核在每个Tick中断期间调用的函数。要使用Tick钩子函数：

1. 在FreeRTOSConfig.h中将`configUSE_TICK_HOOK`设置为1。

2. 提供钩子函数的实现，使用如代码清单8.17所示的精确函数名称和原型。

<a name="list8.17" title="代码清单8.17 Tick钩子函数的名称和原型"></a>

```c
void vApplicationTickHook( void );
```
***代码清单8.17*** *Tick钩子函数的名称和原型*

Tick钩子函数在Tick中断的上下文中执行，因此必须非常简短，只能使用适量的栈空间，并且不能调用任何不以'FromISR()'结尾的FreeRTOS API函数。

调度器总是在Tick钩子函数之后立即执行，因此从Tick钩子调用的中断安全FreeRTOS API函数不需要使用`pxHigherPriorityTaskWoken`参数，该参数可以设置为NULL。

<a name="list8.18" title="Listing 8.18 The gatekeeper task"></a>

```c
static void prvStdioGatekeeperTask( void *pvParameters )
{
    char *pcMessageToPrint;

    /* 这是唯一被允许向标准输出写入数据的任务。任何其他任务想要向输出写入字符串时，
       不会直接访问标准输出，而是将字符串发送给此任务。由于只有此任务访问标准输出，
       因此在任务本身的实现中无需考虑互斥或序列化问题。 */
    for( ;; )
    {
        /* 等待消息到达。指定了无限阻塞时间，因此无需检查返回值——该函数
           只有在成功接收到消息时才会返回。 */
        xQueueReceive( xPrintQueue, &pcMessageToPrint, portMAX_DELAY );

        /* 输出接收到的字符串。 */
        printf( "%s", pcMessageToPrint );
        fflush( stdout );

        /* 循环等待下一条消息。 */
    }
}
```
***代码清单 8.18*** *看门狗任务*


<a name="example8.2" title="Example 8.2 The alternative implementation for print task"></a>
---
***示例 8.2*** *打印任务的替代实现*

---

向队列写入数据的任务如代码清单 8.19 所示。和之前一样，创建了两个独立的任务实例，
任务写入队列的字符串通过任务参数传递给任务。

<a name="list8.19" title="示例8.2的打印任务实现"></a>


```c
static void prvPrintTask( void *pvParameters )
{
    int iIndexToString;
    const TickType_t xMaxBlockTimeTicks = 0x20;

    /* 此任务创建了两个实例。任务参数用于将字符串数组的索引传递给任务。
       将其转换为所需的类型。 */
    iIndexToString = ( int ) pvParameters;

    for( ;; )
    {
        /* 通过队列将字符串的指针传递给门卫任务来打印字符串，而不是直接打印。
           队列在调度器启动之前创建，因此在此任务首次执行时已经存在。
           由于队列中应该始终有空间，因此未指定阻塞时间。 */
        xQueueSendToBack( xPrintQueue, &( pcStringsToPrint[ iIndexToString ]), 0 );

        /* 等待一个伪随机时间。注意，rand()不一定是可重入的，
           但在这种情况下并不重要，因为代码不关心返回的值。
           在更安全的应用程序中，应使用已知可重入的rand()版本，
           或者应使用临界区保护对rand()的调用。 */
        vTaskDelay( ( rand() % xMaxBlockTimeTicks ) );
    }
}
```

***清单8.19*** *示例8.2的打印任务实现*


tick钩子函数统计其被调用的次数，每当计数达到200时，将其消息发送给门卫任务。仅用于演示目的，tick钩子写入队列的前端，而任务写入队列的后端。tick钩子的实现如清单8.20所示。

<a name="list8.20" title="清单 8.20 tick钩子函数的实现"></a>

```c
void vApplicationTickHook( void )
{
    static int iCount = 0;

    /* 每200个tick打印一次消息。消息不直接输出，而是发送给看门人任务。 */
    iCount++;

    if( iCount >= 200 )
    {
        /* 由于xQueueSendToFrontFromISR()是从tick钩子函数中调用的，
           因此不需要使用xHigherPriorityTaskWoken参数（第三个参数），
           该参数设置为NULL。 */
        xQueueSendToFrontFromISR( xPrintQueue, 
                                  &( pcStringsToPrint[ 2 ] ), 
                                  NULL );

        /* 重置计数，准备在200个tick后再次打印字符串。 */
        iCount = 0;
    }
}
```
***清单 8.20*** *tick钩子函数的实现*

通常情况下，`main()`函数会创建运行示例所需的队列和任务，然后启动调度器。`main()`函数的实现如清单8.21所示。

```c
/* 定义任务和中断将通过门卫任务打印的字符串。 */
static char *pcStringsToPrint[] =
{
    "Task 1 ****************************************************\r\n",
    "Task 2 ----------------------------------------------------\r\n",
    "Message printed from the tick hook interrupt ##############\r\n"
};

/*-----------------------------------------------------------*/

/* 声明一个类型为 QueueHandle_t 的变量。该队列用于从打印任务和tick中断向门卫任务发送消息。 */
QueueHandle_t xPrintQueue;

/*-----------------------------------------------------------*/

int main( void )
{
    /* 在使用队列之前必须显式创建它。该队列最多可容纳5个字符指针。 */
    xPrintQueue = xQueueCreate( 5, sizeof( char * ) );

    /* 检查队列是否成功创建。 */
    if( xPrintQueue != NULL )
    {
        /* 创建两个向门卫任务发送消息的任务实例。任务使用的字符串索引通过任务参数（xTaskCreate()的第四个参数）传递给任务。这些任务以不同的优先级创建，因此较高优先级的任务会偶尔抢占较低优先级的任务。 */
        xTaskCreate( prvPrintTask, "Print1", 1000, ( void * ) 0, 1, NULL );
        xTaskCreate( prvPrintTask, "Print2", 1000, ( void * ) 1, 2, NULL );

        /* 创建门卫任务。这是唯一允许直接访问标准输出的任务。 */
        xTaskCreate( prvStdioGatekeeperTask, "Gatekeeper", 1000, NULL, 0, NULL );

        /* 启动调度器，使创建的任务开始执行。 */
        vTaskStartScheduler();
    }

    /* 如果一切正常，main() 将永远不会到达这里，因为调度器现在正在运行任务。如果 main() 确实到达了这里，那么很可能是堆内存不足，无法创建空闲任务。第3章提供了关于堆内存管理的更多信息。 */
    for( ;; );
}
```
<a name="list8.21" title="Listing 8.21 The implementation of main() for Example 8.2"></a>

***清单 8.21*** *示例 8.2 中 main() 函数的实现*

示例 8.2 执行时产生的输出如图 8.8 所示。可以看出，来自任务的字符串和来自中断的字符串都正确打印，没有出现任何损坏。

<a name="fig8.8" title="图 8.8 示例 8.2 执行时产生的输出"></a>

* * *
![](media/image70.jpg)   
***图 8.8*** *示例 8.2 执行时产生的输出*
* * *

看门狗任务的优先级被设置为低于打印任务——因此发送给看门狗的消息会一直保留在队列中，直到两个打印任务都进入阻塞状态。在某些情况下，为看门狗分配更高的优先级是合适的，这样消息可以立即得到处理——但这样做会以看门狗延迟低优先级任务为代价，直到它完成对受保护资源的访问。


