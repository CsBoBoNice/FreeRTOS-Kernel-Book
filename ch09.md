# 9 事件组

## 9.1 本章介绍与范围

如前所述，实时嵌入式系统需要根据事件采取相应的动作。前几章已经介绍了FreeRTOS中用于将事件传递给任务的功能特性，例如信号量和队列，它们都具有以下特性：

- 允许任务在阻塞状态中等待单个事件的发生。
- 当事件发生时，解除单个任务的阻塞状态。被解除阻塞的任务是等待该事件的最高优先级任务。

事件组是FreeRTOS中另一种用于将事件传递给任务的功能。与队列和信号量不同：

- 事件组允许任务在阻塞状态中等待一个或多个事件的组合发生。
- 当事件发生时，事件组会解除所有等待相同事件或事件组合的任务的阻塞状态。

事件组的这些独特特性使其在以下场景中非常有用：
- 同步多个任务
- 向多个任务广播事件
- 允许任务在阻塞状态中等待一组事件中的任意一个发生
- 允许任务在阻塞状态中等待多个动作完成

事件组还提供了减少应用程序RAM使用的可能性，因为通常可以用单个事件组替换多个二进制信号量。

事件组功能是可选的。若要包含事件组功能，请将FreeRTOS源文件`event_groups.c`作为项目的一部分进行构建。


### 9.1.1 范围

本章旨在让读者深入了解以下内容：

- 事件组的实际用途。
- 事件组相对于其他 FreeRTOS 功能的优势和劣势。
- 如何在事件组中设置位。
- 如何在阻塞状态下等待事件组中的位被设置。
- 如何使用事件组来同步一组任务。

## 9.2 事件组的特性

### 9.2.1 事件组、事件标志和事件位

事件“标志”是一个布尔值（1 或 0），用于指示某个事件是否发生。事件“组”是一组事件标志。

事件标志只能是 1 或 0，因此可以将事件标志的状态存储在一个单独的位中，而事件组中所有事件标志的状态可以存储在一个单独的变量中；事件组中每个事件标志的状态由 `EventBits_t` 类型的变量中的一个位表示。因此，事件标志也被称为事件“位”。如果 `EventBits_t` 变量中的某个位被设置为 1，则表示该位所代表的事件已经发生。如果 `EventBits_t` 变量中的某个位被设置为 0，则表示该位所代表的事件尚未发生。

图 9.1 展示了如何将各个事件标志映射到 `EventBits_t` 类型变量中的各个位。


<a name="fig9.1" title="图 9.1 事件标志到 EventBits\_t 类型变量中位编号的映射"></a>

* * *
![](media/image71.png)
***图 9.1*** *事件标志到 EventBits\_t 类型变量中位编号的映射*
* * *

例如，如果事件组的值为 0x92（二进制 1001 0010），则只有事件位 1、4 和 7 被设置，因此只有由位 1、4 和 7 表示的事件已经发生。图 9.2 展示了一个 `EventBits_t` 类型的变量，其中事件位 1、4 和 7 被设置，而所有其他事件位被清除，使事件组的值为 0x92。


<a name="fig9.2" title="图 9.2 一个事件组，其中只有位 1、4 和 7 被设置，其他所有事件标志被清除，使事件组的值为 0x92"></a>

* * *
![](media/image72.png)
***图 9.2*** *一个事件组，其中只有位 1、4 和 7 被设置，其他所有事件标志被清除，使事件组的值为 0x92*
* * *

应用程序开发者需要为事件组中的各个位赋予具体的含义。例如，应用程序开发者可以创建一个事件组，然后：

- 定义事件组中的位 0 表示“已从网络接收到消息”。
- 定义事件组中的位 1 表示“有消息准备好发送到网络”。
- 定义事件组中的位 2 表示“中止当前的网络连接”。


### 9.2.2 深入理解 EventBits\_t 数据类型

事件组中的事件位数量取决于 FreeRTOSConfig.h 中的编译时配置常量 `configTICK_TYPE_WIDTH_IN_BITS`[^24]：

[^24]: `configTICK_TYPE_WIDTH_IN_BITS` 用于配置保存 RTOS 节拍计数的类型，因此看似与事件组功能无关。它对 `EventBits_t` 类型的影响是 FreeRTOS 内部实现的结果。虽然将 `configTICK_TYPE_WIDTH_IN_BITS` 设置为 `TICK_TYPE_WIDTH_16_BITS` 是理想的选择，但这应仅在 FreeRTOS 运行于能够比 32 位类型更高效处理 16 位类型的架构上时进行。

- 如果 `configTICK_TYPE_WIDTH_IN_BITS` 为 `TICK_TYPE_WIDTH_16_BITS`，则每个事件组包含 8 个可用事件位。

- 如果 `configTICK_TYPE_WIDTH_IN_BITS` 为 `TICK_TYPE_WIDTH_32_BITS`，则每个事件组包含 24 个可用事件位。

- 如果 `configTICK_TYPE_WIDTH_IN_BITS` 为 `TICK_TYPE_WIDTH_64_BITS`，则每个事件组包含 56 个可用事件位。


### 9.2.3 多任务访问

事件组是独立的对象，可以被任何知道其存在的任务或中断服务例程（ISR）访问。任何数量的任务都可以在同一个事件组中设置位，任何数量的任务也可以从同一个事件组中读取位。

### 9.2.4 使用事件组的实际示例

FreeRTOS+TCP TCP/IP 协议栈的实现提供了一个实际示例，展示了如何使用事件组来同时简化设计并最小化资源使用。

TCP 套接字必须响应许多不同的事件。事件的示例包括接受事件、绑定事件、读取事件和关闭事件。套接字在任何给定时间可能接收到的事件取决于套接字的状态。例如，如果套接字已创建但尚未绑定到地址，那么它可以预期接收到绑定事件，但不会预期接收到读取事件（如果它没有地址，则无法读取数据）。

FreeRTOS+TCP 套接字的状态保存在一个名为 `FreeRTOS_Socket_t` 的结构中。该结构包含一个事件组，其中为套接字必须处理的每个事件定义了一个事件位。FreeRTOS+TCP API 调用在等待一个事件或一组事件时，只需在该事件组上阻塞。

事件组还包含一个“中止”位，允许在任何时候中止 TCP 连接，无论套接字当时正在等待哪个事件。


## 9.3 使用事件组进行事件管理

### 9.3.1 xEventGroupCreate() API 函数

FreeRTOS 还包含 `xEventGroupCreateStatic()` 函数，该函数在编译时静态分配创建事件组所需的内存：必须显式创建事件组后才能使用。

事件组使用类型为 `EventGroupHandle_t` 的变量进行引用。`xEventGroupCreate()` API 函数用于创建事件组，并返回一个 `EventGroupHandle_t` 以引用所创建的事件组。

<a name="list9.1" title="Listing 9.1 The xEventGroupCreate() API function prototype"></a>

```c
EventGroupHandle_t xEventGroupCreate( void );
```
***代码清单 9.1*** *xEventGroupCreate() API 函数原型*


**xEventGroupCreate() 返回值**

- 返回值

  如果返回 NULL，则表示无法创建事件组，因为 FreeRTOS 没有足够的堆内存来分配事件组数据结构。第 3 章提供了有关堆内存管理的更多信息。

  返回非 NULL 值表示事件组已成功创建。返回值应存储为所创建事件组的句柄。


### 9.3.2 xEventGroupSetBits() API 函数

`xEventGroupSetBits()` API 函数用于设置事件组中的一个或多个位，通常用于通知任务，表示被设置的位所代表的事件已经发生。

> *注意：切勿在中断服务例程中调用 `xEventGroupSetBits()`。应使用其中断安全版本 `xEventGroupSetBitsFromISR()` 代替。*


<a name="list9.2" title="Listing 9.2. The xEventGroupSetBits() API function prototype"></a>

```c
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,

const EventBits_t uxBitsToSet );
```
***代码清单 9.2*** *xEventGroupSetBits() API 函数原型*


**xEventGroupSetBits() 参数和返回值**

- `xEventGroup`

  要设置位的事件组的句柄。该事件组句柄由用于创建事件组的 `xEventGroupCreate()` 调用返回。

- `uxBitsToSet`

  一个位掩码，指定要在事件组中设置为 1 的事件位。事件组的值通过将事件组的现有值与 `uxBitsToSet` 传入的值进行按位或操作来更新。

  例如，将 `uxBitsToSet` 设置为 0x04（二进制 0100）将导致事件组中的事件位 3 被设置（如果尚未设置），而事件组中的其他事件位保持不变。

- 返回值

  调用 `xEventGroupSetBits()` 返回时事件组的值。请注意，返回的值不一定设置了 `uxBitsToSet` 指定的位，因为这些位可能已被其他任务再次清除。


### 9.3.3 xEventGroupSetBitsFromISR() API 函数

`xEventGroupSetBitsFromISR()` 是 `xEventGroupSetBits()` 的中断安全版本。

释放信号量是一个确定性的操作，因为可以提前知道释放信号量最多会导致一个任务离开阻塞状态。而在事件组中设置位时，无法提前知道有多少任务会离开阻塞状态，因此在事件组中设置位并不是一个确定性操作。

FreeRTOS 的设计和实现标准不允许在中断服务例程中或在中断被禁用时执行非确定性操作。因此，`xEventGroupSetBitsFromISR()` 不会直接在中断服务例程中设置事件位，而是将该操作推迟到 RTOS 守护任务中执行。


<a name="list9.3" title="Listing 9.3 The xEventGroupSetBitsFromISR() API function prototype"></a>

```c
BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup,
                                      const EventBits_t uxBitsToSet,
                                      BaseType_t *pxHigherPriorityTaskWoken );
```
***清单 9.3*** *xEventGroupSetBitsFromISR() API 函数原型*


**xEventGroupSetBitsFromISR() 参数和返回值**

- `xEventGroup`

  正在设置位的事件组的句柄。事件组句柄是通过调用 `xEventGroupCreate()` 创建事件组时返回的。

- `uxBitsToSet`

  一个位掩码，用于指定要设置为 1 的事件位。事件组的值通过将事件组的现有值与 `uxBitsToSet` 传入的值进行按位或运算来更新。

  例如，将 `uxBitsToSet` 设置为 0x05（二进制 0101）将导致事件组中的事件位 2 和事件位 0 被设置（如果它们尚未被设置），而事件组中的所有其他事件位保持不变。

- `pxHigherPriorityTaskWoken`

  `xEventGroupSetBitsFromISR()` 不会直接在中断服务例程中设置事件位，而是通过向定时器命令队列发送命令，将该操作推迟到 RTOS 守护任务中执行。如果守护任务处于阻塞状态以等待定时器命令队列中的数据变得可用，那么向定时器命令队列写入数据将导致守护任务离开阻塞状态。如果守护任务的优先级高于当前正在执行的任务（被中断的任务）的优先级，那么 `xEventGroupSetBitsFromISR()` 会在内部将 `*pxHigherPriorityTaskWoken` 设置为 `pdTRUE`。

  如果 `xEventGroupSetBitsFromISR()` 将此值设置为 `pdTRUE`，则应在退出中断之前执行上下文切换。这将确保中断直接返回到守护任务，因为守护任务将是处于就绪状态的最高优先级任务。

- 返回值

  有两种可能的返回值：

  - 只有当数据成功发送到定时器命令队列时，才会返回 `pdPASS`。

  - 如果由于队列已满而无法将“设置位”命令写入定时器命令队列，则会返回 `pdFALSE`。


### 9.3.4 xEventGroupWaitBits() API 函数

`xEventGroupWaitBits()` API 函数允许任务读取事件组的值，并可选择在阻塞状态中等待事件组中的一个或多个事件位被置位（如果这些事件位尚未被置位）。

<a name="list9.4" title="Listing 9.4 The xEventGroupWaitBits() API function prototype"></a>

```c
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait );
```
***代码清单 9.4*** *xEventGroupWaitBits() API 函数原型*

调度器用于确定任务是否进入阻塞状态以及何时从阻塞状态退出的条件被称为“解除阻塞条件”。解除阻塞条件由 `uxBitsToWaitFor` 和 `xWaitForAllBits` 参数值的组合指定：

- `uxBitsToWaitFor` 指定要测试的事件组中的事件位
- `xWaitForAllBits` 指定是使用按位 OR 测试还是按位 AND 测试

如果任务在调用 `xEventGroupWaitBits()` 时满足其解除阻塞条件，则不会进入阻塞状态。

[待翻译内容开始]


可能导致任务进入阻塞状态或退出阻塞状态的条件示例如表6所示。
表6仅展示了事件组和`uxBitsToWaitFor`值的低四位二进制位——这两个值的其他位均假定为零。

<a name="tbl6" title="表6 uxBitsToWaitFor和xWaitForAllBits参数的影响"></a>

* * *
| 现有事件组值 | uxBitsToWaitFor值 | xWaitForAllBits值 | 结果行为 |
| -------------------------- | --------------------- | --------------------- | ------------------ |
| 0000 | 0101 | pdFALSE | 调用任务将进入阻塞状态，因为事件组中位0和位2均未置位，当事件组中位0或位2被置位时，任务将退出阻塞状态。 |
| 0100 | 0101 | pdTRUE | 调用任务将进入阻塞状态，因为事件组中位0和位2未同时置位，当事件组中位0和位2均被置位时，任务将退出阻塞状态。 |
| 0100 | 0110 | pdFALSE | 调用任务不会进入阻塞状态，因为`xWaitForAllBits`为`pdFALSE`，且`uxBitsToWaitFor`指定的两位中已有一位在事件组中置位。 |
| 0100 | 0110 | pdTRUE | 调用任务将进入阻塞状态，因为`xWaitForAllBits`为`pdTRUE`，且`uxBitsToWaitFor`指定的两位中仅有一位在事件组中置位。当事件组中位1和位2均被置位时，任务将退出阻塞状态。 |

***表6*** *uxBitsToWaitFor和xWaitForAllBits参数的影响*
* * *

调用任务通过`uxBitsToWaitFor`参数指定要测试的位，且调用任务很可能需要在满足解除阻塞条件后将这些位清零。可以使用`xEventGroupClearBits()` API函数清除事件位，但在以下情况下手动使用该函数清除事件位会导致应用程序代码中的竞态条件：

- 多个任务使用同一个事件组。
- 事件组中的位由其他任务或中断服务例程置位。

[待翻译内容结束]

`xClearOnExit` 参数用于避免这些潜在的竞争条件。如果 `xClearOnExit` 设置为 `pdTRUE`，那么事件位的测试和清除对调用任务来说将是一个原子操作（不会被其他任务或中断打断）。

**xEventGroupWaitBits() 参数和返回值**

- `xEventGroup`

  包含待读取事件位的事件组的句柄。该事件组句柄由创建事件组的 `xEventGroupCreate()` 调用返回。

- `uxBitsToWaitFor`

  一个位掩码，用于指定在事件组中要测试的事件位或多个事件位。

  例如，如果调用任务希望等待事件位 0 和/或事件位 2 在事件组中被置位，则将 `uxBitsToWaitFor` 设置为 0x05（二进制 0101）。更多示例请参见表 6。

- `xClearOnExit`

  如果调用任务的解除阻塞条件已满足，并且 `xClearOnExit` 设置为 `pdTRUE`，则在调用任务退出 `xEventGroupWaitBits()` API 函数之前，`uxBitsToWaitFor` 指定的事件位将在事件组中被清除为 0。

如果 `xClearOnExit` 设置为 `pdFALSE`，则事件组中的事件位状态不会被 `xEventGroupWaitBits()` API 函数修改。

- `xWaitForAllBits`

  `uxBitsToWaitFor` 参数指定要在事件组中测试的事件位。`xWaitForAllBits` 指定调用任务是否应在 `uxBitsToWaitFor` 参数指定的一个或多个事件位被设置时从阻塞状态移除，还是仅在 `uxBitsToWaitFor` 参数指定的所有事件位被设置时才从阻塞状态移除。

  如果 `xWaitForAllBits` 设置为 `pdFALSE`，则进入阻塞状态以等待其解除阻塞条件满足的任务将在 `uxBitsToWaitFor` 指定的任何位被设置时（或由 `xTicksToWait` 参数指定的超时时间到期时）离开阻塞状态。

  如果 `xWaitForAllBits` 设置为 `pdTRUE`，则进入阻塞状态以等待其解除阻塞条件满足的任务仅在 `uxBitsToWaitFor` 指定的所有位被设置时（或由 `xTicksToWait` 参数指定的超时时间到期时）才会离开阻塞状态。

请参考表6中的示例。

- `xTicksToWait`

  任务在阻塞状态下等待其解除阻塞条件被满足的最长时间。

  如果`xTicksToWait`为零，或者在调用`xEventGroupWaitBits()`时解除阻塞条件已满足，`xEventGroupWaitBits()`将立即返回。

  阻塞时间以滴答周期为单位指定，因此它所代表的绝对时间取决于滴答频率。可以使用宏`pdMS_TO_TICKS()`将指定的毫秒时间转换为滴答时间。

  将`xTicksToWait`设置为`portMAX_DELAY`将导致任务无限期等待（不会超时），前提是在FreeRTOSConfig.h中将`INCLUDE_vTaskSuspend`设置为1。

- 返回值

  如果`xEventGroupWaitBits()`因调用任务的解除阻塞条件被满足而返回，则返回值是调用任务的解除阻塞条件被满足时事件组的值（如果在`xClearOnExit`为`pdTRUE`的情况下，任何位在被自动清除之前）。在这种情况下，返回值也将满足解除阻塞条件。

如果`xEventGroupWaitBits()`函数返回是因为`xTicksToWait`参数指定的阻塞时间已到期，那么返回值是阻塞时间到期时事件组的值。在这种情况下，返回值将不满足解除阻塞的条件。

### 9.3.5 xEventGroupGetStaticBuffer() API 函数

`xEventGroupGetStaticBuffer()` API 函数提供了一种方法来获取指向静态创建的事件组缓冲区的指针。该缓冲区与创建事件组时提供的缓冲区相同。

*注意：切勿从中断服务例程调用`xEventGroupGetStaticBuffer()`。*


<a name="list9.5" title="Listing 9.5 The xEventGroupGetStaticBuffer() API function prototype"></a>

```c
BaseType_t xEventGroupGetStaticBuffer( EventGroupHandle_t xEventGroup,

StaticEventGroup_t ** ppxEventGroupBuffer );
```
***Listing 9.5*** *xEventGroupGetStaticBuffer() API 函数原型*


**xEventGroupGetStaticBuffer() 参数和返回值**

- `xEventGroup`

  要检索缓冲区的事件组。该事件组必须由`xEventGroupCreateStatic()`创建。

- `ppxEventGroupBuffer`

  用于返回指向事件组数据结构缓冲区的指针。该缓冲区与创建时提供的缓冲区相同。

- 返回值

  有两种可能的返回值：

  - 如果成功获取缓冲区，则返回 `pdTRUE`。

  - 如果未能成功获取缓冲区，则返回 `pdFALSE`。

<a name="example9.1" title="示例 9.1 事件组实验"></a>
---
***示例 9.1*** *事件组实验*

---

本示例演示了如何：

- 创建事件组。
- 在中断服务例程中设置事件组的位。
- 在任务中设置事件组的位。
- 在事件组上阻塞。

通过首先将 `xEventGroupWaitBits()` 的 `xWaitForAllBits` 参数设置为 `pdFALSE` 执行示例，然后将其设置为 `pdTRUE` 执行示例，展示了 `xWaitForAllBits` 参数的效果。

事件位 0 和事件位 1 在任务中设置，事件位 2 在中断服务例程中设置。通过使用清单 9.6 中的 \#define 语句，为这三个位赋予了描述性名称。

<a name="list9.6" title="Listing 9.6 Event bit definitions used in Example 9.1"></a>

```c
/* 事件组中事件位的定义。 */
#define mainFIRST_TASK_BIT ( 1UL << 0UL )  /* 事件位 0，由任务设置 */
#define mainSECOND_TASK_BIT ( 1UL << 1UL ) /* 事件位 1，由任务设置 */
#define mainISR_BIT ( 1UL << 2UL )         /* 事件位 2，由中断服务例程设置 */
```
***清单 9.6*** *示例 9.1 中使用的事件位定义*


清单 9.7 展示了设置事件位 0 和事件位 1 的任务的实现。该任务位于一个循环中，反复设置一个事件位，然后设置另一个事件位，每次调用 `xEventGroupSetBits()` 之间有 200 毫秒的延迟。在设置每个事件位之前，会打印一条字符串，以便在控制台中查看执行顺序。


<a name="list9.7" title="Listing 9.7 The task that sets two bits in the event group in Example 9.1"></a>

```c
static void vEventBitSettingTask( void *pvParameters )
{
    const TickType_t xDelay200ms = pdMS_TO_TICKS( 200UL );

    for( ;; )
    {
        /* 在开始下一个循环之前延迟一小段时间。 */
        vTaskDelay( xDelay200ms );

        /* 打印一条消息，表示任务即将设置事件位 0，然后设置事件位 0。 */
        vPrintString( "Bit setting task -\t about to set bit 0.\r\n" );
        xEventGroupSetBits( xEventGroup, mainFIRST_TASK_BIT );

        /* 在设置另一个事件位之前延迟一小段时间。 */
        vTaskDelay( xDelay200ms );

        /* 打印一条消息，表示任务即将设置事件位 1，然后设置事件位 1。 */
        vPrintString( "Bit setting task -\t about to set bit 1.\r\n" );
        xEventGroupSetBits( xEventGroup, mainSECOND_TASK_BIT );
    }
}
```
***清单 9.7*** *示例 9.1 中设置事件组中两个事件位的任务*


清单 9.8 展示了设置事件组中事件位 2 的中断服务例程的实现。同样，在设置事件位之前会打印一条字符串，以便在控制台中查看执行顺序。然而，在这种情况下，由于不应直接在中断服务例程中执行控制台输出，因此使用 `xTimerPendFunctionCallFromISR()` 在 RTOS 守护任务的上下文中执行输出。

如前文示例所示，中断服务例程由一个简单的周期性任务触发，该任务强制产生一个软件中断。在本例中，中断每500毫秒生成一次。


<a name="list9.8" title="Listing 9.8 The ISR that sets bit 2 in the event group in Example 9.1"></a>

```c
static uint32_t ulEventBitSettingISR( void )
{
    /* 字符串不会在中断服务例程中打印，而是发送到RTOS守护任务进行打印。
       因此将其声明为静态，以确保编译器不会将字符串分配在ISR的栈上，
       因为在守护任务中打印字符串时，ISR的栈帧将不复存在。 */
    static const char *pcString = "Bit setting ISR -\t about to set bit 2.\r\n";
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    /* 打印一条消息，表示即将设置bit 2。消息无法在ISR中打印，
       因此将实际输出延迟到RTOS守护任务的上下文中执行，通过挂起一个函数调用。 */
    xTimerPendFunctionCallFromISR( vPrintStringFromDaemonTask,
                                   ( void * ) pcString,
                                   0,
                                   &xHigherPriorityTaskWoken );

    /* 在事件组中设置bit 2。 */
    xEventGroupSetBitsFromISR( xEventGroup,
                               mainISR_BIT,
                               &xHigherPriorityTaskWoken );

    /* xTimerPendFunctionCallFromISR()和xEventGroupSetBitsFromISR()都会
       写入定时器命令队列，并且都使用了相同的xHigherPriorityTaskWoken变量。
       如果写入定时器命令队列导致RTOS守护任务离开阻塞状态，并且
       如果RTOS守护任务的优先级高于当前执行任务（被此中断中断的任务）的优先级，
       那么xHigherPriorityTaskWoken将被设置为pdTRUE。

       xHigherPriorityTaskWoken用作portYIELD_FROM_ISR()的参数。
       如果xHigherPriorityTaskWoken等于pdTRUE，则调用portYIELD_FROM_ISR()
       将请求上下文切换。如果xHigherPriorityTaskWoken仍为pdFALSE，
       则调用portYIELD_FROM_ISR()将不起作用。

       Windows移植版本使用的portYIELD_FROM_ISR()实现包含一个return语句，
       因此此函数未显式返回值。 */

    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***清单9.8*** *在示例9.1中设置事件组bit 2的ISR*


清单9.9展示了调用`xEventGroupWaitBits()`以在事件组上阻塞的任务的实现。该任务会为事件组中设置的每个bit打印一条字符串。

`xEventGroupWaitBits()`的`xClearOnExit`参数被设置为`pdTRUE`，因此导致`xEventGroupWaitBits()`返回的事件位将在`xEventGroupWaitBits()`返回之前被自动清除。

<a name="list9.9" title="Listing 9.9 The task that blocks to wait for event bits to become set in Example 9.1"></a>

```c
static void vEventBitReadingTask( void *pvParameters )
{
    EventBits_t xEventGroupValue;
    const EventBits_t xBitsToWaitFor = ( mainFIRST_TASK_BIT  |
                                         mainSECOND_TASK_BIT |
                                         mainISR_BIT );

    for( ;; )
    {
        /* 阻塞等待事件组中的事件位被设置。 */
        xEventGroupValue = xEventGroupWaitBits( /* 要读取的事件组 */
                                                xEventGroup,

                                                /* 要测试的位 */
                                                xBitsToWaitFor,

                                                /* 如果满足解除阻塞条件，则在退出时清除位 */
                                                pdTRUE,

                                                /* 不需要等待所有位。第二次执行时将此参数设置为pdTRUE。 */
                                                pdFALSE,

                                                /* 不超时。 */
                                                portMAX_DELAY );

        /* 为每个被设置的位打印消息。 */
        if( ( xEventGroupValue & mainFIRST_TASK_BIT ) != 0 )
        {
            vPrintString( "Bit reading task -\t 事件位 0 被设置\r\n" );
        }

        if( ( xEventGroupValue & mainSECOND_TASK_BIT ) != 0 )
        {
            vPrintString( "Bit reading task -\t 事件位 1 被设置\r\n" );
        }

        if( ( xEventGroupValue & mainISR_BIT ) != 0 )
        {
            vPrintString( "Bit reading task -\t 事件位 2 被设置\r\n" );
        }
    }
}
```
***代码清单 9.9*** *在示例 9.1 中阻塞等待事件位被设置的任务*

`main()`函数在启动调度器之前创建事件组和任务。其实现参见代码清单 9.10。读取事件组的任务的优先级高于写入事件组的任务的优先级，确保每次读取任务的解除阻塞条件满足时，读取任务都会抢占写入任务。

<a name="list9.10" title="清单 9.10 在示例 9.1 中创建事件组和任务"></a>

```c
int main( void )
{
    /* 在使用事件组之前，必须先创建它。 */
    xEventGroup = xEventGroupCreate();

    /* 创建用于设置事件组中事件位的任务。 */
    xTaskCreate( vEventBitSettingTask, "Bit Setter", 1000, NULL, 1, NULL );

    /* 创建用于等待事件组中事件位被设置的任务。 */
    xTaskCreate( vEventBitReadingTask, "Bit Reader", 1000, NULL, 2, NULL );

    /* 创建用于定期生成软件中断的任务。 */
    xTaskCreate( vInterruptGenerator, "Int Gen", 1000, NULL, 3, NULL );

    /* 安装软件中断的处理程序。执行此操作的语法取决于使用的 FreeRTOS 移植版本。
       这里显示的语法只能用于 FreeRTOS Windows 移植版本，其中此类中断是模拟的。 */
    vPortSetInterruptHandler( mainINTERRUPT_NUMBER, ulEventBitSettingISR );

    /* 启动调度器，使创建的任务开始执行。 */
    vTaskStartScheduler();

    /* 以下代码行永远不应被执行到。 */
    for( ;; );
    return 0;
}
```
***清单 9.10*** *在示例 9.1 中创建事件组和任务*

当示例 9.1 被执行时，`xEventGroupWaitBits()` 的 `xWaitForAllBits` 参数设置为 `pdFALSE` 时产生的输出如图 9.3 所示。在图 9.3 中可以看到，由于调用 `xEventGroupWaitBits()` 时的 `xWaitForAllBits` 参数设置为 `pdFALSE`，因此从事件组读取任务在每次任何事件位被设置时都会立即退出阻塞状态并执行。

<a name="fig9.3" title="Figure 9.3 当示例 9.1 以 xWaitForAllBits 设置为 pdFALSE 执行时产生的输出"></a>

* * *
![](media/image73.jpg)
***图 9.3*** *当示例 9.1 以 xWaitForAllBits 设置为 pdFALSE 执行时产生的输出*
* * *

当示例 9.1 以 `xEventGroupWaitBits()` 函数的 `xWaitForAllBits` 参数设置为 `pdTRUE` 执行时产生的输出如图 9.4 所示。在图 9.4 中可以看到，由于 `xWaitForAllBits` 参数被设置为 `pdTRUE`，读取事件组的任务仅在所有三个事件位都被设置后才离开阻塞状态。


<a name="fig9.4" title="Figure 9.4 当示例 9.1 以 xWaitForAllBits 设置为 pdTRUE 执行时产生的输出"></a>

* * *
![](media/image74.jpg)
***图 9.4*** *当示例 9.1 以 xWaitForAllBits 设置为 pdTRUE 执行时产生的输出*
* * *



## 9.4 使用事件组进行任务同步

有时，应用程序的设计要求两个或多个任务彼此同步。例如，考虑这样一种设计：任务 A 接收到一个事件，然后将事件所需的部分处理工作委托给其他三个任务：任务 B、任务 C 和任务 D。如果任务 A 在任务 B、任务 C 和任务 D 都完成对前一个事件的处理之前无法接收另一个事件，那么这四个任务需要彼此同步。每个任务的同步点是在该任务完成其处理后，并且在其他每个任务也完成处理之前无法继续执行。任务 A 只有在所有四个任务都达到同步点后才能接收另一个事件。

一个不那么抽象的例子可以在 FreeRTOS+TCP 的某个演示项目中找到，这种任务同步的需求得到了体现。该演示在两个任务之间共享一个 TCP 套接字；一个任务向套接字发送数据，另一个任务从同一个套接字接收数据[^25]。在确保另一个任务不会再次尝试访问套接字之前，任何任务都不安全地关闭 TCP 套接字。如果两个任务中的任何一个希望关闭套接字，那么它必须通知另一个任务其意图，然后等待另一个任务停止使用套接字后再继续。希望关闭套接字的是向套接字发送数据的任务，这一场景的伪代码如清单 9.10 所示。

[^25]: 在撰写本文时，这是单个 FreeRTOS+TCP 套接字可以在任务之间共享的唯一方式。

清单 9.10 演示的场景很简单，因为只需要两个任务相互同步，但如果其他任务正在执行依赖于套接字保持打开状态的处理操作，那么很容易看出该场景将变得更加复杂，并需要更多任务加入同步。

<a name="list9.11" title="Listing 9.11 两个任务相互同步以确保共享的 TCP 套接字...的伪代码"></a>

```c
void SocketTxTask( void *pvParameters )
{
    xSocket_t xSocket;
    uint32_t ulTxCount = 0UL;

    for( ;; )
    {
        /* 创建一个新的套接字。该任务将向此套接字发送数据，而另一个
           任务将从此套接字接收数据。 */
        xSocket = FreeRTOS_socket( ... );

        /* 连接套接字。 */
        FreeRTOS_connect( xSocket, ... );

        /* 使用队列将套接字发送给接收数据的任务。 */
        xQueueSend( xSocketPassingQueue, &xSocket, portMAX_DELAY );

        /* 在关闭套接字之前，向套接字发送 1000 条消息。 */
        for( ulTxCount = 0; ulTxCount < 1000; ulTxCount++ )
        {
            if( FreeRTOS_send( xSocket, ... ) < 0 )
            {
                /* 发生意外错误 - 退出循环，之后套接字将被关闭。 */
                break;
            }
        }

        /* 通知 Rx 任务 Tx 任务想要关闭套接字。 */
        TxTaskWantsToCloseSocket();

        /* 这是 Tx 任务的同步点。Tx 任务在此等待 Rx 任务到达其同步点。
           Rx 任务只有在不再使用套接字时才会到达其同步点，此时可以安全地关闭套接字。 */
        xEventGroupSync( ... );

        /* 两个任务都不再使用套接字。关闭连接，然后关闭套接字。 */
        FreeRTOS_shutdown( xSocket, ... );
        WaitForSocketToDisconnect();
        FreeRTOS_closesocket( xSocket );
    }
}
/*-----------------------------------------------------------*/

void SocketRxTask( void *pvParameters )
{
    xSocket_t xSocket;

    for( ;; )
    {
        /* 等待接收由 Tx 任务创建并连接的套接字。 */
        xQueueReceive( xSocketPassingQueue, &xSocket, portMAX_DELAY );

        /* 在 Tx 任务想要关闭套接字之前，持续从套接字接收数据。 */
        while( TxTaskWantsToCloseSocket() == pdFALSE )
        {
           /* 接收并处理数据。 */
           FreeRTOS_recv( xSocket, ... );
           ProcessReceivedData();
        }

        /* 这是 Rx 任务的同步点 - 只有在不再使用套接字时才会到达这里，
           此时 Tx 任务可以安全地关闭套接字。 */
        xEventGroupSync( ... );
    }
}
```
***清单 9.11*** *两个任务相互同步的伪代码，以确保在关闭共享的 TCP 套接字之前，两个任务都不再使用该套接字*


事件组可用于创建同步点：

- 每个必须参与同步的任务在事件组中被分配一个唯一的事件位。

- 每个任务在到达同步点时设置自己的事件位。

- 设置自己的事件位后，每个任务在事件组上阻塞，等待代表所有其他同步任务的事件位也被设置。

然而，`xEventGroupSetBits()`和`xEventGroupWaitBits()` API 函数不能在此场景中使用。如果使用它们，那么位的设置（表示任务已到达其同步点）和位的测试（确定其他同步任务是否已到达其同步点）将作为两个单独的操作执行。为了理解这为什么会成为问题，考虑一个场景，其中任务 A、任务 B 和任务 C 尝试使用事件组进行同步：

1. 任务 A 和任务 B 已经到达同步点，因此它们的事件位在事件组中被设置，并且它们处于阻塞状态，等待任务 C 的事件位也被设置。

2. 任务 C 到达同步点，并使用 `xEventGroupSetBits()` 设置其在事件组中的位。一旦任务 C 的位被设置，任务 A 和任务 B 就离开阻塞状态，并清除所有三个事件位。

3. 任务C随后调用`xEventGroupWaitBits()`等待所有三个事件位被置位，但此时所有三个事件位已经被清除，任务A和任务B已经离开了它们各自的同步点，因此同步失败。

要成功使用事件组创建同步点，事件位的设置以及随后的测试必须作为一个不可中断的操作来执行。为此，提供了`xEventGroupSync()` API函数。

### 9.4.1 xEventGroupSync() API函数

`xEventGroupSync()`函数用于允许两个或更多任务使用事件组进行相互同步。该函数允许任务在事件组中设置一个或多个事件位，然后等待同一事件组中的事件位组合被置位，这是一个不可中断的操作。

`xEventGroupSync()`函数的`uxBitsToWaitFor`参数指定了调用任务的解除阻塞条件。如果`xEventGroupSync()`返回是因为满足了解除阻塞条件，则在`xEventGroupSync()`返回之前，`uxBitsToWaitFor`指定的事件位将被清零。

<a name="list9.12" title="Listing 9.12 The xEventGroupSync() API function prototype"></a>

```c
EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait );
```
***Listing 9.12*** *xEventGroupSync() API 函数原型*


**xEventGroupSync() 参数和返回值**

- `xEventGroup`

  事件组的句柄，用于设置并测试事件位。该事件组句柄由创建事件组的 `xEventGroupCreate()` 函数调用返回。

- `uxBitsToSet`

  一个位掩码，指定要在事件组中设置为 1 的事件位。事件组的值通过将其现有值与传入的 `uxBitsToSet` 值进行按位或运算来更新。

  例如，将 `uxBitsToSet` 设置为 0x04（二进制 0100）将导致事件位 2 被设置（如果尚未设置），同时保持事件组中所有其他事件位不变。

- `uxBitsToWaitFor`

  一个位掩码，用于指定要测试的事件位或事件位组。

  例如，如果调用任务希望等待事件组中的事件位 0、1 和 2 被置位，则将 `uxBitsToWaitFor` 设置为 0x07（二进制 111）。

- `xTicksToWait`

  任务应保持在阻塞状态下等待其解除阻塞条件被满足的最长时间。

  如果 `xTicksToWait` 为零，或者在调用 `xEventGroupSync()` 时解除阻塞条件已经满足，`xEventGroupSync()` 将立即返回。

  阻塞时间以 tick 周期为单位指定，因此它所表示的绝对时间取决于 tick 频率。可以使用宏 `pdMS_TO_TICKS()` 将以毫秒为单位的时间转换为以 tick 为单位的时间。

  如果将 `xTicksToWait` 设置为 `portMAX_DELAY`，并且 FreeRTOSConfig.h 中的 `INCLUDE_vTaskSuspend` 设置为 1，则任务将无限期等待（不会超时）。

- 返回值

  如果 `xEventGroupSync()` 返回是因为调用任务的解除阻塞条件被满足，则返回值为调用任务的解除阻塞条件被满足时事件组的值（在任何位被自动清零之前）。在这种情况下，返回值也将满足调用任务的解除阻塞条件。

如果 `xEventGroupSync()` 由于 `xTicksToWait` 参数指定的阻塞时间到期而返回，则返回值是阻塞时间到期时事件组的值。在这种情况下，返回值将不满足调用任务的解除阻塞条件。

<a name="example9.2" title="示例 9.2 任务同步"></a>
---
***示例 9.2*** *任务同步*

---

示例 9.2 使用 `xEventGroupSync()` 来同步单个任务实现的三个实例。任务参数用于传递给每个实例，该实例将在调用 `xEventGroupSync()` 时设置的事件位。

任务在调用 `xEventGroupSync()` 之前打印一条消息，并在 `xEventGroupSync()` 调用返回后再次打印一条消息。每条消息都包含时间戳。这使得可以在生成的输出中观察到执行顺序。使用伪随机延迟来防止所有任务同时到达同步点。

有关任务的实现，请参见代码清单 9.12。

<a name="list9.13" title="代码清单 9.13 示例 9.2 中使用的任务实现"></a>

```c
static void vSyncingTask( void *pvParameters )
{
    const TickType_t xMaxDelay = pdMS_TO_TICKS( 4000UL );
    const TickType_t xMinDelay = pdMS_TO_TICKS( 200UL );
    TickType_t xDelayTime;
    EventBits_t uxThisTasksSyncBit;
    const EventBits_t uxAllSyncBits = ( mainFIRST_TASK_BIT  |
                                        mainSECOND_TASK_BIT |
                                        mainTHIRD_TASK_BIT );

    /* 此任务的三个实例被创建 —— 每个任务在同步中使用不同的事件位。
       每个任务实例通过任务参数传入要使用的事件位。将其存储在
       uxThisTasksSyncBit 变量中。 */
    uxThisTasksSyncBit = ( EventBits_t ) pvParameters;

    for( ;; )
    {
        /* 通过延迟一个伪随机时间来模拟此任务执行某些操作所需的时间。
           这可以防止此任务的三个实例同时到达同步点，从而更容易观察示例的行为。 */
        xDelayTime = ( rand() % xMaxDelay ) + xMinDelay;
        vTaskDelay( xDelayTime );

        /* 打印一条消息以显示此任务已到达其同步点。
           pcTaskGetTaskName() 是一个 API 函数，它返回创建任务时为任务分配的名称。 */
        vPrintTwoStrings( pcTaskGetTaskName( NULL ), "已到达同步点" );

        /* 等待所有任务到达各自的同步点。 */
        xEventGroupSync( /* 用于同步的事件组。 */
                         xEventGroup,

                         /* 此任务设置的事件位，以指示其已到达同步点。 */
                         uxThisTasksSyncBit,

                         /* 要等待的位，每个参与同步的任务对应一个位。 */
                         uxAllSyncBits,

                         /* 无限期等待所有三个任务到达同步点。 */
                         portMAX_DELAY );

        /* 打印一条消息以显示此任务已通过其同步点。
           由于使用了无限期延迟，以下行仅在所有任务到达各自的同步点后才会执行。 */
        vPrintTwoStrings( pcTaskGetTaskName( NULL ), "已离开同步点" );
    }
}
```
***代码清单 9.13*** *示例 9.2 中使用的任务实现*

`main()` 函数创建事件组，创建所有三个任务，然后启动调度器。其实现见代码清单 9.14。

<a name="list9.14" title="代码清单 9.14 示例 9.2 中使用的 main() 函数"></a>

```c
/* 事件组中事件位的定义 */

#define mainFIRST_TASK_BIT ( 1UL << 0UL ) /* 事件位 0，由第 1 个任务设置 */
#define mainSECOND_TASK_BIT( 1UL << 1UL ) /* 事件位 1，由第 2 个任务设置 */
#define mainTHIRD_TASK_BIT ( 1UL << 2UL ) /* 事件位 2，由第 3 个任务设置 */

/* 声明用于同步三个任务的事件组 */
EventGroupHandle_t xEventGroup;

int main( void )
{
    /* 在使用事件组之前，必须先创建它 */
    xEventGroup = xEventGroupCreate();

    /* 创建任务的三个实例。每个任务都被赋予不同的名称，
       稍后会打印出来以直观显示哪个任务正在执行。
       任务参数用于将任务到达同步点时使用的事件位传递给任务 */
    xTaskCreate( vSyncingTask, "Task 1", 1000, mainFIRST_TASK_BIT, 1, NULL );
    xTaskCreate( vSyncingTask, "Task 2", 1000, mainSECOND_TASK_BIT, 1, NULL );
    xTaskCreate( vSyncingTask, "Task 3", 1000, mainTHIRD_TASK_BIT, 1, NULL );

    /* 启动调度器，使创建的任务开始执行 */
    vTaskStartScheduler();

    /* 和往常一样，以下代码行永远不会被执行到 */
    for( ;; );
    return 0;
}
```
***代码清单 9.14*** *示例 9.2 中使用的 main() 函数*

执行示例 9.2 时产生的输出如图 9.5 所示。可以看出，尽管每个任务在不同的（伪随机）时间到达同步点，但所有任务都在同一时间退出同步点[^26]（即最后一个任务到达同步点的时间）。

[^26]: 图9.5展示了在FreeRTOS Windows移植版本中运行的示例，该版本并不提供真正的实时行为（特别是在使用Windows系统调用来打印到控制台时），因此会显示一些时间上的变化。

<a name="fig9.5" title="图9.5 执行示例9.2时产生的输出"></a>

* * *
![](media/image75.jpg)
***图9.5*** *执行示例9.2时产生的输出*
* * *



