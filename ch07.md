# 7 中断管理

## 7.1 简介

### 7.1.1 事件

嵌入式实时系统需要根据来自环境的事件采取相应的操作。例如，以太网外设上到达的数据包（事件）可能需要将其传递给TCP/IP协议栈进行处理（操作）。复杂的系统需要处理来自多个源的事件，这些事件的处理开销和响应时间要求各不相同。在每种情况下，都需要判断最佳的事件处理实现策略：

- 事件应如何检测？通常使用中断，但也可以轮询输入。
- 使用中断时，中断服务例程（ISR）内应执行多少处理，外部应执行多少？通常希望尽可能保持每个ISR的简短。
- 事件如何传递给主（非ISR）代码，以及如何构建此代码以最好地适应潜在异步事件的处理？

FreeRTOS并未对应用程序设计者强加任何特定的事件处理策略，但提供了允许以简单且可维护的方式实现所选策略的功能。

需要区分任务的优先级和中断的优先级：

- 任务是与FreeRTOS运行的硬件无关的软件功能。任务的优先级由应用程序编写者在软件中分配，软件算法（调度程序）决定将哪个任务置于运行状态。
- 尽管中断服务例程是用软件编写的，但它是一种硬件功能，因为硬件控制着哪个中断服务例程将运行以及何时运行。任务仅在没有任何ISR运行时才会运行，因此最低优先级的中断也会中断最高优先级的任务，任务无法抢占ISR。

FreeRTOS运行的所有架构都能够处理中断，但与中断进入和中断优先级分配相关的细节因架构而异。


### 7.1.2 范围

本章涵盖以下内容：

- 哪些FreeRTOS API函数可以在中断服务例程中使用。
- 将中断处理推迟到任务的方法。
- 如何创建和使用二进制信号量和计数信号量。
- 二进制信号量与计数信号量的区别。
- 如何使用队列在中断服务例程中传递数据。
- 某些FreeRTOS端口支持的中断嵌套模型。

## 7.2 在ISR中使用FreeRTOS API

### 7.2.1 中断安全API

通常需要从中断服务例程（ISR）中使用FreeRTOS API函数提供的功能，但许多FreeRTOS API函数执行的操作在ISR内部是无效的。其中最值得注意的是将调用API函数的任务置于阻塞状态——如果从ISR中调用API函数，则它不是从任务中调用的，因此没有调用任务可以被置于阻塞状态。FreeRTOS通过提供某些API函数的两个版本来解决这个问题：一个版本供任务使用，另一个版本供ISR使用。供ISR使用的函数在其名称后附加了“FromISR”。

> *注意：切勿在ISR中调用名称中不包含“FromISR”的FreeRTOS API函数。*


### 7.2.2 使用独立的中断安全API的优势

为中断使用单独的API可以使任务代码更高效、中断服务例程（ISR）代码更高效，并且中断入口更简单。要理解这一点，可以考虑替代方案，即提供一个单一版本的API函数，该函数既可以从任务中调用，也可以从中断中调用。如果同一个API函数既可以从任务中调用，也可以从中断中调用，那么：

- API函数需要额外的逻辑来确定它们是从任务还是中断中调用的。这些额外的逻辑会引入新的执行路径，使得函数更长、更复杂，并且更难以测试。

- 当函数从任务中调用时，某些API函数参数将变得多余；而当函数从中断中调用时，另一些参数将变得多余。

- 每个FreeRTOS移植都需要提供一种机制来确定执行上下文（任务或中断）。

- 在不便于确定执行上下文（任务或中断）的架构上，将需要额外的、浪费的、更复杂且非标准的中断入口代码，以便通过软件提供执行上下文。


### 7.2.3 使用独立的中断安全API的缺点

为某些API函数提供两个版本可以使任务和中断服务程序（ISR）都更高效，但这也引入了一个新问题：有时需要从任务和ISR中调用一个不属于FreeRTOS API但使用了FreeRTOS API的函数。

这通常在集成第三方代码时才会成为问题，因为这是唯一一个软件设计不在应用程序开发者控制范围内的情况。如果确实遇到这个问题，可以通过以下技术之一来解决：

- 将中断处理延迟到任务中[^12]，这样API函数就只会在任务上下文中被调用。

- 如果你使用的FreeRTOS移植版本支持中断嵌套，则使用以"FromISR"结尾的API函数版本，因为该版本可以从任务和ISR中调用。（反之则不成立，不以"FromISR"结尾的API函数绝不能从ISR中调用。）

- 第三方代码通常包含一个RTOS抽象层，可以实现该抽象层来测试函数是从哪个上下文（任务或中断）中被调用的，然后调用适合该上下文的API函数。


[^12]: 延迟中断处理将在本书的下一节中介绍。


### 7.2.4 xHigherPriorityTaskWoken 参数

本节介绍 `xHigherPriorityTaskWoken` 参数的概念。如果尚未完全理解本节内容，请不要担心，后续章节将提供实际示例。

如果上下文切换是由中断执行的，那么在中断退出时运行的任务可能与中断进入时运行的任务不同——中断可能会中断一个任务，但返回到另一个任务。

某些 FreeRTOS API 函数可以将任务从阻塞状态移动到就绪状态。这已经在使用诸如 `xQueueSendToBack()` 等函数时看到过，如果有一个任务在阻塞状态中等待队列中的数据变为可用，那么该函数将解除任务的阻塞状态。

如果由 FreeRTOS API 函数解除阻塞的任务的优先级高于运行状态中任务的优先级，那么根据 FreeRTOS 调度策略，应该切换到更高优先级的任务。切换到更高优先级任务的实际发生时间取决于调用 API 函数的上下文：

- 如果 API 函数是从任务中调用的：

  如果 FreeRTOSConfig.h 中的 `configUSE_PREEMPTION` 设置为 1，则切换到更高优先级任务的操作会在 API 函数内部自动执行，换句话说，在 API 函数退出之前。这已经在图 6.6 中看到过，其中写入计时器命令队列的操作导致在写入命令队列的函数退出之前切换到 RTOS 守护任务。

- 如果 API 函数是从中断中调用的：

  切换到更高优先级任务的操作不会在中断内部自动执行。相反，会设置一个变量来通知应用程序编写者应该执行上下文切换。中断安全的 API 函数（以 "FromISR" 结尾的函数）有一个名为 `pxHigherPriorityTaskWoken` 的指针参数，用于此目的。

  如果需要执行上下文切换，那么中断安全的 API 函数会将 `*pxHigherPriorityTaskWoken` 设置为 `pdTRUE`。为了能够检测到这一点，`pxHigherPriorityTaskWoken` 所指向的变量在首次使用之前必须初始化为 `pdFALSE`。

  如果应用程序编写者选择不从 ISR 请求上下文切换，那么更高优先级的任务将保持就绪状态，直到调度程序下一次运行，最坏的情况是在下一个滴答中断期间。

  FreeRTOS API 函数只能将 `*pxHighPriorityTaskWoken` 设置为 `pdTRUE`。如果一个 ISR 调用了多个 FreeRTOS API 函数，那么可以将同一个变量作为 `pxHigherPriorityTaskWoken` 参数传递给每个 API 函数调用，并且该变量只需在首次使用之前初始化为 `pdFALSE`。

上下文切换不会在 API 函数的中断安全版本中自动执行，有以下几个原因：

- 避免不必要的上下文切换

  在任务需要执行任何处理之前，中断可能会多次执行。例如，考虑一个场景，其中任务处理由中断驱动的 UART 接收的字符串；如果 UART ISR 每次接收到一个字符时都切换到任务，那将是浪费的，因为任务只有在接收到完整字符串后才需要进行处理。

- 控制执行顺序

  中断可能偶发地发生，并且在不可预测的时间。经验丰富的 FreeRTOS 用户可能希望在应用程序的特定点暂时避免不可预测地切换到不同任务，尽管这也可以通过 FreeRTOS 调度器锁定机制来实现。

- 可移植性

  这是可以在所有 FreeRTOS 移植中使用的最简单的机制。

- 效率

  针对较小处理器架构的移植只允许在 ISR 的最后请求上下文切换，取消这一限制将需要额外且更复杂的代码。它还允许在同一个 ISR 中多次调用 FreeRTOS API 函数，而不会在同一个 ISR 中生成多个上下文切换请求。

- 在 RTOS 滴答中断中执行

  正如本书后面将看到的，可以将应用程序代码添加到 RTOS 滴答中断中。在滴答中断内部尝试上下文切换的结果取决于所使用的 FreeRTOS 移植。最好的情况下，它将导致对调度程序的不必要调用。

`pxHigherPriorityTaskWoken` 参数的使用是可选的。如果不需要，可以将 `pxHigherPriorityTaskWoken` 设置为 NULL。


### 7.2.5 portYIELD\_FROM\_ISR() 和 portEND\_SWITCHING\_ISR() 宏

本节介绍用于在中断服务程序（ISR）中请求上下文切换的宏。如果你暂时没有完全理解本节内容，不必担心，后续章节将提供实际示例。

`taskYIELD()` 是一个可以在任务中调用以请求上下文切换的宏。`portYIELD_FROM_ISR()` 和 `portEND_SWITCHING_ISR()` 则是 `taskYIELD()` 的中断安全版本。`portYIELD_FROM_ISR()` 和 `portEND_SWITCHING_ISR()` 的使用方式相同，功能也相同[^13]。某些 FreeRTOS 端口仅提供这两个宏中的一个，而较新的 FreeRTOS 端口则同时提供这两个宏。本书的示例中使用的是 `portYIELD_FROM_ISR()`。

[^13]: 历史上，`portEND_SWITCHING_ISR()` 用于那些要求中断处理程序使用汇编代码包装器的 FreeRTOS 端口，而 `portYIELD_FROM_ISR()` 则用于允许整个中断处理程序用 C 语言编写的 FreeRTOS 端口。


<a name="list7.1" title="Listing 7.1 The portEND\_SWITCHING\_ISR() macros"></a>

```c
portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
```
***清单 7.1*** *portEND\_SWITCHING\_ISR() 宏*


<a name="list7.2" title="Listing 7.2 The portYIELD\_FROM\_ISR() macros"></a>

```c
portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
```
***清单 7.2*** *portYIELD\_FROM\_ISR() 宏*


传递给中断安全 API 函数的 `xHigherPriorityTaskWoken` 参数可以直接用作 `portYIELD_FROM_ISR()` 调用的参数。

如果 `portYIELD_FROM_ISR()` 的 `xHigherPriorityTaskWoken` 参数为 `pdFALSE`（零），则不会请求上下文切换，宏也不会产生任何效果。如果 `portYIELD_FROM_ISR()` 的 `xHigherPriorityTaskWoken` 参数不为 `pdFALSE`，则会请求上下文切换，且处于运行状态的任务可能会发生变化。中断将始终返回到处于运行状态的任务，即使该任务在中断执行期间发生了变化。

大多数 FreeRTOS 端口允许在 ISR 的任何位置调用 `portYIELD_FROM_ISR()`。少数 FreeRTOS 端口（主要为较小架构的端口）只允许在 ISR 的最后调用 `portYIELD_FROM_ISR()`。


## 7.3 延迟中断处理

通常认为，尽可能保持中断服务程序（ISR）简短是最佳实践。原因包括：

- 即使任务被赋予了非常高的优先级，它们也只有在硬件没有处理中断时才能运行。
- ISR可能会干扰任务的开始时间和执行时间，增加“抖动”。
- 根据FreeRTOS运行的架构，可能在ISR执行时无法接受任何新中断，或者至少无法接受一部分新中断。
- 应用程序开发者需要考虑并防止任务和ISR同时访问资源（如变量、外设和内存缓冲区）的后果。
- 某些FreeRTOS移植版本允许中断嵌套，但中断嵌套会增加复杂性并降低可预测性。中断越短，嵌套的可能性就越低。

中断服务程序必须记录中断的原因并清除中断。中断所需的任何其他处理通常可以在任务中完成，从而使中断服务程序能够尽快退出。这被称为“延迟中断处理”，因为中断所需的处理从ISR“延迟”到任务中执行。

将中断处理延迟到任务中，还允许应用程序开发者相对于应用程序中的其他任务为处理设置优先级，并使用所有FreeRTOS API函数。

如果中断处理被延迟到的任务优先级高于任何其他任务的优先级，那么处理将立即执行，就像在ISR本身中执行一样。这种情况如图7.1所示，其中任务1是一个普通的应用程序任务，而任务2是中断处理被延迟到的任务。

<a name="fig7.1" title="图7.1 在高优先级任务中完成中断处理"></a>

* * *
![](media/image48.png)
***图7.1*** *在高优先级任务中完成中断处理*
* * *

在图7.1中，中断处理从时间t2开始，实际在时间t4结束，但只有在时间t2到t3之间是在ISR中执行。如果未使用延迟中断处理，那么整个时间t2到t4都将在ISR中执行。

关于何时最好在ISR中执行中断所需的所有处理，以及何时最好将部分处理延迟到任务中，没有绝对的规则。在以下情况下，将处理延迟到任务中最为有用：

- 中断所需的处理并非微不足道。例如，如果中断只是存储模数转换的结果，那么几乎可以肯定最好在ISR中执行，但如果转换结果还需要通过软件过滤器处理，那么最好在任务中执行过滤器。
- 中断处理需要执行无法在ISR中执行的操作，例如写入控制台或分配内存。
- 中断处理是非确定性的——即无法预先知道处理需要多长时间。

以下部分将描述和演示本章介绍的概念，包括可用于实现延迟中断处理的FreeRTOS特性。


## 7.4 用于同步的二进制信号量

二进制信号量API的中断安全版本可用于在每次特定中断发生时解除任务的阻塞状态，从而有效地将任务与中断同步。这使得大部分中断事件处理可以在同步任务中实现，而只有非常快速和简短的部分直接保留在ISR中。正如前一节所述，二进制信号量用于将中断处理“推迟”到任务中[^14]。

[^14]: 使用直接任务通知从中断中解除任务的阻塞比使用二进制信号量更高效。直接任务通知将在第10章“任务通知”中详细介绍。

如前文图7.1所示，如果中断处理对时间特别敏感，则可以设置推迟处理任务的优先级，以确保该任务始终抢占系统中的其他任务。然后可以实现ISR以包含对`portYIELD_FROM_ISR()`的调用，确保ISR直接返回到中断处理被推迟的任务。这样可以确保整个事件处理在时间上连续执行（没有中断），就像它全部在ISR本身中实现一样。图7.2重复了图7.1所示的场景，但更新了文本以描述如何使用信号量控制推迟处理任务的执行。


<a name="fig7.2" title="图7.2 使用二进制信号量实现推迟中断处理"></a>

* * *
![](media/image49.png)
***图7.2*** *使用二进制信号量实现推迟中断处理*
* * *

推迟处理任务使用阻塞的“获取”调用来获取信号量，作为一种进入阻塞状态以等待事件发生的手段。当事件发生时，ISR使用“释放”操作对同一信号量进行释放，以解除任务的阻塞，从而使所需的事件处理可以继续进行。

“获取信号量”和“释放信号量”的概念根据其使用场景具有不同的含义。在这种中断同步场景中，二进制信号量可以被概念化为一个长度为1的队列。队列在任何时候最多只能包含一个项目，因此总是为空或满（因此称为二进制）。通过调用`xSemaphoreTake()`，中断处理被推迟的任务实际上尝试从队列中读取，并带有阻塞时间，如果队列为空，则导致任务进入阻塞状态。当事件发生时，ISR使用`xSemaphoreGiveFromISR()`函数将令牌（信号量）放入队列中，使队列变为满。这导致任务退出阻塞状态并移除令牌，使队列再次为空。当任务完成其处理后，它再次尝试从队列中读取，发现队列为空，重新进入阻塞状态以等待下一个事件。这一过程在图7.3中进行了演示。

图7.3显示了中断“释放”信号量，即使它没有首先“获取”它，而任务“获取”信号量，但从不释放它。这就是为什么该场景被描述为概念上与写入和读取队列类似。它经常引起混淆，因为它不遵循其他信号量使用场景的规则，在其他场景中，任务获取信号量后必须始终释放它——例如第8章“资源管理”中描述的场景。


<a name="fig7.3" title="图7.3 使用二进制信号量将任务与中断同步"></a>

* * *
![](media/image50.png)
***图7.3*** *使用二进制信号量将任务与中断同步*
* * *


### 7.4.1 xSemaphoreCreateBinary() API 函数

FreeRTOS 还包含 `xSemaphoreCreateBinaryStatic()` 函数，该函数在编译时静态分配创建二进制信号量所需的内存：所有类型的 FreeRTOS 信号量的句柄都存储在 `SemaphoreHandle_t` 类型的变量中。

在使用信号量之前，必须先创建它。要创建二进制信号量，请使用 `xSemaphoreCreateBinary()` API 函数[^15]。

[^15]: 一些信号量 API 函数实际上是宏而不是函数。为简单起见，本书中均将它们称为函数。


<a name="list7.3" title="Listing 7.3 The xSemaphoreCreateBinary() API function prototype"></a>

```c
SemaphoreHandle_t xSemaphoreCreateBinary( void );
```
***Listing 7.3*** *xSemaphoreCreateBinary() API 函数原型*

**xSemaphoreCreateBinary() 返回值**

- 返回值

  如果返回 NULL，则表示由于 FreeRTOS 可用的堆内存不足以分配信号量数据结构，因此无法创建信号量。

  如果返回非 NULL 值，则表示信号量已成功创建。返回的值应作为已创建信号量的句柄存储。


### 7.4.2 xSemaphoreTake() API 函数

“获取”信号量意味着“获得”或“接收”信号量。只有在信号量可用时，才能获取它。

除了递归互斥锁，所有类型的 FreeRTOS 信号量都可以使用 `xSemaphoreTake()` 函数来获取。

`xSemaphoreTake()` 不能在中断服务例程中使用。

<a name="list7.4" title="Listing 7.4 The xSemaphoreTake() API function prototype"></a>

```c
BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait );
```
***代码清单 7.4*** *xSemaphoreTake() API 函数原型*

**xSemaphoreTake() 参数和返回值**

- `xSemaphore`

  被“获取”的信号量。

  信号量通过 `SemaphoreHandle_t` 类型的变量引用。它必须在使用前显式创建。

- `xTicksToWait`

  如果信号量不可用，任务应保持在阻塞状态等待信号量的最长时间。

  如果 `xTicksToWait` 为零，则当信号量不可用时，`xSemaphoreTake()` 会立即返回。

  阻塞时间以 tick 周期为单位指定，因此它所表示的绝对时间取决于 tick 频率。可以使用宏 `pdMS_TO_TICKS()` 将以毫秒为单位的时间转换为以 tick 为单位的时间。

  如果 `FreeRTOSConfig.h` 中的 `INCLUDE_vTaskSuspend` 设置为 1，将 `xTicksToWait` 设置为 `portMAX_DELAY` 将使任务无限期等待（无超时）。

- 返回值

  有两个可能的返回值：

  - `pdPASS`

    只有在 `xSemaphoreTake()` 成功获取信号量时，才会返回 `pdPASS`。

    如果指定了阻塞时间（`xTicksToWait` 不为零），则当信号量不可用时，调用任务可能会被置于阻塞状态以等待信号量，但在阻塞时间到期之前，信号量变为可用。

  - `pdFALSE`

    信号量不可用。

    如果指定了阻塞时间（`xTicksToWait` 不为零），则调用任务将被置于阻塞状态以等待信号量变为可用，但在阻塞时间到期之前，信号量仍未变为可用。


### 7.4.3 xSemaphoreGiveFromISR() API 函数

二值信号量和计数信号量[^16]可以使用 `xSemaphoreGiveFromISR()` 函数进行“释放”。

[^16]: 计数信号量将在本书后续章节中描述。

`xSemaphoreGiveFromISR()` 是 `xSemaphoreGive()` 的中断安全版本，因此具有本章开头描述的 `pxHigherPriorityTaskWoken` 参数。


<a name="list" title="Listing 7.5 The xSemaphoreGiveFromISR() API function prototype"></a>

```c
BaseType_t xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore,
                                  BaseType_t *pxHigherPriorityTaskWoken );
```
***代码清单 7.5*** *xSemaphoreGiveFromISR() API 函数原型*

**xSemaphoreGiveFromISR() 参数和返回值**

- `xSemaphore`

  要“释放”的信号量。

  信号量由类型为 `SemaphoreHandle_t` 的变量引用，并且必须在使用前显式创建。

- `pxHigherPriorityTaskWoken`

  一个信号量可能有一个或多个任务因等待信号量可用而处于阻塞状态。调用 `xSemaphoreGiveFromISR()` 可能会使信号量可用，从而导致等待信号量的任务离开阻塞状态。如果调用 `xSemaphoreGiveFromISR()` 导致任务离开阻塞状态，并且该解除阻塞的任务的优先级高于当前正在执行的任务（被中断的任务），那么 `xSemaphoreGiveFromISR()` 会在内部将 `*pxHigherPriorityTaskWoken` 设置为 `pdTRUE`。

如果 `xSemaphoreGiveFromISR()` 将此值设置为 `pdTRUE`，则通常应在退出中断之前执行上下文切换。这将确保中断直接返回到最高优先级的就绪状态任务。

- 返回值

  有两种可能的返回值：

  - `pdPASS`

    只有在 `xSemaphoreGiveFromISR()` 调用成功时，才会返回 `pdPASS`。

  - `pdFAIL`

    如果信号量已经可用，则无法再次给出，`xSemaphoreGiveFromISR()` 将返回 `pdFAIL`。

<a name="example7.1" title="示例 7.1 使用二进制信号量同步任务与中断"></a>
---
***示例 7.1*** *使用二进制信号量同步任务与中断*

---

本示例使用二进制信号量从中断服务例程中解除任务的阻塞，从而有效地将任务与中断同步。

一个简单的周期性任务用于每 500 毫秒生成一次软件中断。由于在某些目标环境中挂接到真实中断的复杂性，使用软件中断是为了方便。清单 7.6 展示了该周期性任务的实现。请注意，任务在生成中断前后都会打印出一个字符串。这允许在执行示例时通过输出观察执行顺序。

<a name="list7.6" title="代码清单 7.6 示例 7.1 中定期生成软件中断的任务的实现"></a>

```c
/* 本示例中使用的软件中断编号。代码来自 Windows 项目，其中编号 0 到 2 由 FreeRTOS Windows 移植版本身使用，因此 3 是应用程序可用的第一个编号。 */
#define mainINTERRUPT_NUMBER 3

static void vPeriodicTask( void *pvParameters )
{
    const TickType_t xDelay500ms = pdMS_TO_TICKS( 500UL );

    /* 与大多数任务一样，此任务在无限循环中实现。 */
    for( ;; )
    {
        /* 阻塞直到再次生成软件中断的时间。 */
        vTaskDelay( xDelay500ms );

        /* 生成中断，在中断生成前后打印消息，以便从输出中清楚地看出执行顺序。

           生成软件中断的语法取决于所使用的 FreeRTOS 移植版。下面使用的语法仅适用于 FreeRTOS Windows 移植版，其中此类中断仅是被模拟的。 */
        vPrintString( "Periodic task - About to generate an interrupt.\r\n" );
        vPortGenerateSimulatedInterrupt( mainINTERRUPT_NUMBER );
        vPrintString( "Periodic task - Interrupt generated.\r\n\r\n\r\n" );
    }
}
```
***代码清单 7.6*** *示例 7.1 中定期生成软件中断的任务的实现*

代码清单 7.7 展示了中断处理被延迟到的任务的实现——该任务通过使用二进制信号量与软件中断同步。同样，在任务的每次迭代中都会打印一个字符串，因此当示例执行时，从输出中可以清楚地看出任务和中断的执行顺序。

需要注意的是，虽然代码清单7.7中所示的代码适用于示例7.1（其中中断由软件生成），但对于硬件外设生成中断的场景来说并不适用。后续小节将描述如何修改代码结构，使其适用于硬件生成的中断。


<a name="list7.7." title="Listing 7.7 The implementation of the task to which the interrupt processing is deferred (the task that..."></a>

```c
static void vHandlerTask( void *pvParameters )
{
    /* 与大多数任务一样，此任务在无限循环中实现。 */
    for( ;; )
    {
        /* 使用信号量等待事件。信号量是在调度器启动之前创建的，
           因此在此任务首次运行之前。任务无限期阻塞，意味着
           此函数调用仅在成功获取信号量后返回——因此无需检查
           xSemaphoreTake()的返回值。 */
        xSemaphoreTake( xBinarySemaphore, portMAX_DELAY );

        /* 到达此处意味着事件已发生。处理事件（在本例中，
           仅打印一条消息）。 */
        vPrintString( "Handler task - Processing event.\r\n" );
    }
}
```
***代码清单7.7*** *示例7.1中用于延迟中断处理的任务实现（与中断同步的任务）*


代码清单7.8展示了中断服务程序（ISR）。它除了“给出”信号量以解除阻塞延迟中断处理的任务外，几乎不做其他事情。

注意 `xHigherPriorityTaskWoken` 变量的使用方式。在调用 `xSemaphoreGiveFromISR()` 之前，它被设置为 `pdFALSE`，然后在调用 `portYIELD_FROM_ISR()` 时作为参数使用。如果 `xHigherPriorityTaskWoken` 等于 `pdTRUE`，`portYIELD_FROM_ISR()` 宏内部将请求一次上下文切换。

此中断服务程序（ISR）的原型以及用于强制上下文切换的宏对于 FreeRTOS Windows 移植版本都是正确的，但可能与其他 FreeRTOS 移植版本不同。请参考 FreeRTOS.org 网站上的移植特定文档页面，以及 FreeRTOS 下载包中提供的示例，以找到你使用的移植版本所需的语法。

与大多数运行 FreeRTOS 的架构不同，FreeRTOS Windows 移植版本要求 ISR 返回一个值。Windows 移植版本提供的 `portYIELD_FROM_ISR()` 宏的实现包含了返回语句，因此清单 7.8 中没有显式返回值。

<a name="list7.8" title="清单 7.8 示例 7.1 中使用的软件中断的 ISR"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
    BaseType_t xHigherPriorityTaskWoken;

    /* xHigherPriorityTaskWoken 参数必须初始化为 pdFALSE，
       因为如果需要在中断安全的 API 函数内部请求上下文切换，
       它会被设置为 pdTRUE。 */
    xHigherPriorityTaskWoken = pdFALSE;

    /* '给出' 信号量以解锁任务，传递 xHigherPriorityTaskWoken 的地址
       作为中断安全 API 函数的 pxHigherPriorityTaskWoken 参数。 */
    xSemaphoreGiveFromISR( xBinarySemaphore, &xHigherPriorityTaskWoken );

    /* 将 xHigherPriorityTaskWoken 的值传递给 portYIELD_FROM_ISR()。
       如果 xHigherPriorityTaskWoken 在 xSemaphoreGiveFromISR() 内部
       被设置为 pdTRUE，那么调用 portYIELD_FROM_ISR() 将请求一次上下文切换。
       如果 xHigherPriorityTaskWoken 仍然是 pdFALSE，那么调用
       portYIELD_FROM_ISR() 将不会有任何效果。与大多数 FreeRTOS 移植版本不同，
       Windows 移植版本要求 ISR 返回一个值——返回语句位于 Windows 版本的
       portYIELD_FROM_ISR() 内部。 */
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***清单 7.8*** *示例 7.1 中使用的软件中断的 ISR*

`main()` 函数创建二进制信号量，创建任务，安装中断处理程序，并启动调度器。其实现如清单 7.9 所示。

调用以安装中断处理程序的函数的语法是特定于FreeRTOS Windows移植版的，对于其他FreeRTOS移植版可能会有所不同。请参考FreeRTOS.org网站上的移植版特定文档页面，以及FreeRTOS下载包中提供的示例，以找到你所使用的移植版所需的语法。


<a name="list7.9" title="Listing 7.9 The implementation of main() for Example 7.1"></a>

```c
int main( void )
{
    /* 在使用信号量之前，必须显式创建它。在此示例中，创建一个二进制信号量。 */
    xBinarySemaphore = xSemaphoreCreateBinary();

    /* 检查信号量是否成功创建。 */
    if( xBinarySemaphore != NULL )
    {
        /* 创建“处理器”任务，该任务是将中断处理延迟到的任务。这是将与中断同步的任务。
           处理器任务以高优先级创建，以确保它在中断退出后立即运行。在此示例中，选择优先级为3。 */
        xTaskCreate( vHandlerTask, "Handler", 1000, NULL, 3, NULL );

        /* 创建将定期生成软件中断的任务。该任务以低于处理器任务的优先级创建，
           以确保每次处理器任务退出阻塞状态时它都会被抢占。 */
        xTaskCreate( vPeriodicTask, "Periodic", 1000, NULL, 1, NULL );

        /* 安装软件中断的处理程序。执行此操作所需的语法取决于使用的FreeRTOS移植版。
           此处显示的语法仅适用于FreeRTOS Windows移植版，其中此类中断是模拟的。 */
        vPortSetInterruptHandler( mainINTERRUPT_NUMBER,
                                  ulExampleInterruptHandler );

        /* 启动调度器，使创建的任务开始执行。 */
        vTaskStartScheduler();
    }

    /* 正常情况下，以下代码行不应被执行。 */
    for( ;; );
}
```
***代码清单 7.9*** *示例7.1中main()函数的实现*


示例7.1生成的输出如图7.4所示。正如预期的那样，`vHandlerTask()`在生成中断后立即进入运行状态，因此该任务的输出分割了周期性任务生成的输出。更多解释如图7.5所示。

<a name="fig7.4" title="Figure 7.4 The output produced when Example 7.1 is executed"></a>
<a name="fig7.5" title="Figure 7.5 The sequence of execution when Example 7.1 is executed"></a>

* * *
![](media/image51.jpg)
***图 7.4*** *执行示例 7.1 时产生的输出*

![](media/image52.png)
***图 7.5*** *执行示例 7.1 时的执行顺序*
* * *

### 7.4.4 改进示例 7.1 中任务的实现

示例 7.1 使用了一个二进制信号量来同步任务与中断。其执行顺序如下：

1. 中断发生。
2. ISR 执行并向任务“释放”信号量以解除其阻塞。
3. 任务在 ISR 之后立即执行，并“获取”信号量。
4. 任务处理事件，然后尝试再次“获取”信号量——由于信号量尚未可用（另一个中断尚未发生），任务进入阻塞状态。

如果中断发生的频率相对较低，示例 7.1 中使用的任务结构是足够的。为了理解原因，考虑如果在任务完成对第一个中断的处理之前发生了第二个甚至第三个中断，会发生什么：

- 当第二个 ISR 执行时，信号量为空，因此 ISR 会释放信号量，任务在处理完第一个事件后立即处理第二个事件。该场景如图 7.6 所示。

- 当第三个中断服务程序（ISR）执行时，信号量已经可用，从而阻止了ISR再次给出信号量，因此任务将无法得知第三个事件已经发生。这种情况如图7.7所示。

<a name="fig7.6" title="图7.6 任务尚未完成第一个事件处理时发生一个中断的场景"></a>
<a name="fig7.7" title="图7.7 任务尚未完成第一个事件处理时发生两个中断的场景"></a>

* * *
![](media/image53.png)
***图7.6*** *任务尚未完成第一个事件处理时发生一个中断的场景*

![](media/image54.png)
***图7.7*** *任务尚未完成第一个事件处理时发生两个中断的场景*
* * *

示例7.1中使用的延迟中断处理任务（如清单7.7所示）的结构设计为每次调用`xSemaphoreTake()`之间仅处理一个事件。这对于示例7.1是足够的，因为生成事件的中断是由软件触发的，并且发生在可预测的时间。在实际应用中，中断是由硬件生成的，并且发生在不可预测的时间。因此，为了最大限度地减少中断被遗漏的可能性，延迟中断处理任务的结构必须设计为在每次调用`xSemaphoreTake()`之间处理所有已经可用的事件[^17]。清单7.10展示了如何为UART构建一个延迟中断处理程序。在清单7.10中，假设UART每次接收到一个字符时都会生成一个接收中断，并且UART将接收到的字符放入硬件FIFO（硬件缓冲区）中。

[^17]: 或者，可以使用计数信号量或直接任务通知来计数事件。计数信号量将在下一节中介绍。直接任务通知将在第10章“任务通知”中描述。直接任务通知是首选方法，因为它们在运行时间和RAM使用方面都是最高效的。

示例7.1中使用的延迟中断处理任务还有一个缺点；它在调用`xSemaphoreTake()`时没有使用超时。相反，任务将`portMAX_DELAY`作为`xSemaphoreTake()`的`xTicksToWait`参数传递，这导致任务无限期地（没有超时）等待信号量可用。无限期超时通常用于示例代码中，因为它们的使用简化了示例的结构，从而使示例更易于理解。然而，无限期超时在实际应用中通常是不良实践，因为它们使得从错误中恢复变得困难。例如，考虑以下场景：一个任务正在等待中断给出信号量，但硬件中的错误状态阻止了中断的生成：

- 如果任务在没有超时的情况下等待，它将不会知道错误状态，并且会永远等待。

- 如果任务正在等待超时，那么当超时到期时，`xSemaphoreTake()` 将返回 `pdFAIL`，任务可以在下次执行时检测并清除错误。此场景也如清单 7.10 所示。


<a name="list7.10" title="清单 7.10 推荐的延迟中断处理任务结构，以UART接收处理程序为例"></a>

```c
static void vUARTReceiveHandlerTask( void *pvParameters )
{
    /* xMaxExpectedBlockTime 保存两次中断之间的最大预期时间。 */
    const TickType_t xMaxExpectedBlockTime = pdMS_TO_TICKS( 500 );

    /* 与大多数任务一样，此任务在无限循环中实现。 */
    for( ;; )
    {
        /* 信号量由 UART 的接收 (Rx) 中断“给出”。
           等待下一个中断的最长时间为 xMaxExpectedBlockTime 个 tick。 */
        if( xSemaphoreTake( xBinarySemaphore, xMaxExpectedBlockTime ) == pdPASS)
        {
            /* 成功获取信号量。在再次调用 xSemaphoreTake() 之前，
               处理所有挂起的 Rx 事件。每个 Rx 事件都会将一个字符
               放入 UART 的接收 FIFO 中，假设 UART_RxCount() 返回
               FIFO 中的字符数。 */
            while( UART_RxCount() > 0 )
            {
                /* 假设 UART_ProcessNextRxEvent() 处理一个 Rx 字符，
                   将 FIFO 中的字符数减少 1。 */
                UART_ProcessNextRxEvent();
            }

            /* 没有更多挂起的 Rx 事件（FIFO 中没有更多字符），
               因此循环返回并调用 xSemaphoreTake() 以等待下一个中断。
               在代码中的此点与调用 xSemaphoreTake() 之间发生的任何中断
               都将锁存在信号量中，因此不会丢失。 */
        }
        else
        {
            /* 在预期时间内未收到事件。检查并清除 UART 中的任何错误条件，
               这些错误可能会阻止 UART 生成更多中断。 */
            UART_ClearErrors();
        }
    }
}
```
***清单 7.10*** *推荐的延迟中断处理任务结构，以 UART 接收处理程序为例*



## 7.5 计数信号量

正如二值信号量可以被视为长度为1的队列，计数信号量可以被视为长度大于1的队列。任务并不关心队列中存储的数据，只关心队列中的项目数量。在FreeRTOSConfig.h中，`configUSE_COUNTING_SEMAPHORES`必须设置为1，才能使用计数信号量。

每次计数信号量被“释放”时，其队列中的另一个空间被使用。队列中的项目数量即为信号量的“计数值”。

计数信号量通常用于以下两种情况：

1. **事件计数** [^18]

   在这种情况下，每次事件发生时，事件处理程序会“释放”一个信号量，使得信号量的计数值在每次“释放”时增加。任务在每次处理事件时会“获取”一个信号量，使得信号量的计数值在每次“获取”时减少。计数值表示已发生事件与已处理事件之间的差异。图7.8展示了这一机制。

   用于事件计数的计数信号量在创建时，其初始计数值为零。

   [^18]: 使用直接任务通知来计数事件比使用计数信号量更高效。直接任务通知将在第10章中介绍。

2. **资源管理**

   在这种情况下，计数值表示可用资源的数量。要获取资源的控制权，任务必须首先获取一个信号量，这会减少信号量的计数值。当计数值达到零时，表示没有可用资源。当任务使用完资源后，它会“释放”信号量，这会增加信号量的计数值。

   用于资源管理的计数信号量在创建时，其初始计数值等于可用资源的数量。第7章将详细介绍如何使用信号量来管理资源。

<a name="fig7.8" title="Figure 7.8 使用计数信号量来‘计数’事件"></a>

* * *
![](media/image55.png)
***图7.8*** *使用计数信号量来‘计数’事件*
* * *

### 7.5.1 xSemaphoreCreateCounting() API 函数

FreeRTOS 还包含了 `xSemaphoreCreateCountingStatic()` 函数，该函数在编译时静态分配创建计数信号量所需的内存：所有类型的 FreeRTOS 信号量的句柄都存储在 `SemaphoreHandle_t` 类型的变量中。

在使用信号量之前，必须先创建它。要创建计数信号量，请使用 `xSemaphoreCreateCounting()` API 函数。

<a name="list7.11" title="Listing 7.11 The xSemaphoreCreateCounting() API function prototype"></a>

```c
SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount,
                                            UBaseType_t uxInitialCount );
```
***代码清单 7.11*** *xSemaphoreCreateCounting() API 函数原型*

**xSemaphoreCreateCounting() 参数和返回值**

- `uxMaxCount`

   信号量计数的最大值。继续用队列类比，`uxMaxCount` 值实际上是队列的长度。

当信号量用于计数或锁存事件时，`uxMaxCount` 是可锁存事件的最大数量。

当信号量用于管理对一组资源的访问时，`uxMaxCount` 应设置为可用资源的总数。

- `uxInitialCount`

  信号量创建后的初始计数值。

  当信号量用于计数或锁存事件时，`uxInitialCount` 应设置为零（因为在信号量创建时，我们假设尚未发生任何事件）。

  当信号量用于管理对一组资源的访问时，`uxInitialCount` 应设置为等于 `uxMaxCount`（因为在信号量创建时，我们假设所有资源都可用）。

- 返回值

  如果返回 NULL，则表示无法创建信号量，因为 FreeRTOS 没有足够的堆内存来分配信号量数据结构。第3章提供了有关堆内存管理的更多信息。

如果返回了非NULL值，则表明信号量已成功创建。返回值应作为已创建信号量的句柄进行存储。

<a name="example7.2" title="示例7.2 使用计数信号量同步任务与中断"></a>
---
***示例7.2*** *使用计数信号量同步任务与中断*
---

示例7.2在示例7.1的实现基础上进行了改进，使用计数信号量替代了二进制信号量。`main()`函数被修改为包含对`xSemaphoreCreateCounting()`的调用，以替代对`xSemaphoreCreateBinary()`的调用。新的API调用如代码清单7.12所示。

<a name="list7.12" title="代码清单7.12 在示例7.2中创建计数信号量的xSemaphoreCreateCounting()调用"></a>

```c
/* 在使用信号量之前，必须显式创建它。在此示例中，创建了一个计数信号量。该信号量的最大计数值为10，初始计数值为0。 */
xCountingSemaphore = xSemaphoreCreateCounting( 10, 0 );
```
***代码清单7.12*** *在示例7.2中创建计数信号量的xSemaphoreCreateCounting()调用*

为了模拟高频发生的多个事件，中断服务例程被修改为每次中断时多次“释放”信号量。每个事件都被锁存在信号量的计数值中。修改后的中断服务例程如代码清单7.13所示。

<a name="list7.13" title="代码清单 7.13 示例 7.2 中使用的中断服务例程的实现"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
    BaseType_t xHigherPriorityTaskWoken;

    /* 必须将 xHigherPriorityTaskWoken 参数初始化为 pdFALSE，
       因为如果需要在中断安全的 API 函数中进行上下文切换，
       该参数将被设置为 pdTRUE。 */
    xHigherPriorityTaskWoken = pdFALSE;

    /* 多次“给出”信号量。第一次将解除延迟中断处理任务的阻塞，
       随后的“给出”是为了演示信号量可以锁存事件，以便延迟中断
       的任务能够依次处理这些事件，而不会丢失事件。这模拟了处理器
       接收到多个中断的情况，尽管在此示例中事件是在单次中断发生
       中模拟的。 */
    xSemaphoreGiveFromISR( xCountingSemaphore, &xHigherPriorityTaskWoken );
    xSemaphoreGiveFromISR( xCountingSemaphore, &xHigherPriorityTaskWoken );
    xSemaphoreGiveFromISR( xCountingSemaphore, &xHigherPriorityTaskWoken );

    /* 将 xHigherPriorityTaskWoken 值传递给 portYIELD_FROM_ISR()。
       如果在 xSemaphoreGiveFromISR() 中将 xHigherPriorityTaskWoken 
       设置为 pdTRUE，则调用 portYIELD_FROM_ISR() 将请求上下文切换。
       如果 xHigherPriorityTaskWoken 仍为 pdFALSE，则调用 
       portYIELD_FROM_ISR() 将不会产生任何影响。与大多数 FreeRTOS 
       移植版本不同，Windows 移植版本要求 ISR 返回一个值 —— 返回
       语句位于 Windows 版本的 portYIELD_FROM_ISR() 中。 */
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***代码清单 7.13*** *示例 7.2 中使用的中断服务例程的实现*

其他所有函数均与示例 7.1 中使用的函数保持不变。

执行示例7.2时产生的输出如图7.9所示。  
可以看到，中断处理被延迟到任务中，每次生成中断时，该任务都会处理所有三个（模拟的）事件。这些事件被锁存到信号量的计数值中，从而允许任务依次处理它们。


<a name="fig7.9" title="图7.9 执行示例7.2时产生的输出"></a>

* * *
![](media/image56.jpg)
***图7.9*** *执行示例7.2时产生的输出*
* * *



## 7.6 将工作延迟到RTOS守护任务

到目前为止，所展示的延迟中断处理示例都要求应用程序编写者为每个使用延迟处理技术的中断创建一个任务。也可以使用`xTimerPendFunctionCallFromISR()`[^19] API函数将中断处理延迟到RTOS守护任务中，这样就无需为每个中断创建单独的任务。将中断处理延迟到守护任务中称为“集中式延迟中断处理”。

[^19]: 守护任务最初被称为定时器服务任务，因为它最初仅用于执行软件定时器回调函数。因此，`xTimerPendFunctionCall()`实现在timers.c中，并且根据在函数实现文件中为函数名称添加前缀的约定，该函数名称以“Timer”为前缀。

第6章描述了与软件定时器相关的FreeRTOS API函数如何通过定时器命令队列向守护任务发送命令。`xTimerPendFunctionCall()`和`xTimerPendFunctionCallFromISR()` API函数使用相同的定时器命令队列向守护任务发送“执行函数”命令。发送到守护任务的函数随后在守护任务的上下文中执行。

集中式延迟中断处理的优点包括：

- **资源占用更低**

  无需为每个延迟中断创建单独的任务。

- **简化用户模型**

  延迟中断处理函数是一个标准的C函数。

集中式延迟中断处理的缺点包括：

- **灵活性较低**

  无法单独设置每个延迟中断处理任务的优先级。每个延迟中断处理函数都以守护任务的优先级执行。如第6章所述，守护任务的优先级由FreeRTOSConfig.h中的`configTIMER_TASK_PRIORITY`编译时配置常量设置。

- **确定性较低**

  `xTimerPendFunctionCallFromISR()`将命令发送到定时器命令队列的末尾。守护任务会先处理已经在定时器命令队列中的命令，然后再处理由`xTimerPendFunctionCallFromISR()`发送到队列的“执行函数”命令。

不同的中断有不同的时序要求，因此在同一个应用程序中通常会同时使用这两种延迟中断处理方法。


### 7.6.1 xTimerPendFunctionCallFromISR() API 函数

`xTimerPendFunctionCallFromISR()` 是 `xTimerPendFunctionCall()` 的中断安全版本。这两个 API 函数都允许应用程序开发人员提供的函数在 RTOS 守护任务中执行，因此是在守护任务的上下文中执行。要执行的函数及其输入参数的值都会通过定时器命令队列发送到守护任务。因此，函数实际执行的时间取决于守护任务相对于应用程序中其他任务的优先级。


<a name="list7.14" title="Listing 7.14 The xTimerPendFunctionCallFromISR() API function prototype"></a>

```c
BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t
                                          xFunctionToPend,
                                          void *pvParameter1,
                                          uint32_t ulParameter2,
                                          BaseType_t *pxHigherPriorityTaskWoken );
```
***Listing 7.14*** *xTimerPendFunctionCallFromISR() API 函数原型*


<a name="list7.15" title="Listing 7.15 The prototype to which a function passed in the xFunctionToPend parameter of xTimerPendFunctionCallFromISR()..."></a>

```c
void vPendableFunction( void *pvParameter1, uint32_t ulParameter2 );
```
***Listing 7.15*** *传递给 xTimerPendFunctionCallFromISR() 的 xFunctionToPend 参数的函数必须符合的原型*


**xTimerPendFunctionCallFromISR() 参数和返回值**

- `xFunctionToPend`

  指向将在守护任务中执行的函数的指针（实际上就是函数名）。该函数的原型必须与 Listing 7.15 中显示的原型一致。

- `pvParameter1`

  该值将作为`pvParameter1`参数传递给由守护任务执行的函数。该参数具有`void *`类型，以便能够用于传递任何数据类型。例如，整型可以直接强制转换为`void *`，或者`void *`可以用于指向一个结构体。

- `ulParameter2`

  该值将作为`ulParameter2`参数传递给由守护任务执行的函数。

- `pxHigherPriorityTaskWoken`

  `xTimerPendFunctionCallFromISR()`会向定时器命令队列写入数据。如果RTOS守护任务处于阻塞状态以等待定时器命令队列上出现数据，那么向定时器命令队列写入数据将导致守护任务离开阻塞状态。如果守护任务的优先级高于当前正在执行的任务（被中断的任务）的优先级，那么`xTimerPendFunctionCallFromISR()`会在内部将`*pxHigherPriorityTaskWoken`设置为`pdTRUE`。

如果 `xTimerPendFunctionCallFromISR()` 将此值设置为 `pdTRUE`，则必须在退出中断之前执行上下文切换。这将确保中断直接返回到守护任务，因为守护任务将是处于就绪状态的最高优先级任务。

- 返回值

  有两种可能的返回值：

  - `pdPASS`

    如果“执行函数”命令成功写入定时器命令队列，则返回 `pdPASS`。

  - `pdFAIL`

    如果由于定时器命令队列已满而无法将“执行函数”命令写入定时器命令队列，则返回 `pdFAIL`。第6章介绍了如何设置定时器命令队列的长度。


<a name="example7.3" title="示例 7.3 集中式延迟中断处理"></a>
---
***示例 7.3*** *集中式延迟中断处理*

---

示例7.3提供了与示例7.1类似的功能，但没有使用信号量，也没有专门创建一个任务来执行中断所需的处理。相反，处理由RTOS守护任务完成。

示例7.3使用的中断服务例程如代码清单7.16所示。它调用 `xTimerPendFunctionCallFromISR()` 将指向 `vDeferredHandlingFunction()` 函数的指针传递给守护任务。延后的中断处理由 `vDeferredHandlingFunction()` 函数执行。

每次执行中断服务例程时，它都会递增一个名为 `ulParameterValue` 的变量。 `ulParameterValue` 在调用 `xTimerPendFunctionCallFromISR()` 时作为 `ulParameter2` 的值使用，因此当守护任务执行 `vDeferredHandlingFunction()` 时，它也将作为 `vDeferredHandlingFunction()` 调用中的 `ulParameter2` 的值使用。该函数的另一个参数 `pvParameter1` 在本示例中未使用。


<a name="list7.16" title="代码清单7.16 示例7.3中使用的软件中断处理程序"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
    static uint32_t ulParameterValue = 0;
    BaseType_t xHigherPriorityTaskWoken;

    /* xHigherPriorityTaskWoken 参数必须初始化为 pdFALSE，
       因为如果需要进行上下文切换，中断安全API函数内部会将其设置为 pdTRUE。 */
    xHigherPriorityTaskWoken = pdFALSE;

    /* 将指向中断的延后处理函数的指针发送给守护任务。
       延后处理函数的 pvParameter1 参数未使用，因此设置为 NULL。
       延后处理函数的 ulParameter2 参数用于传递一个数字，
       该数字在每次执行此中断处理程序时递增一次。 */
    xTimerPendFunctionCallFromISR( vDeferredHandlingFunction, /* 要执行的函数 */
                                   NULL, /* 未使用 */
                                   ulParameterValue, /* 递增的值 */
                                   &xHigherPriorityTaskWoken );
    ulParameterValue++;

    /* 将 xHigherPriorityTaskWoken 值传递给 portYIELD_FROM_ISR()。
       如果 xHigherPriorityTaskWoken 在 xTimerPendFunctionCallFromISR() 中被设置为 pdTRUE，
       则调用 portYIELD_FROM_ISR() 将请求上下文切换。
       如果 xHigherPriorityTaskWoken 仍为 pdFALSE，
       则调用 portYIELD_FROM_ISR() 不会有任何效果。
       与大多数 FreeRTOS 移植不同，Windows 移植要求 ISR 返回一个值 ——
       return 语句位于 Windows 版本的 portYIELD_FROM_ISR() 内部。 */
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***代码清单7.16*** *示例7.3中使用的软件中断处理程序*

`vDeferredHandlingFunction()` 的实现如代码清单7.17所示。它输出一个固定字符串及其 `ulParameter2` 参数的值。

`vDeferredHandlingFunction()` 必须具有如代码清单 7.15 所示的原型，尽管在本示例中实际上只使用了其中一个参数。

<a name="list7.17" title="代码清单 7.17 用于处理示例 7.3 中中断所必需的处理函数"></a>

```c
static void vDeferredHandlingFunction( void *pvParameter1, uint32_t ulParameter2 )
{
    /* 处理事件 —— 在本例中仅打印一条消息及 ulParameter2 的值。pvParameter1 在本示例中未使用。 */
    vPrintStringAndNumber( "处理函数 - 处理事件 ", ulParameter2 );
}
```
***代码清单 7.17*** *用于处理示例 7.3 中中断所必需的处理函数*

示例 7.3 使用的 `main()` 函数如代码清单 7.18 所示。它比示例 7.1 中使用的 `main()` 函数更简单，因为它既没有创建信号量，也没有创建任务来执行延迟中断处理。

`vPeriodicTask()` 是定期生成软件中断的任务。它的优先级低于守护任务的优先级，以确保一旦守护任务离开阻塞状态，它就会被守护任务抢占。

<a name="list7.18" title="Listing 7.18 The implementation of main() for Example 7.3"></a>

```c
int main( void )
{
    /* 生成软件中断的任务的优先级低于守护任务的优先级。守护任务的优先级由FreeRTOSConfig.h中的
       configTIMER_TASK_PRIORITY编译时配置常量设置。 */
    const UBaseType_t ulPeriodicTaskPriority = configTIMER_TASK_PRIORITY - 1;

    /* 创建将定期生成软件中断的任务。 */
    xTaskCreate( vPeriodicTask, "Periodic", 1000, NULL, ulPeriodicTaskPriority,
                 NULL );

    /* 安装软件中断的处理程序。执行此操作所需的语法取决于所使用的FreeRTOS端口。这里显示的语法只能用于
       FreeRTOS Windows端口，其中此类中断是模拟的。 */
    vPortSetInterruptHandler( mainINTERRUPT_NUMBER, ulExampleInterruptHandler );

    /* 启动调度器以使创建的任务开始执行。 */
    vTaskStartScheduler();

    /* 正常情况下，以下代码行永远不会被执行。 */
    for( ;; );
}
```
***Listing 7.18*** *示例7.3中main()函数的实现*

示例7.3产生的输出如图7.10所示。守护任务的优先级高于生成软件中断的任务的优先级，因此一旦中断生成，守护任务就会立即执行`vDeferredHandlingFunction()`。这导致`vDeferredHandlingFunction()`输出的消息出现在周期性任务输出的两条消息之间，就像使用信号量解除专用延迟中断处理任务的阻塞时一样。进一步的解释如图7.11所示。

<a name="fig7.10" title="图7.10 执行示例7.3时产生的输出"></a>
<a name="fig7.11" title="图7.11 执行示例7.3时的执行顺序"></a>

* * *
![](media/image57.jpg)
***图7.10*** *执行示例7.3时产生的输出*

![](media/image58.png)
***图7.11*** *执行示例7.3时的执行顺序*
* * *

## 7.7 在中断服务例程中使用队列

二进制信号量和计数信号量用于通信事件。队列用于通信事件和传输数据。

`xQueueSendToFrontFromISR()` 是 `xQueueSendToFront()` 的中断安全版本，适用于在中断服务例程中使用；`xQueueSendToBackFromISR()` 是 `xQueueSendToBack()` 的中断安全版本，适用于在中断服务例程中使用；`xQueueReceiveFromISR()` 是 `xQueueReceive()` 的中断安全版本，适用于在中断服务例程中使用。

### 7.7.1 xQueueSendToFrontFromISR() 和 xQueueSendToBackFromISR() API 函数

<a name="list7.19" title="清单7.19 xQueueSendToFrontFromISR() API函数原型"></a>

```c
BaseType_t xQueueSendToFrontFromISR( QueueHandle_t xQueue,
                                     const void *pvItemToQueue
                                     BaseType_t *pxHigherPriorityTaskWoken );
```
***清单7.19*** *xQueueSendToFrontFromISR() API函数原型*

<a name="list7.20" title="清单7.20 xQueueSendToBackFromISR() API函数原型"></a>

```c
BaseType_t xQueueSendToBackFromISR( QueueHandle_t xQueue,
                                    const void *pvItemToQueue
                                    BaseType_t *pxHigherPriorityTaskWoken );
```
***清单7.20*** *xQueueSendToBackFromISR() API函数原型*

`xQueueSendFromISR()` 和 `xQueueSendToBackFromISR()` 在功能上是等效的。

**xQueueSendToFrontFromISR() 和 xQueueSendToBackFromISR() 参数和返回值**

- `xQueue`

  要发送（写入）数据的队列句柄。队列句柄是通过调用 `xQueueCreate()` 创建队列时返回的。

- `pvItemToQueue`

  指向要放入队列的项目的指针。

  队列中每个项目的大小在创建队列时定义，因此将从 `pvItemToQueue` 复制这么多字节到队列存储区域。

- `pxHigherPriorityTaskWoken`

  单个队列上可能有一个或多个任务被阻塞，等待数据可用。调用 `xQueueSendToFrontFromISR()` 或 `xQueueSendToBackFromISR()` 可以使数据可用，从而导致此类任务离开阻塞状态。如果调用API函数导致任务离开阻塞状态，并且未阻塞任务的优先级高于当前执行的任务（被中断的任务），则在内部，API函数会将 `*pxHigherPriorityTaskWoken` 设置为 `pdTRUE`。

  如果 `xQueueSendToFrontFromISR()` 或 `xQueueSendToBackFromISR()` 将此值设置为 `pdTRUE`，则应在退出中断之前执行上下文切换。这将确保中断直接返回到最高优先级的就绪状态任务。

- 返回值

  有两种可能的返回值：

  - `pdPASS`

    仅当数据成功发送到队列时返回 `pdPASS`。

  - `errQUEUE_FULL

    如果由于队列已满而无法将数据发送到队列，则返回 `errQUEUE_FULL`。


### 7.7.2 在ISR中使用队列时的注意事项

队列提供了一种简单便捷的方式将数据从中断传递到任务，但如果数据以高频率到达，使用队列并不高效。

FreeRTOS 下载包中的许多演示应用程序包含一个简单的 UART 驱动程序，该程序使用队列将字符从 UART 的接收 ISR 中传递出去。在这些演示中，使用队列有两个原因：一是演示如何在 ISR 中使用队列，二是为了故意加载系统以测试 FreeRTOS 移植。以这种方式使用队列的 ISR 绝不是为了展示高效的设计，除非数据到达速度较慢，否则不建议生产代码复制此技术。适用于生产代码的更高效技术包括：

- 使用直接内存访问（DMA）硬件来接收和缓冲字符。这种方法几乎没有软件开销。然后可以使用直接任务通知[^20]来解除阻塞任务，该任务仅在检测到传输中断后才会处理缓冲区。

[^20]: 直接任务通知是从ISR中解除任务阻塞的最有效方法。直接任务通知将在第10章“任务通知”中详细介绍。

- 将每个接收到的字符复制到线程安全的RAM缓冲区中[^21]。同样，可以使用直接任务通知来解除处理缓冲区的任务阻塞，该任务将在接收到完整消息或检测到传输中断后处理缓冲区。

  [^21]: FreeRTOS+TCP提供的“流缓冲区”（[https://www.FreeRTOS.org/tcp](http://www.FreeRTOS.org/tcp)）可用于此目的。

- 在ISR中直接处理接收到的字符，然后使用队列将数据处理结果（而非原始数据）发送给任务。这在图5.4中已经演示过。

<a name="example7.4" title="示例7.4 在中断内发送和接收队列"></a>
---
***示例7.4*** *在中断内发送和接收队列*

---

本示例演示了在同一中断中使用`xQueueSendToBackFromISR()`和`xQueueReceiveFromISR()`。为了方便起见，中断由软件生成。

创建了一个周期性任务，该任务每 200 毫秒向队列发送五个数字。只有在所有五个值都发送完毕后，它才会生成一个软件中断。任务实现如代码清单 7.21 所示。

<a name="list7.21" title="代码清单 7.21 示例 7.4 中写入队列的任务实现"></a>

```c
static void vIntegerGenerator( void *pvParameters )
{
    TickType_t xLastExecutionTime;
    uint32_t ulValueToSend = 0;
    int i;

    /* 初始化用于调用 vTaskDelayUntil() 的变量。 */
    xLastExecutionTime = xTaskGetTickCount();

    for( ;; )
    {
        /* 这是一个周期性任务。阻塞直到再次运行的时间。该任务将每 200ms 执行一次。 */
        vTaskDelayUntil( &xLastExecutionTime, pdMS_TO_TICKS( 200 ) );

        /* 向队列发送五个数字，每个值比前一个值大 1。这些数字由中断服务例程从队列中读取。中断服务例程总是清空队列，因此该任务保证能够写入所有五个值，而无需指定阻塞时间。 */
        for( i = 0; i < 5; i++ )
        {
            xQueueSendToBack( xIntegerQueue, &ulValueToSend, 0 );
            ulValueToSend++;
        }

        /* 生成中断，以便中断服务例程可以从队列中读取值。生成软件中断的语法取决于所使用的 FreeRTOS 移植版本。下面使用的语法只能用于 FreeRTOS Windows 移植版本，在这种情况下，此类中断仅是模拟的。 */
        vPrintString( "Generator task - About to generate an interrupt.\r\n" );
        vPortGenerateSimulatedInterrupt( mainINTERRUPT_NUMBER );
        vPrintString( "Generator task - Interrupt generated.\r\n\r\n\r\n" );
    }
}
```
***代码清单 7.21*** *示例 7.4 中写入队列的任务实现*

中断服务例程重复调用 `xQueueReceiveFromISR()`，直到读取完周期性任务写入队列的所有值，并且队列被清空。每个接收到的值的最后两位用作字符串数组的索引。然后使用 `xQueueSendFromISR()` 将指向相应索引位置的字符串的指针发送到另一个队列。中断服务例程的实现如代码清单 7.22 所示。

<a name="list7.22" title="Listing 7.22 例7.4中使用的中断服务例程的实现"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
    BaseType_t xHigherPriorityTaskWoken;
    uint32_t ulReceivedNumber;

    /* 字符串被声明为static const，以确保它们不会分配在中断服务例程的栈上，
       并且即使中断服务例程未执行时仍然存在。 */

    static const char *pcStrings[] =
    {
        "String 0\r\n",
        "String 1\r\n",
        "String 2\r\n",
        "String 3\r\n"
    };

    /* 如往常一样，xHigherPriorityTaskWoken被初始化为pdFALSE，
       以便检测它在中断安全API函数内部是否被设置为pdTRUE。
       请注意，由于中断安全API函数只能将xHigherPriorityTaskWoken设置为pdTRUE，
       因此在调用xQueueReceiveFromISR()和xQueueSendToBackFromISR()时
       使用相同的xHigherPriorityTaskWoken变量是安全的。 */
    xHigherPriorityTaskWoken = pdFALSE;

    /* 从队列中读取，直到队列为空。 */
    while( xQueueReceiveFromISR( xIntegerQueue,
                                 &ulReceivedNumber,
                                 &xHigherPriorityTaskWoken ) != errQUEUE_EMPTY )
    {
        /* 将接收到的值截取到最后两位（值为0到3，包含0和3），
           然后使用截取后的值作为索引从pcStrings[]数组中选择一个字符串（char *）
           发送到另一个队列。 */
        ulReceivedNumber &= 0x03;
        xQueueSendToBackFromISR( xStringQueue,
                                 &pcStrings[ ulReceivedNumber ],
                                 &xHigherPriorityTaskWoken );
    }

    /* 如果从xIntegerQueue接收数据导致某个任务离开阻塞状态，
       并且如果离开阻塞状态的任务的优先级高于当前运行任务的优先级，
       那么xHigherPriorityTaskWoken将在xQueueReceiveFromISR()内部被设置为pdTRUE。

       如果向xStringQueue发送数据导致某个任务离开阻塞状态，
       并且如果离开阻塞状态的任务的优先级高于当前运行任务的优先级，
       那么xHigherPriorityTaskWoken将在xQueueSendToBackFromISR()内部被设置为pdTRUE。

       xHigherPriorityTaskWoken作为portYIELD_FROM_ISR()的参数。
       如果xHigherPriorityTaskWoken等于pdTRUE，则调用portYIELD_FROM_ISR()
       将请求一次上下文切换。如果xHigherPriorityTaskWoken仍为pdFALSE，
       则调用portYIELD_FROM_ISR()将不会产生任何效果。

       Windows端口使用的portYIELD_FROM_ISR()实现包含一个return语句，
       这就是为什么此函数没有显式返回一个值的原因。 */
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```
***Listing 7.22*** *例7.4中使用的中断服务例程的实现*


从中断服务例程接收字符指针的任务在队列上阻塞，直到消息到达，并在接收到每个字符串时将其打印出来。其实现如Listing 7.23所示。

<a name="list7.23" title="Listing 7.23 打印从中断服务例程接收到的字符串的任务（示例7.4）"></a>

```c
static void vStringPrinter( void *pvParameters )
{
    char *pcString;

    for( ;; )
    {
        /* 在队列上阻塞，等待数据到达。 */
        xQueueReceive( xStringQueue, &pcString, portMAX_DELAY );

        /* 打印接收到的字符串。 */
        vPrintString( pcString );
    }
}
```
***代码清单 7.23*** *打印从中断服务例程接收到的字符串的任务（示例7.4）*

通常，`main()` 在启动调度器之前会创建所需的队列和任务。其实现如代码清单7.24所示。

<a name="list7.24" title="Listing 7.24 示例7.4的main()函数"></a>

```c
int main( void )
{
    /* 在使用队列之前，必须先创建它。创建本示例中使用的两个队列。
       一个队列可以保存类型为uint32_t的变量，另一个队列可以保存类型为char*的变量。
       两个队列最多都可以保存10个项目。实际应用程序应检查返回值以确保队列已成功创建。 */
    xIntegerQueue = xQueueCreate( 10, sizeof( uint32_t ) );
    xStringQueue = xQueueCreate( 10, sizeof( char * ) );

    /* 创建使用队列将整数传递给中断服务例程的任务。任务的优先级为1。 */
    xTaskCreate( vIntegerGenerator, "IntGen", 1000, NULL, 1, NULL );

    /* 创建打印从中断服务例程发送给它的字符串的任务。该任务的优先级较高，为2。 */
    xTaskCreate( vStringPrinter, "String", 1000, NULL, 2, NULL );

    /* 安装软件中断的处理程序。执行此操作所需的语法取决于使用的FreeRTOS移植版本。
       这里显示的语法只能用于FreeRTOS Windows移植版本，其中此类中断仅是模拟的。 */
    vPortSetInterruptHandler( mainINTERRUPT_NUMBER, ulExampleInterruptHandler );

    /* 启动调度器，使创建的任务开始执行。 */
    vTaskStartScheduler();

    /* 如果一切正常，main()将永远不会到达这里，因为调度器现在正在运行任务。
       如果main()确实到达了这里，那么很可能是堆内存不足，无法创建空闲任务。
       第2章提供了有关堆内存管理的更多信息。 */
    for( ;; );
}
```
***代码清单 7.24*** *示例7.4的main()函数*

执行示例7.4时产生的输出如图7.12所示。可以看到，中断接收了所有五个整数，并生成了五个字符串作为响应。更多解释如图7.13所示。

<a name="fig7.12" title="Figure 7.12 The output produced when Example 7.4 is executed"></a>
<a name="fig7.13" title="Figure 7.13 The sequence of execution produced by Example 7.4"></a>

* * *
![](media/image59.jpg)
***图 7.12*** *执行示例 7.4 时产生的输出*

![](media/image60.png)
***图 7.13*** *示例 7.4 产生的执行顺序*
* * *

## 7.8 中断嵌套

任务优先级和中断优先级之间常常会引起混淆。本节将讨论中断优先级，即中断服务例程（ISR）相互之间的执行优先级。分配给任务的优先级与分配给中断的优先级没有任何关系。硬件决定ISR何时执行，而软件决定任务何时执行。响应硬件中断执行的ISR会中断任务，但任务不能抢占ISR。

支持中断嵌套的端口需要在FreeRTOSConfig.h中定义以下一个或两个常量。`configMAX_SYSCALL_INTERRUPT_PRIORITY`和`configMAX_API_CALL_INTERRUPT_PRIORITY`都定义了相同的属性。较旧的FreeRTOS端口使用`configMAX_SYSCALL_INTERRUPT_PRIORITY`，而较新的FreeRTOS端口使用`configMAX_API_CALL_INTERRUPT_PRIORITY`。

**控制中断嵌套的常量**

- `configMAX_SYSCALL_INTERRUPT_PRIORITY` 或 `configMAX_API_CALL_INTERRUPT_PRIORITY`

  设置可以从中调用中断安全的FreeRTOS API函数的最高中断优先级。

- `configKERNEL_INTERRUPT_PRIORITY`

  设置tick中断使用的中断优先级，必须始终设置为可能的最低中断优先级。

  如果使用的FreeRTOS端口不使用`configMAX_SYSCALL_INTERRUPT_PRIORITY`常量，则任何使用中断安全的FreeRTOS API函数的中断也必须以`configKERNEL_INTERRUPT_PRIORITY`定义的优先级执行。

每个中断源都有一个数字优先级和一个逻辑优先级：

- 数字优先级

  数字优先级是分配给中断优先级的数字。例如，如果中断的优先级为7，则其数字优先级为7。同样，如果中断的优先级为200，则其数字优先级为200。

- 逻辑优先级

  中断的逻辑优先级描述了该中断相对于其他中断的优先权。

  如果两个不同优先级的中断同时发生，则处理器将先执行逻辑优先级较高的中断的ISR，然后再执行逻辑优先级较低的中断的ISR。

  中断可以中断（嵌套）任何逻辑优先级较低的中断，但不能中断（嵌套）任何逻辑优先级相等或较高的中断。

中断的数字优先级和逻辑优先级之间的关系取决于处理器架构；在某些处理器上，分配给中断的数字优先级越高，该中断的逻辑优先级就*越高*，而在其他处理器架构上，分配给中断的数字优先级越高，该中断的逻辑优先级就*越低*。

通过将`configMAX_SYSCALL_INTERRUPT_PRIORITY`设置为比`configKERNEL_INTERRUPT_PRIORITY`更高的逻辑中断优先级，可以创建一个完整的中断嵌套模型。这在图7.14中得到了展示，图中展示了以下场景：

- 处理器有七个唯一的中断优先级。
- 数字优先级为7的中断比数字优先级为1的中断具有更高的逻辑优先级。
- `configKERNEL_INTERRUPT_PRIORITY`设置为1。
- `configMAX_SYSCALL_INTERRUPT_PRIORITY`设置为3。


<a name="fig7.14" title="Figure 7.14 Constants affecting interrupt nesting behavior"></a>

* * *
![](media/image61.png)
***图 7.14*** *影响中断嵌套行为的常量*
* * *

参考图7.14：

- 使用优先级1到3（包括1和3）的中断在内核或应用程序处于临界区时被阻止执行。以这些优先级运行的ISR可以使用中断安全的FreeRTOS API函数。临界区将在第8章中描述。

- 使用优先级4或更高的中断不受临界区的影响，因此调度器的任何操作都不会阻止这些中断立即执行——在硬件本身的限制范围内。以这些优先级执行的ISR不能使用任何FreeRTOS API函数。

- 通常，需要非常严格时间精度的功能（例如电机控制）将使用高于`configMAX_SYSCALL_INTERRUPT_PRIORITY`的优先级，以确保调度器不会在中断响应时间中引入抖动。


### 7.8.1 给ARM Cortex-M[^22]和ARM GIC用户的说明

[^22]: 本节仅部分适用于Cortex-M0和Cortex-M0+内核。

在Cortex-M处理器上配置中断容易令人困惑且容易出错。为了协助开发，FreeRTOS的Cortex-M移植版本会自动检查中断配置，但仅在定义了`configASSERT()`时生效。`configASSERT()`的描述请参见第11.2节。

ARM Cortex内核和ARM通用中断控制器（GIC）使用数值*较小*的优先级编号来表示逻辑上*较高*优先级的中断。这可能看起来违反直觉，并且容易被遗忘。如果你想为某个中断分配逻辑上较低的优先级，则必须为其分配一个数值较高的值；反之，如果你想分配逻辑上较高的优先级，则必须为其分配一个数值较低的值。

Cortex-M中断控制器允许使用最多8位来指定每个中断的优先级，因此255是最低可能的优先级，而0是最高优先级。然而，Cortex-M微控制器通常只实现了8位中的一部分，实际实现的位数取决于微控制器系列。

当只实现了8位中的一部分时，只有字节的最高有效位可以被使用——最低有效位未被实现。未实现的位可以取任何值，但通常将其设置为1。图7.15展示了如何在实现了4个优先级位的Cortex-M微控制器中存储二进制值为101的优先级。

<a name="fig7.15" title="图7.15 二进制值101在实现了4个优先级位的Cortex-M微控制器中的存储方式"></a>

* * *
![](media/image62.png)
***图7.15*** *二进制值101在实现了4个优先级位的Cortex-M微控制器中的存储方式*
* * *

在图7.15中，二进制值101被移动到最高有效的4位，因为最低有效的4位未被实现。未实现的位被设置为1。

某些库函数要求优先级值在移动到已实现（最高有效）位之后指定。使用此类函数时，图7.15中显示的优先级可以指定为十进制95。十进制95是将二进制101向左移动4位后得到的二进制101nnnn（其中'n'是未实现的位），并且未实现的位设置为1，即二进制1011111。

另一些库函数要求优先级值在移动到已实现（最高有效）位之前指定。使用此类函数时，图7.15中显示的优先级必须指定为十进制5。十进制5是未经任何移动的二进制101。

`configMAX_SYSCALL_INTERRUPT_PRIORITY`和`configKERNEL_INTERRUPT_PRIORITY`必须以允许直接写入Cortex-M寄存器的方式指定，因此在优先级值移动到已实现的位之后指定。

`configKERNEL_INTERRUPT_PRIORITY`必须始终设置为最低可能的中断优先级。未实现的优先级位可以设置为1，因此无论实际实现了多少优先级位，该常量始终可以设置为255。

Cortex-M中断默认优先级为0——最高可能的优先级。Cortex-M硬件的实现不允许将`configMAX_SYSCALL_INTERRUPT_PRIORITY`设置为0，因此使用FreeRTOS API的中断优先级绝不能保留为默认值。

