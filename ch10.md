# 10 任务通知

## 10.1 引言

FreeRTOS应用程序通常由一系列独立的任务组成，这些任务通过相互通信来共同提供系统功能。任务通知是一种高效的机制，允许一个任务直接通知另一个任务。

### 10.1.1 通过中介对象进行通信

本书已经描述了任务之间通信的各种方式。到目前为止描述的方法都需要创建一个通信对象。通信对象的示例包括队列、事件组和各种不同类型的信号量。

当使用通信对象时，事件和数据不会直接发送到接收任务或接收ISR，而是发送到通信对象。同样，任务和ISR从通信对象接收事件和数据，而不是直接从发送事件或数据的任务或ISR接收。这在图10.1中有所体现。

<a name="fig10.1" title="图10.1 使用通信对象将事件从一个任务发送到另一个任务"></a>

* * *
![](media/image76.png)
***图10.1*** *使用通信对象将事件从一个任务发送到另一个任务*
* * *

### 10.1.2 任务通知—直接任务通信

'任务通知' 允许任务与其他任务进行交互，并与中断服务程序（ISR）同步，而无需单独的通信对象。通过使用任务通知，任务或ISR可以直接向接收任务发送事件。这在图10.2中有所描述。

<a name="fig10.2" title="图10.2 使用任务通知直接从一个任务发送事件到另一个任务"></a>

* * *
![](media/image77.png)
***图10.2*** *使用任务通知直接从一个任务发送事件到另一个任务*
* * *

任务通知功能是可选的。要包含任务通知功能，请在FreeRTOSConfig.h中将`configUSE_TASK_NOTIFICATIONS`设置为1。

当`configUSE_TASK_NOTIFICATIONS`设置为1时，每个任务至少有一个'通知状态'，可以是'待处理'或'未待处理'，以及一个'通知值'，这是一个32位无符号整数。当任务接收到通知时，其通知状态设置为待处理。当任务读取其通知值时，其通知状态设置为未待处理。如果`configTASK_NOTIFICATION_ARRAY_ENTRIES`设置为大于1的值，则有多个通知状态和值，由索引标识。

任务可以在阻塞状态下等待，可选超时，直到其通知状态变为待处理。

### 10.1.3 作用域

本章讨论以下内容：

- 任务的通知状态和通知值。
- 任务通知何时以及如何可以替代通信对象（如信号量）。
- 使用任务通知替代通信对象的优势。

## 10.2 任务通知；优点和局限性

### 10.2.1 任务通知的性能优势

使用任务通知向任务发送事件或数据比使用队列、信号量或事件组执行等效操作要快得多。

### 10.2.2 任务通知的RAM占用优势

同样，使用任务通知向任务发送事件或数据比使用队列、信号量或事件组执行等效操作所需的RAM要少得多。这是因为每个通信对象（队列、信号量或事件组）在使用之前必须创建，而启用任务通知功能具有固定的开销。任务通知的RAM成本为`configTASK_NOTIFICATION_ARRAY_ENTRIES` * 每个任务5字节。`configTASK_NOTIFICATION_ARRAY_ENTRIES`的默认值为1，因此任务通知的默认大小为每个任务5字节。

### 10.2.3 任务通知的局限性

任务通知比通信对象更快且占用的RAM更少，但任务通知不能在所有场景中使用。本节记录了任务通知不能使用的场景：

- 向ISR发送事件或数据

  通信对象可以用于从ISR向任务发送事件和数据，也可以从任务向ISR发送事件和数据。

  任务通知可以用于从ISR向任务发送事件和数据，但不能用于从任务向ISR发送事件或数据。

- 启用多个接收任务

  通信对象可以被任何知道其句柄（可能是队列句柄、信号量句柄或事件组句柄）的任务或ISR访问。任何数量的任务和ISR都可以处理发送到任何给定通信对象的事件或数据。

  任务通知直接发送到接收任务，因此只能由接收通知的任务处理。然而，这在实际情况下很少是一个限制，因为虽然有多个任务和ISR发送到同一个通信对象是常见的，但有多个任务和ISR接收同一个通信对象的数据是罕见的。

- 缓冲多个数据项

  队列是一种可以同时保存多个数据项的通信对象。发送到队列但尚未从队列接收的数据被缓存在队列对象内。

  任务通知通过更新接收任务的通知值将数据发送到任务。任务的通知值只能保存一个值。

- 广播到多个任务

  事件组是一种可以用于一次向多个任务发送事件的通信对象。

  任务通知直接发送到接收任务，因此只能由接收任务处理。

- 在阻塞状态下等待发送完成

  如果通信对象暂时处于无法写入更多数据或事件的状态（例如，当队列已满时，无法向队列发送更多数据），则尝试写入对象的任务可以选择进入阻塞状态，等待其写操作完成。

  如果一个任务尝试向已经有通知挂起的任务发送任务通知，则发送任务无法在阻塞状态下等待接收任务重置其通知状态。正如将看到的，这在实际使用任务通知的情况下很少是一个限制。

## 10.3 使用任务通知

### 10.3.1 任务通知API选项

任务通知是一种非常强大的功能，通常可以替代二进制信号量、计数信号量、事件组，有时甚至是队列。通过使用`xTaskNotify()` API函数发送任务通知，以及使用`xTaskNotifyWait()` API函数接收任务通知，可以实现这一广泛的使用场景。

然而，在大多数情况下，`xTaskNotify()` 和 `xTaskNotifyWait()` API函数提供的全部灵活性并不是必需的，更简单的函数就足够了。因此，提供了`xTaskNotifyGive()` API函数作为`xTaskNotify()`的一种更简单但灵活性较低的替代品，以及`ulTaskNotifyTake()` API函数作为`xTaskNotifyWait()`的一种更简单但灵活性较低的替代品。

任务通知系统不限于单个通知事件。配置参数`configTASK_NOTIFICATION_ARRAY_ENTRIES`默认设置为1。如果将其设置为大于1的值，则在每个任务内部创建一个通知数组。这允许通过索引管理通知。每个任务通知API函数都有一个带索引的版本。使用非索引版本将访问通知[0]（数组中的第一个）。每个API函数的带索引版本都以后缀`Indexed`标识，因此函数`xTaskNotify`变为`xTaskNotifyIndexed`。为了简化，本书中将仅使用每个函数的非索引版本。

任务通知API实现为宏，这些宏调用每种API函数类型的底层`Generic`版本。为了简化，本书中将称这些API宏为函数。

#### 10.3.1.1 API函数的完整列表 <sup>27</sup>

- `xTaskNotifyGive`
- `xTaskNotifyGiveIndexed`
- `vTaskNotifyGiveFromISR`
- `vTaskNotifyGiveIndexedFromISR`
- `vTaskNotifyTake`
- `vTaskNotifyTakeIndexed`
- `xTaskNotify`
- `xTaskNotifyIndexed`
- `xTaskNotifyWait`
- `xTaskNotifyWaitIndexed`
- `xTaskNotifyStateClear`
- `xTaskNotifyStateClearIndexed`
- `ulTaskNotifyValueClear`
- `ulTaskNotifyValueClearIndexed`
- `xTaskNotifyAndQueryIndexedFromISR`
- `xTaskNotifyAndQueryFromISR`
- `xTaskNotifyFromISR`
- `xTaskNotifyIndexedFromISR`
- `xTaskNotifyAndQuery`
- `xTaskNotifyAndQueryIndexed`

*(27): 这些函数实际上是作为宏实现的。*

>注意：`FromISR`函数不存在于接收通知的情况下，因为通知总是发送给一个任务，而中断与任何任务都没有关联。

### 10.3.2 xTaskNotifyGive() API函数

`xTaskNotifyGive()` 直接向任务发送通知，并增加接收任务的通知值。调用 `xTaskNotifyGive()` 将设置接收任务的通知状态为挂起，如果它尚未挂起。

`xTaskNotifyGive()` API函数提供了允许任务通知作为二进制或计数信号量的更轻量级和更快的替代方案。

<a name="list10.1" title="清单 10.1 xTaskNotifyGive() API函数原型"></a>

```c
BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );
BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify );
```

***清单 10.1*** *xTaskNotifyGive() API函数原型*

**xTaskNotifyGive()/xTaskNotifyGiveIndexed() 参数和返回值**

- `xTaskToNotify`

  通知被发送到的任务的句柄—有关获取任务句柄的信息，请参阅 `xTaskCreate()` API函数的 `pxCreatedTask` 参数。

- `uxIndexToNotify`

  数组的索引

- 返回值

  `xTaskNotifyGive()` 是一个调用 `xTaskNotify()` 的宏。宏传递给 `xTaskNotify()` 的参数设置为 `pdPASS` 是唯一可能的返回值。`xTaskNotify()` 将在本书后面描述。

### 10.3.3 vTaskNotifyGiveFromISR() API 函数

`vTaskNotifyGiveFromISR()` 是 `xTaskNotifyGive()` 的一个版本，可以在中断服务例程中使用。

<a name="list10.2" title="Listing 10.2 The vTaskNotifyGiveFromISR() API function prototype"></a>

```c
void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                             BaseType_t *pxHigherPriorityTaskWoken );
```

***Listing 10.2*** *vTaskNotifyGiveFromISR() API 函数原型*

**vTaskNotifyGiveFromISR() 参数和返回值**

- `xTaskToNotify`

  要发送通知的任务的句柄—有关获取任务句柄的信息，请参阅 `xTaskCreate()` API 函数的 `pxCreatedTask` 参数。

- `pxHigherPriorityTaskWoken`

  如果要发送通知的任务正在阻塞状态等待接收通知，那么发送通知将导致任务离开阻塞状态。

  如果调用 `vTaskNotifyGiveFromISR()` 导致任务离开阻塞状态，并且解除阻塞的任务的优先级高于当前正在执行的任务（被中断的任务），那么在内部，`vTaskNotifyGiveFromISR()` 将 `*pxHigherPriorityTaskWoken` 设置为 `pdTRUE`。

  如果 `vTaskNotifyGiveFromISR()` 将此值设置为 `pdTRUE`，那么在退出中断之前应执行上下文切换。这将确保中断直接返回到优先级最高的就绪状态任务。

  与所有中断安全的 API 函数一样，在使用之前必须将 `pxHigherPriorityTaskWoken` 参数设置为 `pdFALSE`。

### 10.3.4 ulTaskNotifyTake() API 函数

`ulTaskNotifyTake()` 允许一个任务在阻塞状态下等待其通知值大于零，并在返回之前递减（从中减去一个）或清除任务的通知值。

`ulTaskNotifyTake()` API 函数提供了一种更轻量级和更快速的替代方案，用于任务通知，而不是二进制或计数信号量。

<a name="list10.3" title="Listing 10.3 The ulTaskNotifyTake() API function prototype"></a>

```c
uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t
xTicksToWait );
```

***Listing 10.3*** *The ulTaskNotifyTake() API function prototype*

**ulTaskNotifyTake() 参数和返回值**

- `xClearCountOnExit`

  如果 `xClearCountOnExit` 设置为 `pdTRUE`，那么在调用 `ulTaskNotifyTake()` 返回之前，调用任务的通知值将被清零。

  如果 `xClearCountOnExit` 设置为 `pdFALSE`，并且调用任务的通知值大于零，那么在调用 `ulTaskNotifyTake()` 返回之前，调用任务的通知值将被递减。

- `xTicksToWait`

  调用任务在阻塞状态下等待其通知值大于零的最大时间。

  阻塞时间以滴答周期指定，因此它所代表的绝对时间取决于滴答频率。可以使用宏 `pdMS_TO_TICKS()` 将以毫秒指定的时间转换为以滴答指定的时间。

  将 `xTicksToWait` 设置为 `portMAX_DELAY` 将导致任务无限期等待（不会超时），前提是 `INCLUDE_vTaskSuspend` 在 `FreeRTOSConfig.h` 中设置为 1。

- 返回值

  返回值是调用任务的通知值，在其被清零或递减之前，具体取决于 `xClearCountOnExit` 参数的值。

  如果指定了阻塞时间（`xTicksToWait` 不为零），并且返回值不为零，那么可能调用任务被放置在阻塞状态下等待其通知值大于零，并且在阻塞时间到期之前更新了其通知值。

如果指定了阻塞时间（`xTicksToWait` 不为零），并且返回值为零，那么调用任务被放置到阻塞状态以等待其通知值大于零，但在此之前指定的阻塞时间已过期。

<a name="example10.1" title="示例 10.1 使用任务通知代替信号量，方法 1"></a>
---
***示例 10.1*** *使用任务通知代替信号量，方法 1*

---

示例 7.1 使用了一个二进制信号量来在中断服务例程中解除任务的阻塞状态——从而将任务与中断同步。本示例复制了示例 7.1 的功能，但使用直接任务通知代替二进制信号量。

清单 10.4 显示了与中断同步的任务的实现。示例 7.1 中使用的 `xSemaphoreTake()` 调用已被 `ulTaskNotifyTake()` 调用替换。

`ulTaskNotifyTake()` 的 `xClearCountOnExit` 参数设置为 `pdTRUE`，这导致接收任务的通知值在 `ulTaskNotifyTake()` 返回之前被清零。因此，在每次调用 `ulTaskNotifyTake()` 之间必须处理所有已有的事件。在示例 7.1 中，因为使用了二进制信号量，因此必须从硬件中确定待处理事件的数量，这并不总是可行。在示例 10.1 中，待处理事件的数量是从 `ulTaskNotifyTake()` 返回的。

在调用 `ulTaskNotifyTake` 之间发生的中断事件会被锁存在任务的通知值中，如果调用任务已经有待处理的通知，则调用 `ulTaskNotifyTake()` 将立即返回。

<a name="list10.4" title="Listing 10.4 The implementation of the task to which the interrupt processing is deferred (the task that..."></a>

```c
/* 定期任务生成软件中断的频率。 */
const TickType_t xInterruptFrequency = pdMS_TO_TICKS( 500UL );

static void vHandlerTask( void *pvParameters )
{
    /* xMaxExpectedBlockTime 设置为稍长于事件之间的最大预期时间。 */
    const TickType_t xMaxExpectedBlockTime = xInterruptFrequency +
                                             pdMS_TO_TICKS( 10 );
    uint32_t ulEventsToProcess;

    /* 与大多数任务一样，此任务在无限循环中实现。 */
    for( ;; )
    {
        /* 等待接收从中断服务例程直接发送到此任务的通知。 */
        ulEventsToProcess = ulTaskNotifyTake( pdTRUE, xMaxExpectedBlockTime );
        if( ulEventsToProcess != 0 )
        {
            /* 至少发生了一次事件才能到达这里。在此循环，直到所有待处理的事件都已处理（在这种情况下，只需为每个事件打印一条消息）。 */
            while( ulEventsToProcess > 0 )
            {
                vPrintString( "Handler task - Processing event.\r\n" );
                ulEventsToProcess--;
            }
        }
        else
        {
            /* 如果到达此函数的这一部分，则在预期时间内未到达中断，并且（在实际应用程序中）可能需要执行一些错误恢复操作。 */
        }
    }
}
```

***Listing 10.4*** *将中断处理推迟到的任务的实现（与中断同步的任务）在示例 10.1 中*

用于生成软件中断的定期任务在生成中断之前和之后打印一条消息。这允许在生成的输出中观察执行序列。

Listing 10.5 显示了中断处理程序。它几乎没有做什么，除了直接向延迟中断处理的任务发送通知。

<a name="list10.5" title="Listing 10.5 在示例 10.1 中使用的中断服务例程的实现"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
    BaseType_t xHigherPriorityTaskWoken;

    /* xHigherPriorityTaskWoken 参数必须初始化为 pdFALSE，因为它将在中断安全的 API 函数内部设置为 pdTRUE，如果需要上下文切换。 */
    xHigherPriorityTaskWoken = pdFALSE;

    /* 直接向延迟中断处理的任务发送通知。 */
    vTaskNotifyGiveFromISR( /* 发送通知的任务的句柄。句柄在创建任务时保存。 */
                            xHandlerTask,

                            /* xHigherPriorityTaskWoken 以通常的方式使用。 */
                            &xHigherPriorityTaskWoken );

    /* 将 xHigherPriorityTaskWoken 值传递给 portYIELD_FROM_ISR()。如果在 vTaskNotifyGiveFromISR() 中将 xHigherPriorityTaskWoken 设置为 pdTRUE，则调用 portYIELD_FROM_ISR() 将请求上下文切换。如果 xHigherPriorityTaskWoken 仍为 pdFALSE，则调用 portYIELD_FROM_ISR() 将没有效果。Windows 端口使用的 portYIELD_FROM_ISR() 的实现包括一个返回语句，这就是为什么这个函数没有显式返回值的原因。 */
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***Listing 10.5*** *在示例 10.1 中使用的中断服务例程的实现*

当执行示例 10.1 时生成的输出显示在图 10.3 中。如预期的那样，它与执行示例 7.1 时生成的输出相同。`vHandlerTask()` 一旦生成中断就进入运行状态，因此任务的输出分割了周期性任务生成的输出。图 10.4 提供了进一步的解释。

<a name="fig10.3" title="图 10.3 执行示例 7.1 时生成的输出"></a>
<a name="fig10.4" title="图 10.4 执行示例 10.1 时的执行顺序"></a>

* * *
![](media/image78.png)
***图 10.3*** *执行示例 7.1 时生成的输出*

![](media/image79.png)
***图 10.4*** *执行示例 10.1 时的执行顺序*
* * *

<a name="example10.2" title="示例 10.2 使用任务通知代替信号量，方法 2"></a>
---
***示例 10.2*** *使用任务通知代替信号量，方法 2*

---

在示例 10.1 中，`ulTaskNotifyTake()` 的 `xClearOnExit` 参数设置为 `pdTRUE`。示例 10.1 稍微修改了示例 10.1，以演示当 `ulTaskNotifyTake()` 的 `xClearOnExit` 参数设置为 `pdFALSE` 时的行为。

当 `xClearOnExit` 为 `pdFALSE` 时，调用 `ulTaskNotifyTake()` 只会递减（减少一个）调用任务的通知值，而不是将其清零。因此，通知计数是发生的事件数与已处理的事件数之差。这使得 `vHandlerTask()` 的结构可以在两个方面简化：

1. 等待处理的事件数保存在通知值中，因此不需要保存在局部变量中。

2. 在每次调用 `ulTaskNotifyTake()` 之间，只需要处理一个事件。

示例 10.2 中使用的 `vHandlerTask()` 的实现如清单 10.6 所示。

<a name="list10.6" title="清单 10.6 中断处理延迟到的任务的实现（与中断同步的任务..."></a>

```c
static void vHandlerTask( void *pvParameters )
{
    /* xMaxExpectedBlockTime 设置为稍长于事件之间的最大预期时间。 */
    const TickType_t xMaxExpectedBlockTime = xInterruptFrequency +
                                             pdMS_TO_TICKS( 10 );

    /* 与大多数任务一样，此任务在无限循环中实现。 */
    for( ;; )
    {
        /* 等待接收来自中断服务例程直接发送到此任务的通知。xClearCountOnExit 参数现在为 pdFALSE，因此任务的通知值将由 ulTaskNotifyTake() 减少，而不是清零。 */
        if( ulTaskNotifyTake( pdFALSE, xMaxExpectedBlockTime ) != 0 )
        {
            /* 要到达这里，必须发生一个事件。处理事件（在这种情况下只是打印一条消息）。 */
            vPrintString( "Handler task - Processing event.\r\n" );
        }
        else
        {
            /* 如果到达此函数的这一部分，则在预期时间内未到达中断，并且（在实际应用程序中）可能需要执行一些错误恢复操作。 */
        }
    }
}
```

***清单 10.6*** *示例 10.2 中将中断处理延迟到的任务的实现（与中断同步的任务）*

为了演示目的，中断服务例程还被修改为每次中断发送多个任务通知，从而模拟高频率发生的多个中断。示例 10.2 中使用的中断服务例程的实现如清单 10.7 所示。

<a name="list10.7" title="Listing 10.7 示例 10.2 中使用的中断服务例程的实现"></a>

```c
static uint32_t ulExampleInterruptHandler( void )
{
    BaseType_t xHigherPriorityTaskWoken;

    xHigherPriorityTaskWoken = pdFALSE;

    /* 向处理任务发送多个通知。第一个 'give' 将解锁任务，后续的 'gives' 是为了演示接收任务的通知值被用来计数（捕获）事件 - 允许任务依次处理每个事件。 */
    vTaskNotifyGiveFromISR( xHandlerTask, &xHigherPriorityTaskWoken );
    vTaskNotifyGiveFromISR( xHandlerTask, &xHigherPriorityTaskWoken );
    vTaskNotifyGiveFromISR( xHandlerTask, &xHigherPriorityTaskWoken );

    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***Listing 10.7*** *示例 10.2 中使用的中断服务例程的实现*

执行示例 10.2 时生成的输出如图 10.5 所示。可以看到，`vHandlerTask()` 每次生成中断时都会处理所有三个事件。

<a name="fig10.5" title="图 10.5 执行示例 10.2 时生成的输出"></a>

* * *
![](media/image80.jpg)
***图 10.5*** *执行示例 10.2 时生成的输出*
* * *

### 10.3.5 xTaskNotify() 和 xTaskNotifyFromISR() API 函数

`xTaskNotify()` 是 `xTaskNotifyGive()` 的更强大版本，可以用于以以下方式更新接收任务的通知值：

- 增量（将接收任务的通知值加一），在这种情况下，`xTaskNotify()` 等同于 `xTaskNotifyGive()`。

- 设置接收任务的通知值中的一个或多个位。这允许任务的通知值作为事件组的更轻量级和更快的替代品。

- 将一个全新的数字写入接收任务的通知值，但仅当接收任务自上次更新以来已经读取了其通知值。这使得任务的通知值能够提供与长度为一的队列相似的功能。

- 向接收任务的通知值中写入一个全新的数字，即使接收任务自上次更新以来尚未读取其通知值。这使得任务的通知值能够提供与`xQueueOverwrite()` API函数提供的功能类似的功能。结果行为有时被称为“邮箱”。

`xTaskNotify()`比`xTaskNotifyGive()`更灵活和强大，因此由于这种额外的灵活性和强大功能，它使用起来也稍微复杂一些。

`xTaskNotifyFromISR()`是`xTaskNotify()`的一个版本，可以在中断服务例程中使用，因此它有一个额外的`pxHigherPriorityTaskWoken`参数。

调用`xTaskNotify()`将始终将接收任务的通知状态设置为挂起，如果它尚未挂起。

<a name="list10.8" title="Listing 10.8 Prototypes for the xTaskNotify() and xTaskNotifyFromISR() API functions"></a>

```c
BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify,
                        uint32_t ulValue,
                        eNotifyAction eAction );

BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify,
                               uint32_t ulValue,
                               eNotifyAction eAction,
                               BaseType_t *pxHigherPriorityTaskWoken );
```

***Listing 10.8*** *Prototypes for the xTaskNotify() and xTaskNotifyFromISR() API functions*

**xTaskNotify() 参数和返回值**

- `xTaskToNotify`

  正在发送通知的任务的句柄—有关获取任务句柄的信息，请参阅`xTaskCreate()` API函数的`pxCreatedTask`参数。

- `ulValue`

  `ulValue` 的用法取决于 `eNotifyAction` 的值。请参见下文。

- `eNotifyAction`

  一个枚举类型，指定如何更新接收任务的通知值。请参见下文。

- 返回值

  `xTaskNotify()` 将返回 `pdPASS`，除非在下面提到的那种情况下。

**有效的 `xTaskNotify()` `eNotifyAction` 参数值及其对接收任务通知值的影响**

- `eNoAction`

  接收任务的通知状态被设置为挂起，而不更新其通知值。`xTaskNotify()` 的 `ulValue` 参数未使用。

  `eNoAction` 操作允许任务通知作为二进制信号量的更快、更轻量级的替代方案。

- `eSetBits`

  接收任务的通知值与 `xTaskNotify()` 的 `ulValue` 参数中传递的值进行按位或运算。例如，如果 `ulValue` 设置为 0x01，则接收任务的通知值中位 0 将被设置。再例如，如果 `ulValue` 为 0x06（二进制 0110），则接收任务的通知值中位 1 和位 2 将被设置。

`eSetBits` 操作允许任务通知作为事件组的更快、更轻量级的替代方案。

- `eIncrement`

  接收任务的通知值会增加。`xTaskNotify()` 的 `ulValue` 参数不会被使用。

  `eIncrement` 操作允许任务通知作为二进制信号量或计数信号量的更快、更轻量级的替代方案，并且等同于更简单的 `xTaskNotifyGive()` API 函数。

- `eSetValueWithoutOverwrite`

  如果在调用 `xTaskNotify()` 之前接收任务已经有通知挂起，则不采取任何操作，`xTaskNotify()` 将返回 `pdFAIL`。

  如果在调用 `xTaskNotify()` 之前接收任务没有通知挂起，则接收任务的通知值将设置为 `xTaskNotify()` 的 `ulValue` 参数中传递的值。

- `eSetValueWithOverwrite`

  接收任务的通知值将设置为 `xTaskNotify()` 的 `ulValue` 参数中传递的值，无论在调用 `xTaskNotify()` 之前接收任务是否已经有通知挂起。

### 10.3.6 xTaskNotifyWait() API 函数

`xTaskNotifyWait()` 是 `ulTaskNotifyTake()` 的更强大版本。它允许一个任务在调用任务的通知状态变为待处理之前等待，如果它还没有待处理的话。`xTaskNotifyWait()` 提供了在进入函数和退出函数时清除调用任务通知值中的位的选项。

<a name="list10.9" title="Listing 10.9 The xTaskNotifyWait() API function prototype"></a>

```c
BaseType_t xTaskNotifyWait( uint32_t   ulBitsToClearOnEntry,
                            uint32_t   ulBitsToClearOnExit,
                            uint32_t   *pulNotificationValue,
                            TickType_t xTicksToWait );
```

***Listing 10.9*** *The xTaskNotifyWait() API function prototype*

**xTaskNotifyWait() 参数和返回值**

- `ulBitsToClearOnEntry`

  如果调用任务在调用 `xTaskNotifyWait()` 之前没有通知待处理，那么 `ulBitsToClearOnEntry` 中设置的任何位都将在进入函数时清除任务的通知值。

例如，如果 `ulBitsToClearOnEntry` 为 0x01，则任务的通知值的位 0 将被清除。另一个例子是，将 `ulBitsToClearOnEntry` 设置为 0xffffffff (`ULONG_MAX`) 将清除任务通知值中的所有位，从而将值清零。

- `ulBitsToClearOnExit`

  如果调用任务因为收到通知而退出 `xTaskNotifyWait()`，或者在调用 `xTaskNotifyWait()` 时已经有一个通知挂起，那么 `ulBitsToClearOnExit` 中设置的任何位都将在任务退出 `xTaskNotifyWait()` 函数之前被清除。

  位在任务的通知值被保存到 `*pulNotificationValue` 之后被清除（见下面对 `pulNotificationValue` 的描述）。

  例如，如果 `ulBitsToClearOnExit` 为 0x03，则任务的通知值的位 0 和位 1 将在函数退出之前被清除。

  将 `ulBitsToClearOnExit` 设置为 0xffffffff (`ULONG_MAX`) 将清除任务通知值中的所有位，从而将值清零。

- `pulNotificationValue`

  用于传递任务的通知值。复制到 `*pulNotificationValue` 的值是任务的通知值，在任何位被 `ulBitsToClearOnExit` 设置清除之前的值。

  `pulNotificationValue` 是一个可选参数，如果不需要可以设置为 NULL。

- `xTicksToWait`

  调用任务在阻塞状态下等待其通知状态变为挂起的最大时间。

  阻塞时间以滴答周期指定，因此它所代表的绝对时间取决于滴答频率。可以使用宏 `pdMS_TO_TICKS()` 将以毫秒指定的时间转换为以滴答指定的时间。

  将 `xTicksToWait` 设置为 `portMAX_DELAY` 将导致任务无限期等待（不会超时），前提是 `INCLUDE_vTaskSuspend` 在 `FreeRTOSConfig.h` 中设置为 1。

- 返回值

  有两种可能的返回值：

  - `pdTRUE`

    这表明 `xTaskNotifyWait()` 返回是因为收到了通知，或者在调用 `xTaskNotifyWait()` 时调用任务已经有一个通知挂起。

如果指定了一个阻塞时间（`xTicksToWait` 不为零），那么可能会将调用任务放入阻塞状态，以等待其通知状态变为待定，但其通知状态在阻塞时间到期之前就被设置为待定。

  - `pdFALSE`

    这表明 `xTaskNotifyWait()` 在调用任务未接收到任务通知的情况下返回。

    如果 `xTicksToWait` 不为零，那么调用任务将被保持在阻塞状态，以等待其通知状态变为待定，但指定的阻塞时间在发生之前就过期了。

### 10.3.7 任务通知用于外围设备驱动程序：UART示例

外围设备驱动程序库提供执行硬件接口常见操作的函数。常为其提供库的外围设备示例包括通用异步接收器和发送器（UARTs）、串行外围接口（SPI）端口、模拟到数字转换器（ADCs）和以太网端口。此类库通常提供的函数示例包括初始化外围设备、向外围设备发送数据和从外围设备接收数据的函数。

一些外设操作需要相对较长的时间才能完成。例如，高精度ADC转换和通过UART传输大数据包。在这种情况下，驱动程序库函数可以实现为轮询（重复读取）外设的状态寄存器，以确定操作何时完成。然而，这种方式的轮询几乎总是浪费的，因为它在没有执行任何有效处理的情况下占用了处理器的100%时间。这种浪费在多任务系统中尤为昂贵，因为一个轮询外设的任务可能会阻止执行一个具有有效处理的较低优先级任务。

为了避免潜在的处理时间浪费，高效的RTOS感知设备驱动程序应该是中断驱动的，并使启动长时间操作的任务有选择地在Blocked状态下等待操作完成。这样，当执行长时间操作的任务处于Blocked状态时，较低优先级的任务可以执行，并且只有在可以有效使用处理时间时才使用处理时间。

通常，RTOS感知的驱动库会使用二进制信号量将任务置于阻塞状态。这种技术在列表10.10中的伪代码中得到了演示，该伪代码提供了一个在UART端口上传输数据的RTOS感知库函数的概述。在列表10.10中：

- `xUART` 是一个描述UART外围设备并保存状态信息的结构体。结构体的 `xTxSemaphore` 成员是 `SemaphoreHandle_t` 类型的变量。假设信号量已经被创建。

- `xUART_Send()` 函数不包括任何互斥逻辑。如果有多个任务将使用 `xUART_Send()` 函数，那么应用程序编写者必须在应用程序本身中管理互斥。例如，任务可能需要在调用 `xUART_Send()` 之前获取一个互斥锁。

- `xSemaphoreTake()` API函数用于在UART传输启动后将调用任务置于阻塞状态。

- `xSemaphoreGiveFromISR()` API函数用于在传输完成后将任务从阻塞状态移除，即当UART外设的传输结束中断服务例程执行时。

<a name="list10.10" title="Listing 10.10 Pseudo code demonstrating how a binary semaphore can be used in a driver library transmit..."></a>

```c
/* Driver library function to send data to a UART. */

BaseType_t xUART_Send( xUART *pxUARTInstance,
                       uint8_t *pucDataSource,
                       size_t uxLength )
{
    BaseType_t xReturn;

    /* Ensure the UART's transmit semaphore is not already available by
       attempting to take the semaphore without a timeout. */
    xSemaphoreTake( pxUARTInstance->xTxSemaphore, 0 );

    /* Start the transmission. */
    UART_low_level_send( pxUARTInstance, pucDataSource, uxLength );

    /* Block on the semaphore to wait for the transmission to complete. If
       the semaphore is obtained then xReturn will get set to pdPASS. If the
       semaphore take operation times out then xReturn will get set to pdFAIL.
       Note that, if the interrupt occurs between UART_low_level_send() being
       called, and xSemaphoreTake() being called, then the event will be
       latched in the binary semaphore, and the call to xSemaphoreTake() will
       return immediately. */
    xReturn = xSemaphoreTake( pxUARTInstance->xTxSemaphore,
                              pxUARTInstance->xTxTimeout );

    return xReturn;
}
/*-----------------------------------------------------------*/

/* The service routine for the UART's transmit end interrupt, which executes
   after the last byte has been sent to the UART. */
void xUART_TransmitEndISR( xUART *pxUARTInstance )
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    /* Clear the interrupt. */
    UART_low_level_interrupt_clear( pxUARTInstance );

    /* Give the Tx semaphore to signal the end of the transmission. If a task
       is Blocked waiting for the semaphore then the task will be removed from
       the Blocked state. */
    xSemaphoreGiveFromISR( pxUARTInstance->xTxSemaphore,
                           &xHigherPriorityTaskWoken );
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***Listing 10.10*** *Pseudo code demonstrating how a binary semaphore can be used in a driver library transmit function*

Listing 10.10中展示的技术是可行的，实际上也是常见的做法，但它有一些缺点：

- 库使用多个信号量，这增加了其RAM占用量。

- 信号量在创建之前不能使用，因此使用信号量的库在显式初始化之前不能使用。

- 信号量是通用对象，适用于广泛的用例；它们包括逻辑，允许任意数量的任务在阻塞状态下等待信号量可用，并在信号量可用时以确定性方式选择从阻塞状态中移除哪个任务。执行该逻辑需要有限的时间，并且该处理开销在列表10.10所示的场景中是不必要的，在这种情况下，任何给定时间都不能有多个任务等待信号量。

列表10.11演示了如何通过使用任务通知而不是二进制信号量来避免这些缺点。

> *注意：如果库使用任务通知，则库的文档必须明确说明调用库函数可以更改调用任务的通知状态和通知值。*

在列表10.11中：

- `xUART`结构的`xTxSemaphore`成员已被`xTaskToNotify`成员替换。`xTaskToNotify`是`TaskHandle_t`类型的变量，用于保存等待UART操作完成的任务的句柄。

- FreeRTOS API函数`xTaskGetCurrentTaskHandle()`用于获取当前处于运行状态的任务的句柄。

- 该库不创建任何FreeRTOS对象，因此不会增加RAM开销，也不需要显式初始化。

- 任务通知直接发送到等待UART操作完成的任务，因此不会执行不必要的逻辑。

`xUART`结构的`xTaskToNotify`成员从任务和中断服务例程中访问，因此需要考虑处理器如何更新其值：

- 如果通过单个内存写操作更新`xTaskToNotify`，则可以在关键部分之外更新它，就像在清单10.11中所示的那样。如果`xTaskToNotify`是一个32位变量（`TaskHandle_t`是一个32位类型），并且运行FreeRTOS的处理器是一个32位处理器，则会出现这种情况。

- 如果需要多个内存写操作来更新`xTaskToNotify`，则必须在关键部分内更新`xTaskToNotify`，否则中断服务例程可能会在其处于不一致状态时访问`xTaskToNotify`。如果`xTaskToNotify`是一个32位变量，并且运行FreeRTOS的处理器是一个16位处理器，则会出现这种情况，因为需要两个16位内存写操作来更新所有32位。

在FreeRTOS实现内部，`TaskHandle_t` 是一个指针，因此 `sizeof( TaskHandle_t )` 总是等于 `sizeof( void * )`。

<a name="list10.11" title="Listing 10.11 Pseudo code demonstrating how a task notification can be used in a driver library transmit..."></a>

```c
/* 发送数据到UART的驱动库函数。 */
BaseType_t xUART_Send( xUART *pxUARTInstance,
                       uint8_t *pucDataSource,
                       size_t uxLength )
{
    BaseType_t xReturn;

    /* 保存调用此函数的任务的句柄。书中包含是否需要用关键部分保护以下行的注释。 */
    pxUARTInstance->xTaskToNotify = xTaskGetCurrentTaskHandle();

    /* 通过调用ulTaskNotifyTake()，确保调用任务没有挂起的通知，xClearCountOnExit参数设置为pdTRUE，阻塞时间为0（不阻塞）。 */
    ulTaskNotifyTake( pdTRUE, 0 );

    /* 开始传输。 */
    UART_low_level_send( pxUARTInstance, pucDataSource, uxLength );

    /* 阻塞直到通知传输完成。如果接收到通知，则xReturn将被设置为1，因为ISR将此任务的通知值增加到1（pdTRUE）。如果操作超时，则xReturn将为0（pdFALSE），因为此任务的通知值自上次清零以来未更改。请注意，如果ISR在调用UART_low_level_send()和调用ulTaskNotifyTake()之间执行，则事件将被锁定在任务的通知值中，并且ulTaskNotifyTake()将立即返回。 */
    xReturn = ( BaseType_t ) ulTaskNotifyTake( pdTRUE,
                                               pxUARTInstance->xTxTimeout );

    return xReturn;
}
/*-----------------------------------------------------------*/

/* 在最后一个字节发送到UART后执行的ISR。 */
void xUART_TransmitEndISR( xUART *pxUARTInstance )
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    /* 此函数不应执行，除非有任务等待通知。使用assert测试此条件。此步骤并非严格必要，但将有助于调试。configASSERT()在12.2节中描述。 */
    configASSERT( pxUARTInstance->xTaskToNotify != NULL );

    /* 清除中断。 */
    UART_low_level_interrupt_clear( pxUARTInstance );

    /* 直接向调用xUART_Send()的任务发送通知。如果任务被阻塞等待通知，则任务将从阻塞状态中移除。 */
    vTaskNotifyGiveFromISR( pxUARTInstance->xTaskToNotify,
                            &xHigherPriorityTaskWoken );

    /* 现在没有任务等待通知。将xUART结构的xTaskToNotify成员设置回NULL。此步骤并非严格必要，但将有助于调试。 */
    pxUARTInstance->xTaskToNotify = NULL;
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***清单 10.11*** *伪代码演示如何在驱动程序库的传输函数中使用任务通知*

任务通知也可以在接收函数中替代信号量，如伪代码清单 10.12 所示，该清单提供了一个RTOS感知库函数的大纲，该函数通过UART端口接收数据。参考清单 10.12：

- `xUART_Receive()` 函数不包括任何互斥逻辑。如果有多个任务将使用 `xUART_Receive()` 函数，那么应用程序编写者将不得不在应用程序本身中管理互斥。例如，任务可能需要在调用 `xUART_Receive()` 之前获取一个互斥锁。

- UART的接收中断服务例程将UART接收到的字符放入RAM缓冲区。`xUART_Receive()` 函数从RAM缓冲区返回字符。

- `xUART_Receive()` 的 `uxWantedBytes` 参数用于指定要接收的字符数。如果RAM缓冲区尚未包含请求的字符数，则调用任务将被放置到阻塞状态，以等待通知缓冲区中的字符数增加。`while()` 循环用于重复此序列，直到接收缓冲区包含请求的字符数，或者发生超时。

- 调用任务可能会多次进入阻塞状态。因此，阻塞时间会相应调整，以考虑自 `xUART_Receive()` 被调用以来已经过去的时间。这些调整确保在 `xUART_Receive()` 内部花费的总时间不会超过 `xUART` 结构的 `xRxTimeout` 成员指定的阻塞时间。阻塞时间使用 FreeRTOS 的 `vTaskSetTimeOutState()` 和 `xTaskCheckForTimeOut()` 辅助函数进行调整。

<a name="list10.12" title="Listing 10.12 Pseudo code demonstrating how a task notification can be used in a driver library receive..."></a>


```c
/* 从UART接收数据的驱动库函数。 */

size_t xUART_Receive( xUART *pxUARTInstance,
                      uint8_t *pucBuffer,
                      size_t uxWantedBytes )
{
    size_t uxReceived = 0;
    TickType_t xTicksToWait;
    TimeOut_t xTimeOut;

    /* 记录进入此函数的时间。 */
    vTaskSetTimeOutState( &xTimeOut );

    /* xTicksToWait 是超时值 - 初始设置为此UART实例的最大接收超时。 */
    xTicksToWait = pxUARTInstance->xRxTimeout;

    /* 保存调用此函数的任务的句柄。书中包含是否需要用关键部分保护以下行的注释。 */
    pxUARTInstance->xTaskToNotify = xTaskGetCurrentTaskHandle();

    /* 循环，直到缓冲区包含所需的字节数，或者发生超时。 */
    while( UART_bytes_in_rx_buffer( pxUARTInstance ) < uxWantedBytes )
    {
        /* 查找超时，调整 xTicksToWait 以考虑到迄今为止在此函数中花费的时间。 */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) != pdFALSE )
        {
            /* 在所需的字节数可用之前超时，退出循环。 */
            break;
        }

        /* 接收缓冲区尚未包含所需的字节数。等待最多 xTicksToWait 个时钟周期，通知接收中断服务例程将更多数据放入缓冲区。如果调用此函数的任务已经有一个通知挂起，它将只是在这个 while 循环中多迭代一次。 */
        ulTaskNotifyTake( pdTRUE, xTicksToWait );
    }

    /* 没有任务在等待接收通知，因此将 xTaskToNotify 设置回 NULL。书中包含是否需要用关键部分保护以下行的注释。 */
    pxUARTInstance->xTaskToNotify = NULL;

    /* 尝试从接收缓冲区读取 uxWantedBytes 到 pucBuffer。实际读取的字节数（可能小于 uxWantedBytes）将被返回。 */
    uxReceived = UART_read_from_receive_buffer( pxUARTInstance,
                                                pucBuffer,
                                                uxWantedBytes );
    return uxReceived;
}

/*-----------------------------------------------------------*/

/* UART 接收中断的中断服务例程 */
void xUART_ReceiveISR( xUART *pxUARTInstance )
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    /* 将接收到的数据复制到此UART的接收缓冲区并清除中断。 */
    UART_low_level_receive( pxUARTInstance );

    /* 如果有一个任务在等待通知新数据，则现在通知它。 */
```
```c
    if( pxUARTInstance->xTaskToNotify != NULL )
    {
        vTaskNotifyGiveFromISR( pxUARTInstance->xTaskToNotify,
                                &xHigherPriorityTaskWoken );
        portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
    }
}
```

***清单 10.12*** *演示如何在驱动程序接收函数中使用任务通知的伪代码*

### 10.3.8 任务通知在外设设备驱动程序中的使用：ADC示例

前一节演示了如何使用 `vTaskNotifyGiveFromISR()` 从中断发送任务通知到任务。
`vTaskNotifyGiveFromISR()` 是一个简单的函数，但其功能有限；它只能发送一个无值事件的任务通知，不能发送数据。本节演示如何使用 `xTaskNotifyFromISR()` 与任务通知事件一起发送数据。该技术由清单 10.13 中显示的伪代码演示，该伪代码提供了模拟RTOS的中断服务例程的框架，用于模数转换器（ADC）。在清单 10.13 中：

- 假设至少每50毫秒启动一次ADC转换。

- `ADC_ConversionEndISR()` 是 ADC 转换结束中断的中断服务例程，这是每次有新的 ADC 值可用时执行的中断。

- `vADCTask()` 实现的任务处理每个由 ADC 生成的值。假设在创建任务时，任务的句柄已存储在 `xADCTaskToNotify` 中。

- `ADC_ConversionEndISR()` 使用 `xTaskNotifyFromISR()`，并将 `eAction` 参数设置为 `eSetValueWithoutOverwrite`，向 `vADCTask()` 任务发送任务通知，并将 ADC 转换的结果写入任务的通知值。

- `vADCTask()` 任务使用 `xTaskNotifyWait()` 等待被通知新的 ADC 值可用，并从其通知值中检索 ADC 转换的结果。

<a name="list10.13" title="Listing 10.13 Pseudo code demonstrating how a task notification can be used to pass a value to a task"></a>

```c
/* 使用ADC的任务。 */
void vADCTask( void *pvParameters )
{
    uint32_t ulADCValue;
    BaseType_t xResult;

    /* 触发ADC转换的频率。 */
    const TickType_t xADCConversionFrequency = pdMS_TO_TICKS( 50 );

    for( ;; )
    {
        /* 等待下一个ADC转换结果。 */
        xResult = xTaskNotifyWait(
                    /* 新的ADC值将覆盖旧值，因此在等待新通知值之前无需清除任何位。 */
                    0,
                    /* 未来的ADC值将覆盖现有值，因此在退出xTaskNotifyWait()之前无需清除任何位。 */
                    0,
                    /* 任务的通知值（保存最新的ADC转换结果）将被复制到的变量的地址。 */
                    &ulADCValue,
                    /* 应该每xADCConversionFrequency个时钟周期接收一个新的ADC值。 */
                    xADCConversionFrequency * 2 );

        if( xResult == pdPASS )
        {
            /* 接收到新的ADC值。现在处理它。 */
            ProcessADCResult( ulADCValue );
        }
        else
        {
            /* xTaskNotifyWait()的调用没有在预期时间内返回，输入触发ADC转换或ADC本身可能出现问题。在此处理错误。 */
        }
    }
}

/*-----------------------------------------------------------*/

/* 每次ADC转换完成时执行的中断服务例程。 */
void ADC_ConversionEndISR( xADC *pxADCInstance )
{
    uint32_t ulConversionResult;
    BaseType_t xHigherPriorityTaskWoken = pdFALSE, xResult;

    /* 读取新的ADC值并清除中断。 */
    ulConversionResult = ADC_low_level_read( pxADCInstance );

    /* 直接将通知和ADC转换结果发送到vADCTask()。 */
    xResult = xTaskNotifyFromISR( xADCTaskToNotify, /* xTaskToNotify参数 */
                                  ulConversionResult, /* ulValue参数 */
                                  eSetValueWithoutOverwrite, /* eAction参数。 */
                                  &xHigherPriorityTaskWoken );

    /* 如果xTaskNotifyFromISR()的调用返回pdFAIL，则任务无法跟上生成ADC值的速率。configASSERT()在11.2节中描述。 */
    configASSERT( xResult == pdPASS );
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
```

***清单 10.13*** *伪代码演示如何使用任务通知将值传递给任务*

### 10.3.9 在应用程序中直接使用任务通知

本节通过演示任务通知在一个假设应用程序中的使用，进一步强调了任务通知的强大功能。该应用程序包括以下功能：

- 应用程序通过慢速互联网连接与远程数据服务器通信，向其发送数据并请求数据。从这里开始，远程数据服务器被称为*云服务器*。

- 在从云服务器请求数据后，请求任务必须处于阻塞状态，等待请求的数据被接收。

- 在向云服务器发送数据后，发送任务必须处于阻塞状态，等待云服务器正确接收数据的确认。

图10.6显示了软件设计的示意图。在图10.6中：

- 处理多个互联网连接到云服务器的复杂性被封装在一个单独的FreeRTOS任务中。该任务在FreeRTOS应用程序中充当代理服务器，并称为*服务器任务*。

- 应用程序任务通过调用 `CloudRead()` 从云服务器读取数据。`CloudRead()` 不直接与云服务器通信，而是将读取请求发送到服务器任务的队列，并从服务器任务接收请求的数据作为任务通知。

- 应用程序任务通过调用 `CloudWrite()` 向云服务器写入数据。`CloudWrite()` 不直接与云服务器通信，而是将写入请求发送到服务器任务的队列，并从服务器任务接收写入操作的结果作为任务通知。

`CloudRead()` 和 `CloudWrite()` 函数发送到服务器任务的结构如清单 10.14 所示。

<a name="fig10.6" title="图 10.6 应用程序任务与云服务器之间的通信路径，以及返回路径"></a>

* * *
![](media/image81.png)
***图 10.6*** *应用程序任务与云服务器之间的通信路径，以及返回路径*
* * *

<a name="list10.14" title="清单 10.14 发送到服务器任务队列的结构和数据类型"></a>

```c
typedef enum CloudOperations
{
    eRead, /* 将数据发送到云服务器。 */
    eWrite /* 从云服务器接收数据。 */
} Operation_t;

typedef struct CloudCommand
{
    Operation_t eOperation; /* 要执行的操作（读取或写入）。 */
    uint32_t ulDataID; /* 标识正在读取或写入的数据。 */
    uint32_t ulDataValue; /* 仅在将数据写入云服务器时使用。 */
    TaskHandle_t xTaskToNotify;/* 执行操作的任务的句柄。 */
} CloudCommand_t;
```

***清单 10.14*** *发送到服务器任务队列的结构和数据类型*

`CloudRead()` 的伪代码如清单 10.15 所示。该函数将其请求发送到服务器任务，然后调用 `xTaskNotifyWait()` 等待，直到被通知请求的数据可用。

伪代码展示了服务器任务如何管理读取请求，如清单10.16所示。当数据从云服务器接收到时，服务器任务解除应用程序任务的阻塞，并通过调用`xTaskNotify()`（将`eAction`参数设置为`eSetValueWithOverwrite`）将接收到的数据发送到应用程序任务。

清单10.16展示了一个简化的场景，因为它假设`GetCloudData()`不需要等待从云服务器获取值。

<a name="list10.15" title="清单10.15 云读取API函数的实现"></a>

```c
/* ulDataID标识要读取的数据。pulValue保存要将从云服务器接收到的数据写入的变量的地址。 */
BaseType_t CloudRead( uint32_t ulDataID, uint32_t *pulValue )
{
    CloudCommand_t xRequest;
    BaseType_t xReturn;

    /* 设置CloudCommand_t结构体的成员，以便适用于此读取请求。 */
    xRequest.eOperation = eRead; /* 这是一个读取数据的请求。 */
    xRequest.ulDataID = ulDataID; /* 标识要读取的数据的代码。 */
    xRequest.xTaskToNotify = xTaskGetCurrentTaskHandle(); /* 调用任务的句柄。 */

    /* 通过使用阻塞时间为0的通知值读取通知值，确保没有挂起的通知，然后将结构发送到服务器任务。 */
    xTaskNotifyWait( 0, 0, NULL, 0 );
    xQueueSend( xServerTaskQueue, &xRequest, portMAX_DELAY );

    /* 等待来自服务器任务的通知。服务器任务将从云服务器接收到的值直接写入此任务的通知值，因此在进入或退出xTaskNotifyWait()函数时无需清除通知值中的任何位。接收到的值写入*pulValue，因此pulValue作为通知值写入的地址传递。 */
    xReturn = xTaskNotifyWait( 0, /* 进入时不清除任何位 */
                               0, /* 退出时不清除任何位 */
                               pulValue, /* 通知值写入*pulValue */
                               pdMS_TO_TICKS( 250 ) ); /* 最多等待250ms */

    /* 如果xReturn是pdPASS，则获取了值。如果xReturn是pdFAIL，则请求超时。 */
    return xReturn;
}
```

***清单 10.15*** *云读取API函数的实现*

<a name="list10.16" title="清单 10.16 服务器任务处理读取请求"></a>

```c
void ServerTask( void *pvParameters )
{
    CloudCommand_t xCommand;
    uint32_t ulReceivedValue;

    for( ;; )
    {
        /* 等待从任务接收下一个CloudCommand_t结构 */
        xQueueReceive( xServerTaskQueue, &xCommand, portMAX_DELAY );

        switch( xCommand.eOperation ) /* 是读取还是写入请求？ */
        {
            case eRead:

                /* 从远程云服务器获取请求的数据项 */
                ulReceivedValue = GetCloudData( xCommand.ulDataID );

                /* 调用xTaskNotify()将通知和从云服务器接收到的值发送给发出请求的任务。任务的句柄从CloudCommand_t结构中获取。 */
                xTaskNotify( xCommand.xTaskToNotify, /* 任务的句柄在结构中 */
                             ulReceivedValue, /* 作为通知值发送的云数据 */
                             eSetValueWithOverwrite );
                break;

                /* 其他switch情况在此处理。 */
        }
    }
}
```

***清单 10.16*** *服务器任务处理读取请求*

`CloudWrite()` 的伪代码如清单 10.17 所示。为了演示目的，`CloudWrite()` 返回一个位状态代码，其中状态代码中的每一位都有唯一的含义。清单 10.17 顶部的 `#define` 语句显示了四个示例状态位。

任务清除四个状态位，将其请求发送到服务器任务，然后调用 `xTaskNotifyWait()` 以在阻塞状态下等待状态通知。

<a name="list10.17" title="清单 10.17 Cloud Write API 函数的实现"></a>

```c
/* 云写操作使用的状态位。 */
#define SEND_SUCCESSFUL_BIT ( 0x01 << 0 )
#define OPERATION_TIMED_OUT_BIT ( 0x01 << 1 )
#define NO_INTERNET_CONNECTION_BIT ( 0x01 << 2 )
#define CANNOT_LOCATE_CLOUD_SERVER_BIT ( 0x01 << 3 )

/* 设置了四个状态位的掩码。 */
#define CLOUD_WRITE_STATUS_BIT_MASK ( SEND_SUCCESSFUL_BIT |
                                      OPERATION_TIMED_OUT_BIT |
                                      NO_INTERNET_CONNECTION_BIT |
                                      CANNOT_LOCATE_CLOUD_SERVER_BIT )

uint32_t CloudWrite( uint32_t ulDataID, uint32_t ulDataValue )
{
    CloudCommand_t xRequest;
    uint32_t ulNotificationValue;

    /* 设置CloudCommand_t结构体成员以适应此写请求。 */
    xRequest.eOperation = eWrite; /* 这是一个写数据的请求 */
    xRequest.ulDataID = ulDataID; /* 标识正在写入的数据的代码 */
    xRequest.ulDataValue = ulDataValue; /* 写入云服务器的数据值。 */
    xRequest.xTaskToNotify = xTaskGetCurrentTaskHandle(); /* 调用任务的句柄。 */

    /* 通过调用xTaskNotifyWait()，将ulBitsToClearOnExit参数设置为CLOUD_WRITE_STATUS_BIT_MASK，并设置阻塞时间为0，以清除与写操作相关的三个状态位。当前通知值不需要，因此将pulNotificationValue参数设置为NULL。 */
    xTaskNotifyWait( 0, CLOUD_WRITE_STATUS_BIT_MASK, NULL, 0 );

    /* 将请求发送到服务器任务。 */
    xQueueSend( xServerTaskQueue, &xRequest, portMAX_DELAY );

    /* 等待来自服务器任务的通知。服务器任务将位状态码写入此任务的通知值，该值写入ulNotificationValue。 */
    xTaskNotifyWait( 0, /* 入口时不清除任何位。 */
                     CLOUD_WRITE_STATUS_BIT_MASK, /* 退出时将相关位清零。 */
                     &ulNotificationValue, /* 通知值。 */
                     pdMS_TO_TICKS( 250 ) ); /* 最多等待250ms。 */

    /* 将状态码返回给调用任务。 */
    return ( ulNotificationValue & CLOUD_WRITE_STATUS_BIT_MASK );
}
```

***清单 10.17*** *云写入API函数的实现*

展示服务器任务如何管理写入请求的伪代码如清单 10.18所示。当数据已发送到云服务器时，服务器任务解除应用程序任务的阻塞，并通过调用 `xTaskNotify()` 并将 `eAction` 参数设置为 `eSetBits`，将位状态代码发送到应用程序任务。只有由 `CLOUD_WRITE_STATUS_BIT_MASK` 常量定义的位可以在接收任务的通知值中被更改，因此接收任务可以在其通知值的其他位中用于其他目的。

清单 10.18 显示了一个简化的场景，因为它假设 `SetCloudData()` 不需要等待从远程云服务器获得确认。

<a name="list10.18" title="清单 10.18 服务器任务处理发送请求"></a>

```c
void ServerTask( void *pvParameters )
{
    CloudCommand_t xCommand;
    uint32_t ulBitwiseStatusCode;

    for( ;; )
    {
        /* 等待下一条消息。 */
        xQueueReceive( xServerTaskQueue, &xCommand, portMAX_DELAY );

        /* 是读取还是写入请求？ */
        switch( xCommand.eOperation )
        {
            case eWrite:

            /* 将数据发送到远程云服务器。SetCloudData() 返回一个位状态代码，该代码仅使用由 CLOUD_WRITE_STATUS_BIT_MASK 定义的位（如清单 10.17 所示）。 */
            ulBitwiseStatusCode = SetCloudData( xCommand.ulDataID,
                                                xCommand.ulDataValue );

            /* 向发出写入请求的任务发送通知。
               使用 eSetBits 操作，以便在 ulBitwiseStatusCode 中设置的任何状态位都将在被通知的任务的通知值中设置。
               所有其他位保持不变。
               任务的句柄从 CloudCommand_t 结构中获取。 */
            xTaskNotify( xCommand.xTaskToNotify, /* 任务的句柄在结构中 */
                         ulBitwiseStatusCode,    /* 云数据作为通知值发送 */
                         eSetBits );
            break;

            /* 其他 switch 语句在此处。 */
        }
    }
}
```

***清单 10.18*** *服务器任务处理发送请求*


